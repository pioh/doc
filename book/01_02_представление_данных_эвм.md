[← К оглавлению](README.md)

---

# [Глава 1.2](01_02_представление_данных_эвм.md): Представление данных в памяти ЭВМ

## Введение

Окей, теперь ты знаешь, как считать в двоичной системе. Но как вся эта хрень реально хранится в памяти компьютера? Почему один int весит 4 байта, а не 3 или 5? Что за нахрен такое Little Endian и Big Endian? И почему структуры иногда жрут больше памяти, чем должны?

Сейчас разберём, как данные лежат в оперативке, почему процессору удобнее работать с выровненными данными, и что будет, если ты накосячишь с указателями. Это база для понимания не только программирования, но и того, почему твоя программа жрёт дофига памяти или тормозит.

## Память компьютера: адреса и байты

### Оперативная память (RAM)

**Оперативная память (RAM - Random Access Memory)** - это как большой массив байтов, где каждый байт имеет свой адрес. Представь огромную многоэтажку, где у каждой квартиры есть номер. Процессор может обратиться к любому байту напрямую по адресу, не перебирая всё подряд.

Основные фишки RAM:

- **Быстрая**: намного быстрее жесткого диска или SSD
- **Энергозависимая**: выключил комп - всё стёрлось нахрен
- **Случайный доступ**: можно читать/писать в любое место одинаково быстро

### Байт - минимальная единица адресации

**Байт** = 8 бит. Это минимальная порция памяти, к которой можно обратиться по адресу. Почему именно 8 бит? Исторически сложилось - этого достаточно для хранения одного символа ASCII (где нужно всего 7 бит, но 8 удобнее).

```
Байт (8 бит):  [b₇][b₆][b₅][b₄][b₃][b₂][b₁][b₀]
                 ↑                             ↑
            старший                       младший
             (MSB)                          (LSB)
```

Один байт может хранить:

- Число от 0 до 255 (беззнаковое)
- Число от -128 до +127 (знаковое)
- Один символ ASCII
- Один пиксель в градациях серого (256 оттенков)

### Слова, двойные слова и прочая хрень

**Слово (word)** - базовая единица данных для процессора. Размер зависит от архитектуры:

- 16-битные системы: 2 байта
- 32-битные системы: 4 байта
- 64-битные системы: 8 байт

**Двойное слово (dword)** - удвоенный размер слова (например, 4 байта на 16-битной системе).

В современной литературе часто "слово" = 2 байта, "двойное слово" = 4 байта, независимо от архитектуры. Да, это путаница, привыкай.

## Адресация памяти

### Адрес - это просто номер байта

**Адрес** - это целое число, идентифицирующее конкретный байт в памяти. Нумерация начинается с нуля (как индексы массивов в C/C++/Python).

Сколько памяти можно адресовать:

- **16-битная шина**: 2¹⁶ = 64 КБ (привет, MS-DOS!)
- **32-битная шина**: 2³² = 4 ГБ (поэтому на 32-битной Windows больше 4 ГБ не используется)
- **64-битная шина**: 2⁶⁴ ≈ 18 эксабайт (это охуенно много, хватит надолго)

### Little Endian vs Big Endian (война порядков байтов)

Когда нужно сохранить многобайтовое число (например, 32-битный int), возникает вопрос: в каком порядке раскладывать байты?

**Little Endian** (младший байт первым):

- Младший байт лежит по младшему адресу
- Используется в x86/x86-64 (Intel, AMD)
- Большинство современных компов

**Big Endian** (старший байт первым):

- Старший байт лежит по младшему адресу
- Используется в некоторых архитектурах (SPARC, PowerPC)
- Сетевой порядок байтов (network byte order)

### Пример: как хранится 0x12345678

Пусть число 0x12345678 (в шестнадцатеричной) лежит с адреса 1000:

```
Байты числа:
  Байт 3 (старший): 0x12
  Байт 2:           0x34
  Байт 1:           0x56
  Байт 0 (младший): 0x78
```

**Little Endian (x86, твой комп):**

```
Адрес:  1000  1001  1002  1003
Байты:  0x78  0x56  0x34  0x12
         ↑                   ↑
    младший             старший
```

**Big Endian (сетевой порядок):**

```
Адрес:  1000  1001  1002  1003
Байты:  0x12  0x34  0x56  0x78
         ↑                   ↑
    старший             младший
```

**Почему это важно?** Когда отправляешь данные по сети, нужно конвертировать порядок байтов, иначе получатель прочитает херню. Для этого есть функции `htonl`, `ntohl` и т.д.

## Типы данных и их размеры

### Целые числа

```c
char    = 1 байт   (от -128 до 127 или от 0 до 255)
short   = 2 байта  (от -32768 до 32767)
int     = 4 байта  (от -2147483648 до 2147483647)
long    = 4 или 8 байт (зависит от системы, ахаха)
long long = 8 байт (всегда)
```

### Вещественные числа

```c
float   = 4 байта  (32 бита, IEEE 754)
double  = 8 байт   (64 бита, IEEE 754)
```

### Указатели

Размер указателя = размер адресного пространства:

- **32-битная система**: 4 байта
- **64-битная система**: 8 байт

Поэтому на 64-битной системе программа может жрать больше памяти - все указатели в два раза толще.

## Выравнивание данных (alignment)

### Почему процессору лень читать невыравненные данные

**Выравнивание** - это когда данные располагаются по адресам, кратным их размеру. Например, 4-байтовый int лучше класть по адресу, кратному 4 (0, 4, 8, 12, ...).

Почему:

- **Производительность**: процессор читает память блоками (например, по 4 или 8 байт за раз). Если int лежит по адресу, кратному 4, процессор прочитает его за один цикл. Если не кратному - придётся делать два чтения и склеивать.
- **Атомарность**: выровненные данные можно читать/писать атомарно (без прерываний).
- **Некоторые процессоры вообще не умеют**: на некоторых архитектурах (ARM в некоторых режимах) невыравненный доступ вызывает ошибку или работает через жопу медленно.

### Пример: структура с паддингом

```c
struct Example {
    char  a;    // 1 байт
    int   b;    // 4 байта
    char  c;    // 1 байт
};
```

Наивно думаешь: 1 + 4 + 1 = 6 байт. Но реально с выравниванием:

```
Адрес:    0    1    2    3    4    5    6    7    8    9   10   11
Данные:  [a] [---паддинг---][ b  ][ b  ][ b  ][ b  ][c] [---паддинг---]

Размер: 12 байт (ахуеть!)
```

Что произошло:

- `a` занял байт 0
- 3 байта паддинга (1-3), чтобы `b` начинался с адреса 4 (кратно 4)
- `b` занял байты 4-7
- `c` занял байт 8
- 3 байта паддинга (9-11), чтобы размер структуры был кратен 4

**Как сэкономить память?** Переставь поля по убыванию размера:

```c
struct BetterExample {
    int   b;    // 4 байта
    char  a;    // 1 байт
    char  c;    // 1 байт
    // + 2 байта паддинга в конце
};
// Размер: 8 байт вместо 12!
```

## Массивы в памяти

### Одномерные массивы

**Массив** - это просто последовательность элементов одного типа, лежащих подряд в памяти.

Адрес элемента с индексом `i`:

```
Адрес[i] = Базовый_адрес + i × Размер_элемента
```

### Пример: массив int[5]

Массив из 5 целых чисел (по 4 байта) с базовым адресом 2000:

```
Индекс:    0      1      2      3      4
Адрес:  2000   2004   2008   2012   2016
Размер: [  4  ][  4  ][  4  ][  4  ][  4  ] байта
```

- `array[0]` → адрес 2000
- `array[1]` → адрес 2004
- `array[2]` → адрес 2008
- и так далее

### Многомерные массивы: row-major vs column-major

Многомерный массив - это абстракция. В памяти всё хранится линейно. Но как именно?

**Row-major (построчно):**

- Сначала все элементы первой строки, потом второй, и т.д.
- Используется в C/C++/Python

**Column-major (постолбцово):**

- Сначала все элементы первого столбца, потом второго, и т.д.
- Используется в Fortran/MATLAB

### Пример: двумерный массив A[3][4]

```
Элементы:
A[0][0]  A[0][1]  A[0][2]  A[0][3]
A[1][0]  A[1][1]  A[1][2]  A[1][3]
A[2][0]  A[2][1]  A[2][2]  A[2][3]
```

Массив начинается с адреса 3000, элементы по 4 байта.

**Row-major (C/C++):**

Порядок в памяти: A[0][0], A[0][1], A[0][2], A[0][3], A[1][0], ...

Формула адреса:

```
Адрес[i][j] = Базовый_адрес + (i × Число_столбцов + j) × Размер_элемента
```

Адрес A[1][2]:

```
= 3000 + (1 × 4 + 2) × 4
= 3000 + 6 × 4
= 3000 + 24
= 3024
```

**Column-major (Fortran):**

Порядок в памяти: A[0][0], A[1][0], A[2][0], A[0][1], ...

Формула адреса:

```
Адрес[i][j] = Базовый_адрес + (j × Число_строк + i) × Размер_элемента
```

Адрес A[1][2]:

```
= 3000 + (2 × 3 + 1) × 4
= 3000 + 7 × 4
= 3000 + 28
= 3028
```

**Почему это важно?** Если обходишь массив в неправильном порядке, кэш процессора работает хуево, и программа тормозит. Всегда обходи массивы в том порядке, в котором они лежат в памяти.

## Стек и куча: где что лежит

### Сегменты памяти процесса

Когда запускается программа, ОС выделяет ей память, разделённую на сегменты:

1. **Сегмент кода (text)**: машинные инструкции программы (read-only)
2. **Сегмент данных (data)**: глобальные и статические переменные
3. **Стек (stack)**: локальные переменные, параметры функций, адреса возврата
4. **Куча (heap)**: динамически выделяемая память (malloc, new)

### Стек (Stack)

**Стек** работает по принципу LIFO (Last In, First Out - последним пришёл, первым ушёл). Как стопка тарелок: кладёшь сверху, берёшь сверху.

При вызове функции на стек кладутся:

- Параметры функции
- Адрес возврата (куда вернуться после функции)
- Локальные переменные

При выходе из функции всё это снимается со стека.

**Плюсы стека:**

- Быстро: просто двигаешь указатель стека (stack pointer)
- Автоматическое управление: не нужно вручную освобождать память

**Минусы стека:**

- Ограниченный размер (обычно 1-8 МБ)
- Переполнение стека (stack overflow) - если слишком много рекурсий или большие локальные массивы

### Куча (Heap)

**Куча** - область памяти для динамического выделения блоков произвольного размера. Ты явно просишь память (`malloc`, `new`) и должен явно её освободить (`free`, `delete`).

**Плюсы кучи:**

- Гибкость: можешь выделять сколько угодно (в пределах доступной памяти)
- Больше места: куча может быть гигабайтами

**Минусы кучи:**

- Медленнее: выделение и освобождение требует работы менеджера памяти
- Ручное управление: забыл освободить → утечка памяти (memory leak)
- Фрагментация: куча может быть раздроблена на куски

### Пример: что где лежит

```c
void function() {
    int localVar = 42;                           // СТЕК
    int* heapArray = malloc(sizeof(int) * 100); // Сам массив в КУЧЕ
                                                 // Указатель heapArray в СТЕКЕ
    heapArray[0] = 10;
    free(heapArray);
}
```

- `localVar` - локальная переменная → **стек**
- Массив из 100 int - динамический → **куча**
- `heapArray` (сам указатель) → **стек** (это локальная переменная, хранящая адрес)

**Типичные косяки:**

- **Stack overflow**: рекурсия на миллион вызовов или локальный массив `int arr[10000000]`
- **Memory leak**: забыл `free(heapArray)` → память утекла
- **Dangling pointer**: освободил память, но указатель остался, и ты пытаешься по нему обратиться → segfault (пизда программе)

## Почему это всё важно?

### Где это применяется:

1. **Оптимизация программ**: правильное использование типов данных и выравнивание структур ускоряет программу
2. **Отладка**: понимание памяти помогает находить баги типа выхода за границы массива или повреждения памяти
3. **Низкоуровневое программирование**: работа с железом, драйверами, ОС требует понимания памяти
4. **Сетевое программирование**: обмен данными между системами с разным порядком байтов
5. **Встраиваемые системы**: каждый байт на счету, нужно экономить память
6. **Безопасность**: большинство уязвимостей (buffer overflow, stack smashing) основаны на особенностях памяти

## Основные термины

**Оперативная память (RAM)** - быстрая энергозависимая память для временного хранения данных.

**Байт** - 8 бит, минимальная адресуемая единица памяти.

**Адрес** - уникальный номер ячейки памяти.

**Слово (word)** - базовая единица данных для процессора.

**Little Endian** - младший байт по младшему адресу (Intel/AMD).

**Big Endian** - старший байт по младшему адресу (сетевой порядок).

**Выравнивание (alignment)** - размещение данных по адресам, кратным их размеру.

**Паддинг (padding)** - заполнение пустых байтов для выравнивания.

**Стек (stack)** - память для локальных переменных, работает по принципу LIFO.

**Куча (heap)** - память для динамического выделения блоков.

**Memory leak** - утечка памяти, когда забыл освободить.

**Dangling pointer** - висячий указатель на освобождённую память.

## Контрольные вопросы

1. **Теория**: Почему байт стал стандартом минимальной адресуемой единицы?

2. **Практика**: Число 0x123456789ABCDEF0 хранится с адреса 5000 в Little Endian. Запиши содержимое байтов 5000-5007.

3. **Выравнивание**: Рассчитай размер (с учётом выравнивания по 8 байт) структуры:

   ```c
   struct Data {
       char   a;     // 1 байт
       double b;     // 8 байт
       short  c;     // 2 байта
       int    d;     // 4 байта
   };
   ```

4. **Многомерные массивы**: Массив `B[2][3][4]` из int (4 байта) начинается с адреса 6000 (row-major). Найди адрес `B[1][2][1]`.

5. **Концепт**: В чём разница между стеком и кучей? Когда использовать каждый из них?

## Связь с другими главами

- [**Глава 1.1**](01_01_арифметика_двоичная.md) - двоичная арифметика, основа для понимания битов и байтов
- [**Глава 1.9**](01_09_представление_числовых_данных.md) - представление числовых данных (прямой/обратный/дополнительный код)
- [**Глава 2.1**](02_01_архитектура_эвм.md) - архитектура ЭВМ, как процессор работает с памятью
- [**Глава 3.1**](03_01_операционные_системы.md) - операционные системы, управление памятью

## Резюме

Что запомнить:

✅ Память - это массив байтов с адресами  
✅ Байт = 8 бит, минимальная адресуемая единица  
✅ Little Endian (x86) vs Big Endian (сеть)  
✅ Выравнивание экономит процессор, но жрёт память  
✅ Стек - быстро, автоматически, но ограничено  
✅ Куча - гибко, много места, но нужно следить за утечками  
✅ Понимание памяти = меньше багов и быстрее программы

Теперь ты знаешь, как данные реально хранятся в памяти. Это не абстрактные переменные, а конкретные байты по конкретным адресам. И теперь ты понимаешь, почему segfault - это пиздец.

---

_Конец главы_


---

[← К оглавлению](README.md)

*Глава 1.2: Представление данных в памяти ЭВМ*
