[← К оглавлению](README.md)

---

# [Глава 2.1](02_01_архитектура_эвм.md): Понятие архитектуры и структуры ЭВМ

## Введение

Итак, первый раздел позади — мы разобрались, как компьютер кодирует информацию, считает в двоичной системе и что происходит в памяти. Теперь пора выяснить, **что вообще из себя представляет эта машина**, которая всё это делает. Ведь понимание того, как устроен компьютер «внутри», — это как знание анатомии для врача. Без этого ты просто тыкаешь пальцем в небо и надеешься, что всё заработает.

В этой главе мы разберёмся с фундаментальными понятиями **архитектуры** и **структуры** ЭВМ. Это не просто абстрактные термины из учебника — это основа, на которой строится всё: от выбора процессора для игрового ПК до проектирования суперкомпьютеров. Понимание архитектуры позволит тебе осознанно подходить к оптимизации программ, оценивать производительность систем и не задавать вопросы в духе «а почему у меня тормозит?» (хотя, будем честны, всё равно будет тормозить, но хоть будешь знать почему).

Эта глава тесно связана с главой 1.2 (Представление данных в памяти ЭВМ), где мы говорили про организацию памяти, и является прологом к главам 2.2 (История ЭВМ) и 2.3 (Принципы фон Неймана), где копнём глубже в историю и архитектурные принципы.

## Архитектура vs Структура: разбираемся в терминологии

Первое, что нужно понять: **архитектура** и **структура** — это не синонимы. Их часто путают, но это разные уровни абстракции.

### Архитектура ЭВМ

**Архитектура ЭВМ** (computer architecture) — это **концептуальное представление** вычислительной машины, видимое программисту. Грубо говоря, это то, **что** компьютер умеет делать, а не **как** он это делает на физическом уровне.

Архитектура включает:
- **Система команд** (instruction set architecture, ISA) — какие инструкции понимает процессор
- **Типы данных** — какие форматы чисел, символов и т.д. поддерживаются
- **Регистры** — сколько их, какого размера, для чего используются
- **Режимы адресации** — как процессор обращается к памяти
- **Способы ввода-вывода** — как процессор общается с периферией

**Пример**: x86-64 и ARM — это две разные архитектуры. Программа, написанная для x86-64, не запустится на ARM без специальных костылей (эмуляции или перекомпиляции), потому что у них разный набор инструкций.

### Структура ЭВМ

**Структура ЭВМ** (computer organization) — это **физическая реализация** архитектуры. Это **как** именно устроены компоненты на уровне железа.

Структура включает:
- **Количество ядер процессора** и их взаимодействие
- **Организация кэш-памяти** (уровни кэша, размеры)
- **Тип системной шины** и её характеристики
- **Конкретные схемы АЛУ**, блоков управления и т.д.
- **Технология изготовления** (техпроцесс, частоты)

**Пример**: Intel Core i7 и AMD Ryzen — оба реализуют архитектуру x86-64, но имеют разную **структуру**: разное количество ядер, разную организацию кэша, разные техпроцессы.

### Аналогия для понимания

Представь, что архитектура — это **интерфейс** (API) программы: «есть функция `сложить(a, b)`, которая возвращает сумму». А структура — это **конкретная реализация** этой функции: можно написать её на Python за 1 строчку, можно на ассемблере с оптимизацией под каждый процессор. Интерфейс один, реализаций — тысяча.

## Уровни представления компьютера

Компьютер можно рассматривать на разных уровнях абстракции — от физики транзисторов до высокоуровневых языков программирования. Это называется **иерархией уровней**.

### 6 уровней абстракции

1. **Физический уровень** (transistor level)
   - Транзисторы, электрические сигналы, напряжения
   - Тут работают инженеры-электронщики
   - Нас это волнует только когда компьютер сгорел

2. **Логический уровень** (gate level)
   - Логические элементы: И, ИЛИ, НЕ (помнишь [главу 1.6](01_06_алгебра_высказываний.md)?)
   - Триггеры, сумматоры, мультиплексоры
   - Тут проектируют микросхемы

3. **Уровень микроархитектуры** (microarchitecture level)
   - Регистры, АЛУ, блоки управления
   - Как инструкции выполняются внутри процессора (конвейер, суперскалярность)
   - Разработчики процессоров работают на этом уровне

4. **Уровень архитектуры команд** (ISA level)
   - Система команд: ADD, MOV, JMP и т.д.
   - Программирование на ассемблере
   - Это граница между железом и софтом

5. **Уровень операционной системы** (OS level)
   - Файлы, процессы, потоки, управление памятью
   - Системные вызовы (open, read, write)
   - Тут живут разработчики ОС и драйверов

6. **Уровень прикладных программ** (application level)
   - Высокоуровневые языки: Python, Java, C++
   - Библиотеки, фреймворки
   - Обычные программисты работают тут

**Важно**: В этой главе мы сосредоточимся на уровнях 3-4 (микроархитектура и ISA), потому что именно они определяют понятия «архитектура» и «структура» ЭВМ.

## Основные компоненты ЭВМ

Любой компьютер, от смартфона до суперкомпьютера, состоит из **четырёх основных компонентов**. Это не просто декларация — это следствие **принципов фон Неймана** (о них подробнее в [главе 2.3](02_03_классы_эвм_принципы.md)).

### 1. Процессор (CPU — Central Processing Unit)

**Процессор** — это мозг компьютера. Он выполняет программы, обрабатывает данные, управляет всеми остальными устройствами. Процессор состоит из двух основных блоков:

#### Арифметико-логическое устройство (АЛУ)

**АЛУ** (англ. ALU — Arithmetic Logic Unit) выполняет:
- **Арифметические операции**: сложение, вычитание, умножение, деление (привет, [глава 1.1](01_01_арифметика_двоичная.md)!)
- **Логические операции**: И, ИЛИ, НЕ, XOR ([глава 1.6](01_06_алгебра_высказываний.md) на связи)
- **Операции сдвига**: сдвиги битов влево/вправо
- **Операции сравнения**: больше, меньше, равно

АЛУ работает с **регистрами** — сверхбыстрыми ячейками памяти внутри процессора.

#### Устройство управления (УУ)

**УУ** (англ. CU — Control Unit) — это дирижёр оркестра. Оно:
- **Извлекает инструкции** из памяти (fetch)
- **Декодирует** их (decode) — определяет, что нужно делать
- **Выполняет** (execute) — отдаёт команды АЛУ, памяти, устройствам ввода-вывода
- **Управляет** последовательностью операций

### 2. Память (Memory)

**Оперативная память** (ОЗУ, RAM) — это временное хранилище для данных и программ во время их выполнения. Мы уже обсуждали её организацию в [главе 1.2](01_02_представление_данных_эвм.md).

Типы памяти по иерархии (от быстрой к медленной):
1. **Регистры** — внутри процессора, доступ за 1 такт
2. **Кэш L1/L2/L3** — буферная память, доступ за 3-30 тактов
3. **ОЗУ (RAM)** — основная память, доступ за 100-300 тактов
4. **ПЗУ (ROM)** — постоянная память (BIOS/UEFI)
5. **Внешняя память** (SSD/HDD) — долговременное хранение, доступ за миллионы тактов

**Важно**: Чем ближе память к процессору, тем она быстрее, но и дороже. Поэтому регистров — десятки байт, кэша — мегабайты, RAM — гигабайты, SSD — терабайты.

### 3. Системная магистраль (шина)

**Шина** (bus) — это набор линий связи, по которым передаются данные между компонентами. Шина состоит из трёх частей:

#### Шина данных (Data Bus)

Передаёт **собственно данные** между процессором, памятью и устройствами. Разрядность шины данных определяет, сколько бит можно передать за один раз:
- 8-разрядная шина: 1 байт за раз
- 32-разрядная шина: 4 байта за раз
- 64-разрядная шина: 8 байт за раз

**Пример**: Если процессор 64-разрядный, а шина данных 64-битная, то за один такт можно прочитать/записать 8 байт.

#### Адресная шина (Address Bus)

Передаёт **адреса** ячеек памяти или устройств. Разрядность адресной шины определяет **объём адресуемой памяти**:
- 16-разрядная шина: 2¹⁶ = 64 КБ адресного пространства
- 32-разрядная шина: 2³² = 4 ГБ
- 64-разрядная шина: 2⁶⁴ ≈ 16 эксабайт (теоретически)

**Прим. для умных**: На практике современные x86-64 процессоры используют не все 64 бита для адресации (обычно 48 или 52), что даёт 256 ТБ или 4 ПБ адресного пространства — более чем достаточно.

#### Шина управления (Control Bus)

Передаёт **управляющие сигналы**: чтение/запись, готовность, прерывание и т.д. Это как светофоры на дороге: без них все бы врезались друг в друга.

### 4. Устройства ввода-вывода (I/O Devices)

**Устройства ввода**: клавиатура, мышь, микрофон, камера, сканер — всё, что позволяет **ввести данные** в компьютер.

**Устройства вывода**: монитор, принтер, динамики — всё, что **выводит результат** работы.

**Устройства ввода-вывода**: сетевая карта, жёсткий диск, USB-устройства — могут и принимать, и передавать данные.

## Функциональная схема ЭВМ

Теперь соберём всё вместе. Вот упрощённая схема взаимодействия компонентов:

```
┌───────────────────────────────────────────────────┐
│                   ПРОЦЕССОР (CPU)                 │
│  ┌─────────────────┐      ┌───────────────────┐  │
│  │ Устройство      │      │  АЛУ (арифметико- │  │
│  │ управления (УУ) │◄────►│  логическое       │  │
│  │                 │      │  устройство)      │  │
│  └────────┬────────┘      └─────────┬─────────┘  │
│           │                         │            │
│           └─────────┬───────────────┘            │
│                     │ Регистры                   │
└─────────────────────┼────────────────────────────┘
                      │
        ┌─────────────┼─────────────┐
        │   СИСТЕМНАЯ МАГИСТРАЛЬ    │
        │  ┌───────────────────┐    │
        │  │  Шина данных      │    │
        │  ├───────────────────┤    │
        │  │  Адресная шина    │    │
        │  ├───────────────────┤    │
        │  │  Шина управления  │    │
        │  └───────────────────┘    │
        └─────────┬─────────────────┘
                  │
    ┌─────────────┼─────────────────────────┐
    │             │                         │
┌───▼────┐   ┌───▼───┐   ┌─────────────────▼──┐
│ Память │   │  ПЗУ  │   │ Устройства         │
│  (ОЗУ) │   │ (ROM) │   │ ввода-вывода       │
│  (RAM) │   │       │   │ (I/O)              │
└────────┘   └───────┘   └────────────────────┘
```

**Как это работает**:
1. **УУ** извлекает инструкцию из **памяти** через **адресную шину**
2. **УУ** декодирует инструкцию и определяет, что делать
3. Если нужны данные — **УУ** читает их из **памяти** через **шину данных**
4. **АЛУ** выполняет операцию над данными
5. Результат записывается обратно в **память** или **регистр**
6. **УУ** переходит к следующей инструкции

Этот цикл называется **цикл выборки-выполнения** (fetch-decode-execute cycle) и повторяется миллиарды раз в секунду.

## Характеристики производительности ЭВМ

Теперь поговорим о том, **как оценить, насколько быстр компьютер**. Спойлер: просто посмотреть на частоту процессора — это как оценивать машину только по объёму двигателя. Важно, но не достаточно.

### Разрядность

**Разрядность процессора** — это количество бит, обрабатываемых за одну операцию. Она определяется разрядностью:
- **Регистров** (сколько бит помещается в регистр)
- **АЛУ** (сколько бит АЛУ обрабатывает за раз)
- **Шины данных** (сколько бит передаётся за такт)

Исторически процессоры эволюционировали: 4-бит → 8-бит → 16-бит → 32-бит → 64-бит.

**Практическое значение**:
- **8-битный процессор**: может сложить числа 0-255 за одну операцию (или -128 до +127 со знаком)
- **32-битный**: работает с числами до 4 млрд, адресует до 4 ГБ памяти
- **64-битный**: работает с огромными числами, адресует эксабайты памяти

### Тактовая частота

**Тактовая частота** (clock frequency) — это количество тактов процессора в секунду, измеряется в герцах (Гц).

**1 Гц** = 1 такт в секунду  
**1 МГц** = 1 миллион тактов в секунду  
**1 ГГц** = 1 миллиард тактов в секунду

**Пример**: Процессор с частотой 3 ГГц выполняет 3 миллиарда тактов в секунду.

**Важно**: Частота ≠ производительность! Разные процессоры выполняют разное количество инструкций за такт. Современные процессоры используют **конвейеризацию** и **суперскалярность**, выполняя несколько инструкций за такт.

### Пример 1: Вычисление количества инструкций в секунду

**Задача**: Процессор работает на частоте 2.5 ГГц и выполняет в среднем 2 инструкции за такт (IPC = instructions per cycle). Сколько инструкций в секунду он выполняет?

**Решение**:
```
Количество инструкций = Частота × IPC
Количество инструкций = 2.5 ГГц × 2 = 5 млрд инструкций/сек = 5 GIPS
```

**Ответ**: 5 миллиардов инструкций в секунду (5 GIPS).

### Пропускная способность шины

**Пропускная способность** (bandwidth) — это объём данных, передаваемых за единицу времени. Для шины данных:

```
Пропускная способность = (Разрядность шины / 8) × Частота шины
```

Разрядность делим на 8, чтобы перевести биты в байты.

### Пример 2: Расчёт пропускной способности памяти

**Задача**: Оперативная память DDR4-3200 имеет 64-битную шину данных и работает на эффективной частоте 3200 МГц. Какова её пропускная способность?

**Решение**:
```
Пропускная способность = (64 бита / 8) × 3200 МГц
                       = 8 байт × 3200 МГц
                       = 25 600 МБ/с
                       = 25.6 ГБ/с
```

**Ответ**: 25.6 ГБ/с (гигабайт в секунду).

**Примечание**: На практике пропускная способность может быть ниже из-за задержек (латентности) и других факторов.

### Время доступа к памяти

**Время доступа** (access time, latency) — это задержка между запросом данных и их получением. Измеряется в наносекундах (нс) или тактах процессора.

### Пример 3: Сравнение времени доступа к разным уровням памяти

**Задача**: Процессор работает на частоте 3 ГГц (период такта = 0.33 нс). Сравним время доступа к разным типам памяти:

- Регистр: 1 такт
- Кэш L1: 4 такта
- Кэш L2: 12 тактов
- Кэш L3: 40 тактов
- ОЗУ (RAM): 200 тактов
- SSD: ~100 000 тактов
- HDD: ~10 000 000 тактов

**Решение** (переведём в наносекунды):

| Тип памяти | Такты | Время (нс)     | Время (человеческое) |
|-----------|-------|----------------|---------------------|
| Регистр   | 1     | 0.33 нс        | 1 секунда           |
| Кэш L1    | 4     | 1.3 нс         | 4 секунды           |
| Кэш L2    | 12    | 4 нс           | 12 секунд           |
| Кэш L3    | 40    | 13 нс          | 40 секунд           |
| RAM       | 200   | 67 нс          | 3.3 минуты          |
| SSD       | 100K  | 33 мкс         | 9.3 часа            |
| HDD       | 10M   | 3.3 мс         | 38 дней             |

**Аналогия**: Если доступ к регистру занимает 1 секунду, то доступ к жёсткому диску — это как ждать больше месяца. Вот почему кэширование так важно!

## Примеры архитектур

Теперь посмотрим на **реальные архитектуры**, с которыми ты сталкиваешься каждый день.

### x86 и x86-64 (AMD64, Intel 64)

**x86** — это архитектура, разработанная Intel в 1978 году (процессор 8086). 32-битная версия называется **IA-32** (Intel Architecture, 32-bit), 64-битное расширение — **x86-64** (или AMD64, потому что AMD первой его сделала, к ужасу Intel).

**Особенности**:
- **CISC** (Complex Instruction Set Computer) — сложная система команд, есть инструкции для всего
- Используется в большинстве ПК, ноутбуков, серверов
- Обратная совместимость: программы для 8086 (1978!) теоретически могут работать на современном i9

### ARM (Advanced RISC Machine)

**ARM** — это архитектура, используемая в мобильных устройствах, встраиваемых системах, а теперь и в ноутбуках (привет, Apple M1/M2/M3).

**Особенности**:
- **RISC** (Reduced Instruction Set Computer) — упрощённая система команд, каждая инструкция проста и быстра
- Энергоэффективность: меньше потребление, меньше тепловыделение
- Используется в смартфонах (все iPhone и Android), планшетах, роутерах, умных чайниках

### RISC-V

**RISC-V** — новая открытая архитектура, набирающая популярность.

**Особенности**:
- Открытая спецификация (не нужно платить лицензионные отчисления)
- Модульная: можно собрать процессор под конкретную задачу
- Используется в исследованиях, встраиваемых системах, постепенно проникает везде

### Пример 4: Сравнение выполнения операции на CISC и RISC

**Задача**: Нужно выполнить операцию «прибавить значение из памяти к регистру». Сравним подходы x86 (CISC) и ARM (RISC).

**x86 (CISC)**:
```asm
ADD EAX, [1000h]    ; Одна инструкция: читает из памяти и складывает
```
- 1 инструкция
- Сложная: читает память, складывает, записывает результат
- Выполняется за несколько тактов (зависит от кэша)

**ARM (RISC)**:
```asm
LDR R1, [R2]        ; Загрузить из памяти в регистр R1
ADD R0, R0, R1      ; Сложить R0 и R1, результат в R0
```
- 2 инструкции
- Каждая простая: выполняется за 1 такт (в идеале)

**Итог**: CISC — меньше инструкций, но каждая сложнее. RISC — больше инструкций, но каждая проще и быстрее. Что лучше? Зависит от задачи. На практике современные CISC процессоры внутри разбивают сложные инструкции на простые микрооперации (привет, микроархитектура!).

## Производительность: как считать правильно

Финальный вопрос: **как оценить реальную производительность** процессора? Есть несколько метрик.

### MIPS и GIPS

**MIPS** (Million Instructions Per Second) — миллионы инструкций в секунду.  
**GIPS** (Giga Instructions Per Second) — миллиарды инструкций в секунду.

```
MIPS = (Тактовая частота × IPC) / 1 000 000
GIPS = (Тактовая частота × IPC) / 1 000 000 000
```

**Проблема**: Разные инструкции на разных архитектурах делают разное. Сложение на ARM ≠ сложению на x86. Поэтому MIPS — это «Meaningless Indication of Processor Speed» (бессмысленный индикатор скорости процессора), как шутят программисты.

### FLOPS

**FLOPS** (Floating Point Operations Per Second) — операций с плавающей точкой в секунду. Используется для оценки производительности в научных вычислениях.

- **MFLOPS** = миллион FLOPS
- **GFLOPS** = миллиард FLOPS (гигафлопс)
- **TFLOPS** = триллион FLOPS (терафлопс)
- **PFLOPS** = квадриллион FLOPS (петафлопс)

### Пример 5: Расчёт теоретической производительности в FLOPS

**Задача**: Процессор имеет 8 ядер, каждое работает на частоте 3 ГГц. Каждое ядро может выполнять 16 операций с плавающей точкой за такт (благодаря векторным инструкциям AVX-512). Какова теоретическая пиковая производительность?

**Решение**:
```
FLOPS = Количество ядер × Частота × Операций за такт
FLOPS = 8 × 3 ГГц × 16
FLOPS = 8 × 3 × 10⁹ × 16
FLOPS = 384 × 10⁹
FLOPS = 384 GFLOPS = 0.384 TFLOPS
```

**Ответ**: 384 гигафлопс (или 0.384 терафлопс).

**Примечание**: Это **теоретический пик**. На практике достичь его невозможно из-за задержек памяти, ветвлений в коде и других факторов. Реальная производительность обычно 30-70% от пика.

### Benchmark-тесты

**Benchmark** — это стандартный набор задач, на которых тестируют производительность. Примеры:
- **SPEC CPU** — тесты процессора на разных задачах
- **Geekbench** — популярный кроссплатформенный бенчмарк
- **Cinebench** — тест рендеринга 3D-сцен
- **3DMark** — тесты графики и игр

**Важно**: Не существует единого числа, описывающего производительность. В одних задачах быстрее ARM, в других x86. Поэтому смотри бенчмарки, релевантные твоей задаче.

## Практическая значимость

Зачем всё это знать?

1. **Выбор железа**: Понимая архитектуру, ты не купишь процессор с 16 ядрами по 2 ГГц для игр (где важна частота одного ядра), а не количество ядер.

2. **Оптимизация программ**: Зная про кэш и задержки памяти, ты можешь оптимизировать алгоритмы так, чтобы они работали в 10-100 раз быстрее.

3. **Портирование ПО**: Понимая разницу между x86 и ARM, ты не удивишься, почему программа работает на ПК, но не на Raspberry Pi.

4. **Отладка**: Знание архитектуры помогает понять, почему программа падает с segmentation fault (обращение к несуществующему адресу).

5. **Карьера**: Разработчики ОС, компиляторов, драйверов, встраиваемых систем **обязаны** знать архитектуру. Это не просто «для общего развития».

## Ключевые термины и определения

- **Архитектура ЭВМ** — концептуальное представление компьютера, видимое программисту (система команд, регистры, типы данных).

- **Структура ЭВМ** — физическая реализация архитектуры (конкретные схемы, количество ядер, организация кэша).

- **Процессор (CPU)** — центральное вычислительное устройство, выполняющее программы.

- **АЛУ (арифметико-логическое устройство)** — часть процессора, выполняющая арифметические и логические операции.

- **Устройство управления (УУ)** — часть процессора, управляющая выполнением инструкций.

- **Регистр** — сверхбыстрая ячейка памяти внутри процессора.

- **Системная магистраль (шина)** — набор линий связи между компонентами компьютера.

- **Шина данных** — передаёт данные между компонентами.

- **Адресная шина** — передаёт адреса ячеек памяти.

- **Шина управления** — передаёт управляющие сигналы (чтение/запись, прерывания и т.д.).

- **Разрядность процессора** — количество бит, обрабатываемых за одну операцию.

- **Тактовая частота** — количество тактов процессора в секунду (измеряется в Гц).

- **Пропускная способность** — объём данных, передаваемых за единицу времени.

- **Время доступа (латентность)** — задержка между запросом данных и их получением.

- **CISC** (Complex Instruction Set Computer) — архитектура со сложным набором команд (пример: x86).

- **RISC** (Reduced Instruction Set Computer) — архитектура с упрощённым набором команд (пример: ARM, RISC-V).

- **IPC** (Instructions Per Cycle) — количество инструкций, выполняемых за один такт.

- **FLOPS** (Floating Point Operations Per Second) — операций с плавающей точкой в секунду.

## Контрольные вопросы для самопроверки

1. **Концептуальный вопрос**: Объясните разницу между архитектурой и структурой ЭВМ. Приведите пример двух процессоров с одинаковой архитектурой, но разной структурой.

2. **Практическая задача**: Процессор имеет 32-битную адресную шину. Сколько байт памяти он может адресовать? Почему 32-битные версии Windows не могут использовать более 4 ГБ RAM?

3. **Задача на вычисление**: Оперативная память DDR5-6400 имеет 64-битную шину данных и работает на эффективной частоте 6400 МГц. Рассчитайте её теоретическую пропускную способность в ГБ/с.

4. **Задача на архитектуры**: Процессор ARM работает на частоте 2 ГГц и выполняет в среднем 3 инструкции за такт. Процессор x86 работает на частоте 3.5 ГГц и выполняет 2 инструкции за такт. Какой из них выполняет больше инструкций в секунду? Означает ли это, что он быстрее во всех задачах?

5. **Сложный вопрос**: Почему, несмотря на огромный рост тактовых частот (от 1 МГц в 1970-х до 5 ГГц сейчас), производительность процессоров выросла ещё сильнее? Какие архитектурные приёмы, помимо увеличения частоты, повышают производительность? (Подсказка: конвейеризация, кэш, многоядерность)

---

**Связь с другими главами**:
- [Глава 1.2](01_02_представление_данных_эвм.md) (Представление данных в памяти) — организация памяти и адресация
- [Глава 1.6](01_06_алгебра_высказываний.md) (Алгебра высказываний) — логические элементы, из которых строится АЛУ
- [Глава 2.2](02_02_история_эвм.md) (История ЭВМ) — эволюция архитектур от первых компьютеров до современных
- [Глава 2.3](02_03_классы_эвм_принципы.md) (Принципы фон Неймана) — фундаментальные принципы организации ЭВМ

---

_Глава подготовлена в соответствии со спецификацией учебника. Объём: ~14500 символов._


---

[← К оглавлению](README.md)

*Глава 2.1: Понятие архитектуры и структуры ЭВМ*
