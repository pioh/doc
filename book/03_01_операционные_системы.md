[← К оглавлению](README.md)

---

# [Глава 3.1](03_01_операционные_системы.md): Операционные системы. Назначение и классификация

## Введение

Итак, в разделе 2 мы разобрались, что железо бывает разное: от суперкомпьютера за полмиллиарда долларов до Arduino за 500 рублей. Все эти железки работают по принципам фон Неймана ([Глава 2.3](02_03_классы_эвм_принципы.md)), но сами по себе они бесполезны. Процессор без программы — это просто кусок кремния, который потребляет электричество и греется.

Чтобы заставить компьютер что-то делать, нужна **операционная система** (ОС). Это посредник между железом и всеми твоими программами. Без ОС тебе пришлось бы писать код, который напрямую управляет процессором, памятью, жёсткими дисками, сетевыми картами — в общем, полный ад. ОС делает всю грязную работу за тебя.

В этой главе разберём: что такое ОС, зачем она нужна, какие бывают, и почему Linux-фанаты всегда пытаются тебя переубедить поставить Arch (не ставь, если ценишь своё время).

---

## 3.1.1. Что такое операционная система?

**Операционная система (ОС, Operating System, OS)** — это комплекс программ, которые управляют аппаратными ресурсами компьютера и предоставляют сервисы для пользовательских приложений.

**Аналогия:** представь, что компьютер — это ресторан. Процессор — повар, память — холодильник, диск — кладовая, клавиатура с мышкой — посетители. ОС — это менеджер ресторана, который:
- Принимает заказы от посетителей (программ).
- Распределяет работу повара (планирование процессов).
- Следит, чтобы продукты не протухли в холодильнике (управление памятью).
- Заказывает новые продукты со склада (управление дисками).
- Не даёт одному посетителю съесть заказ другого (защита памяти).

Без менеджера ресторан превратится в хаос. Так же и с компьютером.

---

### Функции операционной системы

ОС выполняет кучу задач, но основные можно разделить на пять категорий:

#### 1. Управление процессами (Process Management)

**Процесс** — это программа в процессе выполнения. Открыл браузер — запустился процесс. Открыл ещё 20 вкладок — запустилось ещё 20 процессов (Chrome, привет).

**Что делает ОС:**
- **Создание и уничтожение процессов**: запускает программу, выделяет ей память, завершает её, когда она закончилась (или зависла).
- **Планирование (Scheduling)**: решает, какой процесс будет выполняться на процессоре в данный момент. У тебя 100 процессов, но только 8 ядер процессора — ОС переключается между процессами тысячи раз в секунду, создавая иллюзию, что все работают одновременно.
- **Многозадачность (Multitasking)**: одновременное выполнение нескольких программ. Бывает **вытесняющая** (preemptive) — ОС насильно отбирает процессор у одной программы и отдаёт другой, и **невытесняющая** (cooperative) — программа сама должна отдать управление (древний Windows 3.1 работал так, одна зависшая программа клала всю систему).

**Пример:** Ты запустил игру, браузер, Telegram и Spotify. Процессор Intel i7 (8 ядер, 16 потоков) физически может выполнять 16 задач одновременно. Но у тебя 200 процессов в диспетчере задач. ОС переключается между ними каждые **10-100 миллисекунд** (time slice, квант времени). Для тебя это выглядит, как будто всё работает параллельно.

---

#### 2. Управление памятью (Memory Management)

**Задача:** распределить оперативную память (RAM) между всеми процессами так, чтобы они не мешали друг другу и не крашили систему.

**Что делает ОС:**
- **Выделение и освобождение памяти**: программа запросила 100 MB — ОС выделяет. Программа закрылась — ОС освобождает память.
- **Виртуальная память (Virtual Memory)**: у тебя 16 GB RAM, но система позволяет процессам думать, что у каждого есть терабайты памяти. Как? **Подкачка страниц** (paging): если память кончилась, ОС сбрасывает редко используемые данные на диск (файл подкачки, swap) и подгружает обратно, когда нужно.
- **Защита памяти**: один процесс не может залезть в память другого процесса (это называется **изоляция адресных пространств**). Иначе был бы ад: одна программа случайно перезаписала данные другой, и всё сломалось.

**Пример виртуальной памяти:** У тебя 16 GB RAM. Запустил Photoshop (съел 8 GB), Chrome с 50 вкладками (ещё 6 GB), игру (4 GB). Итого: 18 GB. Но памяти только 16 GB. ОС выгружает на диск неиспользуемые данные Chrome (ты давно не смотрел вкладку "Как варить гречку"), освобождая 2 GB. Когда переключишься обратно на вкладку — ОС подгрузит данные с диска. Медленнее, зато не краш.

**Страничная организация памяти:** память делится на блоки фиксированного размера — **страницы** (обычно 4 KB). Процесс работает с виртуальными адресами, а ОС переводит их в физические адреса через **таблицу страниц** (Page Table). Это основа виртуальной памяти.

---

#### 3. Управление файловой системой (File System Management)

**Файловая система (FS)** — это способ организации данных на диске. Без неё диск — это просто куча нулей и единиц.

**Что делает ОС:**
- Создание, чтение, запись, удаление файлов.
- Организация файлов в иерархию директорий (папок).
- Управление правами доступа (кто может читать/писать файл).
- Журналирование (journaling) — запись всех операций с файлами, чтобы восстановить данные после краша.

**Популярные файловые системы:**

| ФС      | Используется в  | Макс. размер файла | Журналирование | Особенности                              |
|---------|----------------|--------------------|----------------|------------------------------------------|
| **FAT32**   | USB-флешки, старые Windows | 4 GB               | Нет            | Совместима с любой ОС, но ограничения древние |
| **NTFS**    | Windows        | 16 EB (экзабайт)   | Да             | Права доступа, шифрование, сжатие        |
| **ext4**    | Linux          | 16 TB              | Да             | Быстрая, надёжная, стандарт для Linux    |
| **APFS**    | macOS, iOS     | 8 EB               | Да             | Оптимизирована под SSD, снапшоты         |
| **Btrfs**   | Linux (новая)  | 16 EB              | Да             | Copy-on-write, снапшоты, RAID            |

**Пример:** Скачал файл размером 5 GB. FAT32 не поддерживает файлы больше 4 GB, система выдаст ошибку. Нужно переформатировать флешку в exFAT или NTFS.

---

#### 4. Управление устройствами ввода-вывода (I/O Device Management)

Компьютер взаимодействует с кучей устройств: клавиатура, мышь, диски, принтеры, сетевые карты, веб-камеры. ОС управляет всем этим зоопарком через **драйверы**.

**Драйвер (Driver)** — это программа, которая знает, как общаться с конкретным устройством. Например, драйвер видеокарты NVIDIA переводит команды DirectX в инструкции для GPU.

**Что делает ОС:**
- Загружает драйверы устройств.
- Предоставляет единый интерфейс для доступа к устройствам (программа не должна знать, как работает жёсткий диск — она просто вызывает функцию `read()`, а ОС разбирается с деталями).
- Буферизация и кэширование данных ввода-вывода.

**Пример:** Подключил принтер HP. Windows автоматически скачивает драйвер из интернета. Linux может сказать: "Принтер? Не, не слышал." И тебе придётся искать драйвер вручную (или мучиться с CUPS).

---

#### 5. Пользовательский интерфейс (User Interface)

ОС предоставляет интерфейс для взаимодействия с компьютером. Бывает двух типов:

**CLI (Command Line Interface)** — командная строка. Вводишь команды текстом:
```
$ ls -la
$ cd /home/user/documents
$ rm -rf / --no-preserve-root   # не вводи это!
```
**Плюсы:** быстро, гибко, автоматизируется (скрипты).  
**Минусы:** нужно помнить команды, не интуитивно.

**Примеры:** Bash (Linux), PowerShell (Windows), Zsh (macOS).

**GUI (Graphical User Interface)** — графический интерфейс. Окна, кнопки, мышка.  
**Плюсы:** интуитивно, красиво, удобно для новичков.  
**Минусы:** медленнее, жрёт ресурсы.

**Примеры:** Windows 11 (Metro UI), macOS (Aqua), GNOME/KDE (Linux).

**Забавный факт:** Серверы обычно используют CLI, потому что GUI — лишняя нагрузка. Зачем серверу красивые окошки, если он стоит в тёмном дата-центре без монитора?

---

## 3.1.2. Классификация операционных систем

ОС бывают разные. Разберём основные критерии классификации.

---

### По назначению

#### Серверные ОС

**Назначение:** обслуживать множество клиентов одновременно (веб-серверы, базы данных, файловые хранилища).

**Характеристики:**
- Высокая надёжность (uptime 99.99%).
- Многопользовательский режим.
- Оптимизация под сетевые задачи и дисковые операции.

**Примеры:**
- **Linux** (Ubuntu Server, CentOS, Debian, Red Hat Enterprise Linux) — 96% веб-серверов работают на Linux.
- **Windows Server** — для корпораций, Active Directory, Exchange.
- **FreeBSD** — популярна в Netflix (стриминг видео).

---

#### Настольные (Desktop) ОС

**Назначение:** работа одного пользователя с персональным компьютером.

**Характеристики:**
- Графический интерфейс.
- Поддержка мультимедиа (игры, видео, музыка).
- Большой выбор приложений.

**Примеры:**
- **Windows** (10, 11) — доля рынка ~70% (2025).
- **macOS** (Sequoia, Sonoma) — ~15%, популярна среди дизайнеров и программистов.
- **Linux** (Ubuntu, Fedora, Linux Mint) — ~3%, но растёт (особенно после Steam Deck).

---

#### Мобильные ОС

**Назначение:** смартфоны и планшеты.

**Характеристики:**
- Оптимизация под энергопотребление (батарея).
- Сенсорный интерфейс.
- Ограничения безопасности (песочница для приложений).

**Примеры:**
- **Android** (Google) — 70% рынка, открытая ОС на базе Linux.
- **iOS** (Apple) — 28% рынка, закрытая ОС.
- **HarmonyOS** (Huawei) — растущая альтернатива в Китае.

---

#### Встраиваемые ОС (Embedded)

**Назначение:** управление встраиваемыми системами (бытовая техника, автомобили, роутеры).

**Характеристики:**
- Минимальный размер (килобайты-мегабайты).
- Оптимизация под конкретную задачу.
- Работа на слабом железе.

**Примеры:**
- **Embedded Linux** — используется в роутерах, смарт-ТВ, автомобилях Tesla.
- **QNX** — в автомобильных системах (Audi, BMW, Ford).
- **VxWorks** — в авионике (Boeing 787, марсоход Curiosity).

---

#### ОС реального времени (RTOS, Real-Time OS)

**Назначение:** задачи, где критична **предсказуемость времени отклика** (не скорость, а гарантия, что задача выполнится за определённый срок).

**Характеристики:**
- **Жёсткое реальное время (Hard Real-Time):** задача должна выполниться строго за заданное время. Опоздание = катастрофа.
  - Пример: система управления двигателем самолёта. Если команда на изменение тяги задержится на 10 мс — самолёт упадёт.
- **Мягкое реальное время (Soft Real-Time):** задержки нежелательны, но не критичны.
  - Пример: стриминг видео. Если кадр задержится на 50 мс — заметишь лаг, но ничего не сломается.

**Примеры:**
- **FreeRTOS** — бесплатная RTOS для микроконтроллеров (используется в IoT).
- **VxWorks** — коммерческая RTOS (космос, оборона).
- **QNX** — в автомобилях и медицинских устройствах.

**Пример задачи:** Система подушек безопасности в автомобиле. При аварии сенсоры определяют удар, и подушка должна раскрыться за **10-20 миллисекунд**. Если ОС задержит обработку на 50 мс — подушка раскроется после того, как водитель уже ударился о руль. RTOS гарантирует, что критичная задача выполнится вовремя.

---

### По архитектуре ядра

**Ядро (Kernel)** — это сердце ОС. Оно работает в **привилегированном режиме** (kernel mode) и имеет полный доступ к железу. Пользовательские программы работают в **пользовательском режиме** (user mode) и обращаются к железу только через системные вызовы (system calls).

Есть три основных архитектуры ядра:

---

#### 1. Монолитное ядро (Monolithic Kernel)

Весь код ядра работает в одном адресном пространстве. Все компоненты (управление процессами, памятью, файлами, драйверы) — часть ядра.

**Плюсы:**
- Скорость: нет накладных расходов на передачу данных между модулями.
- Производительность: прямой доступ к железу.

**Минусы:**
- Если один модуль (например, драйвер) крашится — падает всё ядро (Blue Screen of Death).
- Сложность отладки.

**Примеры:**
- **Linux** — монолитное ядро, но с поддержкой модулей (можно загружать драйверы динамически).
- **FreeBSD, OpenBSD**.

**Размер ядра Linux:** около 30 миллионов строк кода (2025). Да, это монстр.

---

#### 2. Микроядро (Microkernel)

Минимальное ядро, которое содержит только самое необходимое: управление процессами, межпроцессное взаимодействие (IPC), базовое управление памятью. Всё остальное (драйверы, файловые системы) работает в пользовательском режиме как отдельные процессы.

**Плюсы:**
- Надёжность: если драйвер крашится — он просто перезапускается, ядро остаётся стабильным.
- Безопасность: минимальная атакуемая поверхность.
- Модульность: легко добавлять/удалять компоненты.

**Минусы:**
- Медленнее: много переключений между пользовательским и привилегированным режимами.
- Сложность реализации.

**Примеры:**
- **Minix** — академическая ОС, создана для обучения.
- **QNX** — коммерческая RTOS.
- **L4** — семейство микроядер для встраиваемых систем.

**Забавный факт:** Intel Management Engine (IME) — секретный процессор внутри каждого чипа Intel — работает на Minix. То есть микроскопическая копия Minix работает на твоём компьютере прямо сейчас, и ты даже не знаешь.

---

#### 3. Гибридное ядро (Hybrid Kernel)

Компромисс между монолитным и микроядром. Основные компоненты (управление памятью, процессами) в ядре, но некоторые драйверы могут работать в пользовательском режиме.

**Примеры:**
- **Windows NT** (Windows 10, 11, Server) — гибридное ядро.
- **macOS** (XNU ядро, основано на Mach microkernel + FreeBSD).

**Критика:** некоторые считают, что "гибридное ядро" — это просто маркетинговый термин для "монолитного ядра с элементами микроядра".

---

### По количеству пользователей и задач

- **Однопользовательские / Многопользовательские:**
  - Однопользовательские: MS-DOS, ранние версии Windows (95, 98).
  - Многопользовательские: Linux, Windows (современные версии), macOS.

- **Однозадачные / Многозадачные:**
  - Однозадачные: MS-DOS (можно запустить только одну программу).
  - Многозадачные: все современные ОС.

---

## 3.1.3. Примеры операционных систем

Разберём основных игроков на рынке ОС.

---

### Windows

**История:**
- 1985: Windows 1.0 (графическая оболочка поверх MS-DOS).
- 1995: Windows 95 — первая ОС с полноценным GUI и кнопкой "Пуск".
- 2001: Windows XP — легендарная версия, которую использовали до 2014 года (а в России до сих пор встречается).
- 2015: Windows 10 — "последняя версия Windows" (спойлер: нет).
- 2021: Windows 11 — новый дизайн, поддержка Android-приложений.

**Характеристики:**
- **Архитектура ядра:** гибридное (NT kernel).
- **Файловая система:** NTFS (по умолчанию).
- **Доля рынка:** ~70% десктопов (2025).
- **Применение:** игры, офис, корпоративный сектор.

**Плюсы:**
- Огромный выбор программ и игр.
- Поддержка любого железа (драйверы для всего).
- Привычный интерфейс.

**Минусы:**
- Частые обновления, которые ломают систему.
- Телеметрия (Microsoft собирает данные о тебе).
- Вирусы (самая популярная ОС = самая популярная цель для хакеров).

**Пример задачи:** Windows 11 требует минимум: CPU 1 GHz (2 ядра), 4 GB ОЗУ, 64 GB диска, TPM 2.0 (модуль доверенной платформы для безопасности). Твой старый ноутбук 2015 года не поддерживает TPM 2.0 — Windows 11 не установится (хотя есть обходные пути).

---

### Linux

**История:**
- 1991: Линус Торвальдс (студент из Финляндии) написал ядро Linux как хобби-проект.
- 1993: первые дистрибутивы (Slackware, Debian).
- 2000-е: взрывной рост, Linux захватывает серверный рынок.
- 2020-е: Linux на десктопах растёт (Steam Deck, игры через Proton).

**Дистрибутивы (Distributions):** Linux — это только ядро. Дистрибутив = ядро + набор программ + пакетный менеджер + окружение рабочего стола.

| Дистрибутив   | Сложность   | Применение                        |
|---------------|-------------|-----------------------------------|
| **Ubuntu**        | Лёгкий      | Новички, десктоп, серверы         |
| **Debian**        | Средний     | Серверы, стабильность             |
| **Arch Linux**    | Хардкор     | Гики, кастомизация (i use arch btw) |
| **Fedora**        | Средний     | Разработчики, новые технологии    |
| **CentOS / Rocky**| Средний     | Серверы (замена Red Hat)          |
| **Linux Mint**    | Лёгкий      | Переход с Windows, дружелюбность  |

**Характеристики:**
- **Архитектура ядра:** монолитное (с модулями).
- **Файловая система:** ext4 (обычно).
- **Доля рынка:** ~3% десктопов, **96% серверов**, 70% смартфонов (Android).
- **Применение:** серверы, разработка, встраиваемые системы.

**Плюсы:**
- Бесплатно и open-source.
- Настраиваемость (можешь изменить всё, вплоть до ядра).
- Безопасность (меньше вирусов).
- Стабильность (серверы работают годами без перезагрузки).

**Минусы:**
- Кривая обучения (особенно Arch).
- Меньше программ и игр (хотя ситуация улучшается).
- Проблемы с драйверами (особенно NVIDIA).
- Фрагментация (тысячи дистрибутивов, сложно выбрать).

**Философия Linux:** "Всё есть файл". Даже устройства представлены как файлы в `/dev/`. Хочешь прочитать данные с диска? Читай файл `/dev/sda`. Хочешь отправить данные на принтер? Пиши в `/dev/lp0`.

**Пример:** Создал веб-сервер на Ubuntu Server (4 GB RAM, 2 ядра CPU). Установил nginx, настроил за 10 минут. Сервер работает месяцами без перезагрузки. На Windows Server пришлось бы покупать лицензию ($1000+) и мучиться с IIS.

---

### macOS

**История:**
- 1984: Mac OS (графическая ОС для компьютеров Apple Macintosh).
- 2001: Mac OS X — переход на UNIX-основу (ядро XNU = Mach + FreeBSD).
- 2020: переход с Intel на собственные процессоры Apple Silicon (M1, M2, M3).

**Характеристики:**
- **Архитектура ядра:** гибридное (XNU).
- **Файловая система:** APFS.
- **Доля рынка:** ~15% десктопов.
- **Применение:** дизайн, видеомонтаж, разработка под iOS.

**Плюсы:**
- Красивый и удобный интерфейс.
- Оптимизация под железо Apple (интеграция с iPhone, iPad, Apple Watch).
- Стабильность (UNIX-основа).
- Меньше вирусов, чем на Windows.

**Минусы:**
- Работает только на Mac (цены от $1000).
- Закрытая экосистема (не апгрейдишь железо, не установишь на другой компьютер).
- Меньше игр.

**Пример:** MacBook Air M2 (2024) на ARM-процессоре потребляет 5-10 Вт в режиме работы, работает 15-20 часов от батареи. Ноутбук на Intel с такой же производительностью жрал бы 40-50 Вт и работал 5 часов. Секрет: macOS оптимизирована под Apple Silicon, контролирует каждый аспект железа.

---

### iOS и Android

**iOS** (Apple):
- Закрытая ОС, основана на Darwin (UNIX).
- Жёсткий контроль: приложения только из App Store, Apple проверяет каждое.
- Оптимизация под iPhone/iPad.
- Обновления выходят одновременно для всех устройств (даже 5-летним iPhone).

**Android** (Google):
- Открытая ОС, основана на ядре Linux.
- Свобода: можно ставить приложения из сторонних источников, кастомизировать всё.
- Фрагментация: тысячи производителей (Samsung, Xiaomi, Huawei), разные версии Android.
- Обновления приходят поздно (или не приходят вообще).

**Сравнение:**

| Параметр           | iOS                | Android            |
|--------------------|--------------------|--------------------|
| Доля рынка         | 28%                | 70%                |
| Открытость         | Закрыта            | Открыта (AOSP)     |
| Безопасность       | Высокая            | Средняя            |
| Выбор устройств    | Только iPhone/iPad | Тысячи моделей     |
| Обновления         | 5+ лет             | 2-3 года (зависит) |
| Цена устройств     | $400-$1600         | $100-$1500         |

**Пример:** iPhone 15 Pro (iOS 17) получает обновления безопасности одновременно с выходом патча. У Android-смартфона Xiaomi (2022 года) патч безопасности может выйти через 3 месяца (или никогда). Фрагментация Android — это боль.

---

### Экзотические ОС

- **FreeBSD / OpenBSD**: UNIX-системы, популярны на серверах (Netflix использует FreeBSD для стриминга).
- **Haiku OS**: попытка воскресить BeOS (ОС 1990-х, известную скоростью).
- **TempleOS**: ОС, написанная одним человеком (Terry Davis) как "дар Богу". 640x480 разрешение, 16 цветов, встроенный язык программирования HolyC. Безумие и гениальность одновременно.

---

## 3.1.4. Связь с другими главами

- **[Глава 2.1](02_01_архитектура_эвм.md)-2.3 (Архитектура ЭВМ, принципы фон Неймана):** ОС управляет процессором, памятью, устройствами ввода-вывода, о которых мы говорили в разделе 2.
- **[Глава 3.2](03_02_уровни_по_прикладное.md)-3.3 (Уровни ПО, системное ПО):** ОС — это базовый уровень системного ПО, над которым работают драйверы, утилиты, приложения.
- **Глава 5 (Алгоритмы):** планировщик процессов в ОС использует алгоритмы планирования (Round Robin, Priority Scheduling).
- **Глава 7 (Базы данных):** СУБД работают поверх ОС, используют её API для работы с файлами.
- **Глава 9 (Информационная безопасность):** ОС обеспечивает защиту: права доступа, изоляцию процессов, шифрование дисков.

---

## Примеры для понимания

### Пример 1: Планирование процессов

**Задача:** У тебя 4-ядерный процессор. Запущено 10 процессов. ОС использует алгоритм **Round Robin** (циклическое планирование) с квантом времени 20 мс. Сколько времени каждый процесс ждёт своей очереди?

**Решение:**
- 4 ядра могут выполнять 4 процесса одновременно.
- Каждый процесс работает 20 мс, затем ОС переключается на следующий.
- Первые 4 процесса выполняются: 0-20 мс.
- Следующие 4: 20-40 мс.
- Последние 2: 40-60 мс.
- Процесс №5 ждёт: 20 мс (пока выполняются 1-4, затем его очередь).
- Процесс №10 ждёт: 40 мс.

**Вывод:** В многозадачной системе процессы делят время процессора. Чем больше процессов — тем дольше ожидание.

---

### Пример 2: Виртуальная память

**Задача:** Система с 8 GB RAM. Запущены программы, использующие 10 GB. Размер страницы 4 KB. Сколько страниц нужно выгрузить на диск?

**Решение:**
- Требуется: 10 GB = 10 × 2³⁰ байт.
- Физическая память: 8 GB = 8 × 2³⁰ байт.
- Не хватает: 2 GB = 2 × 2³⁰ байт.
- Размер страницы: 4 KB = 4 × 2¹⁰ байт.
- Количество страниц для выгрузки: (2 × 2³⁰) / (4 × 2¹⁰) = 2 × 2²⁰ / 4 = 524,288 страниц.

**Вывод:** ОС выгружает на диск полмиллиона страниц. Если программа обращается к выгруженной странице, происходит **page fault** (промах страницы), ОС подгружает её с диска. Это медленно (миллисекунды вместо наносекунд), поэтому систему тормозит.

---

### Пример 3: Размер ядра ОС

**Задача:** Сравнить размеры ядер разных ОС.

| ОС               | Размер ядра (строки кода) | Архитектура ядра |
|------------------|--------------------------|------------------|
| Linux 6.6 (2025) | ~30,000,000              | Монолитное       |
| Windows NT       | ~50,000,000 (оценка)     | Гибридное        |
| macOS XNU        | ~10,000,000              | Гибридное        |
| Minix 3          | ~20,000                  | Микроядро        |
| FreeRTOS         | ~10,000                  | Микроядро        |

**Вывод:** Микроядерные ОС в 1000+ раз компактнее монолитных. Но монолитные — производительнее. Компромисс: надёжность vs скорость.

---

### Пример 4: RTOS в авионике

**Задача:** Самолёт Boeing 787 использует VxWorks (RTOS). Критичная задача: обработка данных от датчика высоты. Максимальная допустимая задержка: 5 мс. Обычная ОС (Windows) имеет задержку до 100 мс. Почему нельзя использовать Windows?

**Ответ:**  
RTOS гарантирует, что задача выполнится за заданное время (детерминированность). Windows — ОС общего назначения, она может отложить обработку датчика на 100 мс, если занята обновлением или антивирусом. Для самолёта это недопустимо: задержка в 100 мс при критической ситуации = катастрофа.

**Вывод:** Для задач реального времени нужны специализированные ОС.

---

## Ключевые термины и определения

- **Операционная система (ОС)** — комплекс программ, управляющих аппаратными ресурсами и предоставляющих сервисы для пользовательских приложений.
- **Процесс** — программа в процессе выполнения (с выделенной памятью и состоянием).
- **Многозадачность (Multitasking)** — одновременное выполнение нескольких процессов (вытесняющая или невытесняющая).
- **Планирование (Scheduling)** — алгоритм распределения времени процессора между процессами.
- **Виртуальная память (Virtual Memory)** — механизм, позволяющий процессам использовать больше памяти, чем физически доступно (через подкачку на диск).
- **Страничная организация памяти (Paging)** — разделение памяти на блоки фиксированного размера (страницы).
- **Файловая система (File System)** — способ организации данных на диске (FAT32, NTFS, ext4, APFS).
- **Драйвер (Driver)** — программа для управления конкретным устройством.
- **Ядро (Kernel)** — центральная часть ОС, работающая в привилегированном режиме (монолитное, микроядро, гибридное).
- **CLI (Command Line Interface)** — командная строка (текстовый интерфейс).
- **GUI (Graphical User Interface)** — графический интерфейс (окна, кнопки).
- **RTOS (Real-Time OS)** — ОС реального времени, гарантирующая выполнение задач за заданное время.
- **Дистрибутив (Distribution)** — вариант Linux с набором программ и настроек (Ubuntu, Debian, Arch).
- **Системный вызов (System Call)** — запрос программы к ядру ОС для выполнения привилегированной операции (чтение файла, выделение памяти).

---

## Контрольные вопросы

1. **Теория:** Назовите пять основных функций операционной системы. Объясните, почему без виртуальной памяти современные ОС не могли бы работать с большим количеством процессов одновременно.

2. **Практика:** У тебя 16 GB RAM, запущено 10 программ, каждая использует 2 GB. Физической памяти не хватает. ОС использует подкачку на SSD (скорость чтения 3 GB/с). Программа обращается к данным, которые были выгружены на диск. Сколько времени займёт подгрузка одной страницы размером 4 KB? Сравни с обращением к RAM (задержка 10 нс).

3. **Сравнение:** В чём принципиальное отличие монолитного ядра (Linux) от микроядра (Minix)? Почему Linux доминирует на серверах, несмотря на то, что микроядра теоретически надёжнее?

4. **Классификация:** Объясните разницу между ОС общего назначения (Windows) и RTOS (FreeRTOS). Приведите пример задачи, где RTOS обязательна, и задачи, где она не нужна.

5. **Анализ:** Почему 96% веб-серверов работают на Linux, а не на Windows Server? Какие преимущества Linux для серверов критичны? (Подсказка: лицензии, стабильность, ресурсы, безопасность.)

---

**Итог:** Операционная система — это менеджер компьютера, который управляет всеми ресурсами и не даёт программам убить друг друга. Без ОС компьютер — просто железка. ОС бывают разные: для серверов (Linux), для десктопов (Windows, macOS), для смартфонов (Android, iOS), для встраиваемых систем (Embedded Linux, FreeRTOS). Архитектура ядра может быть монолитной (быстро, но рискованно), микроядром (надёжно, но медленно), или гибридом (компромисс).

Следующая глава (3.2) — уровни программного обеспечения: как ОС взаимодействует с прикладными программами и зачем нужны драйверы, библиотеки, API.


---

[← К оглавлению](README.md)

*Глава 3.1: Операционные системы. Назначение и классификация*
