[← К оглавлению](README.md)

---

# [Глава 5.1](05_01_алгоритм_и_свойства.md): Алгоритм и его свойства. Способы описания

## Введение

Поздравляю, ты дожил до темы, которая **реально важна**. Не то чтобы предыдущие главы были бесполезны (системы счисления и представление данных — это база), но алгоритмы — это то, **как компьютер вообще что-то делает**. Без алгоритмов компьютер — это просто дорогой калькулятор, который умеет только мигать огоньками.

Алгоритм — это пошаговая инструкция для решения задачи. Типа рецепта борща: возьми свёклу, нарежь, вари, добавь капусту... Только в программировании борщ называется "отсортировать массив", а свёкла — "входные данные".

**Эта глава связана с:**
- [**Глава 4.4**](04_04_модели_решения_задач.md) (Модели решения задач) — там мы разбирали жадные алгоритмы, ДП, разделяй и властвуй
- [**Глава 5.2**](05_02_алгоритмические_конструкции.md) (Алгоритмические конструкции) — там будут конкретные конструкции (условия, циклы)
- [**Глава 6.1**](06_01_классификация_языков.md) (Языки программирования) — алгоритм надо на чём-то реализовать
- [**Глава 6.2**](06_02_языки_компиляторы.md) (Компиляторы и интерпретаторы) — как код превращается в инструкции процессора

**Зачем это нужно?** Потому что на экзамене тебя **обязательно** спросят про свойства алгоритма (дискретность, детерминированность и прочая хрень). А ещё потому что понимание алгоритмов — это основа программирования. Без этого ты будешь как водитель, который не знает, где у машины газ и тормоз.

---

## 5.1.1. Что такое алгоритм

### Определение

**Алгоритм (algorithm)** — это **конечная последовательность чётко определённых действий**, необходимых для решения задачи или достижения цели.

Проще говоря: алгоритм — это **пошаговая инструкция** для тупого исполнителя (компьютера, человека, робота). Исполнитель не думает, он просто тупо выполняет шаги один за другим.

**Примеры алгоритмов из жизни:**

1. **Рецепт приготовления яичницы:**
   - Взять сковородку
   - Поставить на огонь
   - Налить масло
   - Разбить яйца
   - Жарить 3 минуты
   - Выключить огонь
   - Готово

2. **Инструкция "как дойти до магазина":**
   - Выйти из дома
   - Повернуть направо
   - Пройти 100 метров
   - Повернуть налево
   - Магазин будет справа

3. **Алгоритм утреннего подъёма студента:**
   - Будильник звонит
   - Нажать "ещё 5 минут"
   - Повторить 10 раз
   - Проснуться в панике
   - Бежать на пары (опционально)

### История термина

Слово **"алгоритм"** происходит от имени узбекского учёного **Мухаммада ибн Мусы аль-Хорезми** (IX век). Он написал книгу "Об индийском счёте", где описал правила арифметических операций. В Европе его имя исказили до "Algorismus", а затем — "алгоритм". По сути, этот чел научил европейцев считать (до этого они мучались с римскими цифрами типа MCMXCIV — попробуй на них умножить столбиком).

**Забавный факт:** Римские цифры — это кошмар для арифметики. Попробуй умножить XLII на XVI без калькулятора. Вот именно. Аль-Хорезми принёс в Европу арабские цифры (на самом деле индийские, но европейцы назвали их "арабскими") — и жить стало чуть проще.

---

## 5.1.2. Свойства алгоритма

У нормального алгоритма есть 5 обязательных свойств. Если хотя бы одного нет — это не алгоритм, а хрень какая-то. Запоминай:

---

### 1. Дискретность (прерывность, пошаговость)

**Дискретность** — алгоритм состоит из **отдельных шагов** (дискретных операций). Каждый шаг выполняется за конечное время, затем начинается следующий.

**Пример:**
```
1. Взять два числа a и b
2. Сложить их: c = a + b
3. Вывести результат c
```

Это 3 отдельных шага. Нельзя выполнить "полтора шага" или "перепрыгнуть сразу к результату, пропустив сложение".

**Анти-пример (не дискретный):**  
"Думай о решении задачи, пока не поймёшь, как её решить" — это не алгоритм, потому что процесс "думать" не разбит на чёткие шаги.

---

### 2. Детерминированность (определённость, однозначность)

**Детерминированность** — каждый шаг алгоритма **однозначно определён**. Два разных исполнителя при одинаковых входных данных должны получить одинаковый результат.

**Простыми словами:** Если ты дал алгоритм двум людям, они должны сделать одно и то же. Никакой "импровизации" или "действуй по ситуации".

**Пример (детерминированный):**
```
Если число чётное, раздели на 2
Если число нечётное, умножь на 3 и прибавь 1
```

**Анти-пример (недетерминированный):**  
"Если погода хорошая, иди пешком, иначе вызови такси" — что значит "хорошая"? Для кого-то +10°C — это хорошо, для кого-то — холодно. Алгоритм должен **точно определить** условие.

**Правильная версия:**  
"Если температура выше +15°C и нет дождя, иди пешком, иначе вызови такси".

---

### 3. Конечность (результативность за конечное время)

**Конечность** — алгоритм должен **завершиться за конечное число шагов**. Нельзя, чтобы он работал бесконечно (если, конечно, это не специально — серверы и операционные системы работают "бесконечно", но это исключения).

**Пример 1 (алгоритм завершается):**
```
Считать от 1 до 10
```
Чётко 10 шагов, затем конец.

**Пример 2 (алгоритм НЕ завершается):**
```
Пока 2×2 = 4, выводи "привет"
```
2×2 всегда равно 4 → бесконечный цикл → алгоритм **не завершается** → это **не алгоритм** (ну или баг).

**Пример 3 (Гипотеза Коллатца — неизвестно, завершается ли):**
```
1. Взять любое натуральное число n
2. Если n чётное, разделить на 2
3. Если n нечётное, умножить на 3 и прибавить 1
4. Повторять, пока n ≠ 1
```

Для всех проверенных чисел (до 2^68) алгоритм завершается. Но **математически не доказано**, что он завершится для **любого** числа. Поэтому строго говоря, это **гипотеза**, а не доказанный алгоритм.

**Интересный момент:** Есть **недетерминированные алгоритмы** (в теории сложности, например, NP-задачи). Там допускается "угадывание" решения. Но это специфика, на экзамене по базовой информатике не спрашивают.

---

### 4. Массовость (применимость к классу задач)

**Массовость** — алгоритм должен решать **не одну конкретную задачу**, а **целый класс однотипных задач**.

**Пример:**
Алгоритм сложения двух чисел работает для **любых** двух чисел (5+3, 1000+2000, -7+15), а не только для конкретной пары "2 + 2 = 4".

**Анти-пример (не массовый):**  
"Ответ на вопрос 'сколько будет 2+2?' — это 4" — это не алгоритм, это просто **константа**. Алгоритм должен уметь складывать **любые** два числа.

**Правильная версия:**
```
Алгоритм сложения:
1. Взять два числа a и b
2. Вычислить c = a + b
3. Вернуть c
```

Теперь это работает для **любой** пары чисел → массовость есть.

---

### 5. Результативность (наличие результата)

**Результативность** — алгоритм должен **давать результат** (или сообщать, что решение невозможно). Нельзя, чтобы алгоритм завершился и ничего не выдал.

**Пример 1 (есть результат):**
```
Найти НОД(18, 24)
Ответ: 6
```

**Пример 2 (результат = "решения нет"):**
```
Найти целое число x, такое что x² = -1
Ответ: Решения в целых числах не существует
```

Это тоже **результат** (информация о невозможности решения).

**Анти-пример:**  
"Подумай над задачей 5 минут" — через 5 минут ты можешь как найти решение, так и не найти. Нет гарантии результата → это не алгоритм.

---

### Запоминалка: Д-Д-К-М-Р

- **Д**искретность
- **Д**етерминированность
- **К**онечность
- **М**ассовость
- **Р**езультативность

На экзамене могут спросить: "Назовите свойства алгоритма". Отвечаешь: "Д-Д-К-М-Р", расшифровываешь — и всё, вопрос закрыт.

---

## 5.1.3. Исполнитель алгоритма и СКИ

### Исполнитель

**Исполнитель алгоритма** — это тот, кто **выполняет** алгоритм. Это может быть:

- **Человек** (ты решаешь задачу по алгоритму)
- **Компьютер** (процессор выполняет машинный код)
- **Робот** (выполняет программу управления)
- **Виртуальная машина** (например, JVM для Java)

### Система команд исполнителя (СКИ)

**СКИ (Система Команд Исполнителя)** — это набор **элементарных действий**, которые исполнитель **умеет выполнять**.

**Пример 1: СКИ человека**
- Читать
- Писать
- Считать в уме (сложение, вычитание, умножение, деление)
- Запоминать числа

**Пример 2: СКИ процессора (упрощённо)**
- Загрузить число из памяти в регистр (`MOV`)
- Сложить два числа (`ADD`)
- Вычесть (`SUB`)
- Умножить (`MUL`)
- Перейти на другую команду (`JMP`)
- Сравнить два числа (`CMP`)

**Пример 3: СКИ робота-пылесоса**
- Ехать вперёд
- Повернуть налево / направо
- Остановиться
- Всосать пыль
- Проверить наличие препятствия (датчик)

**Важно:** Алгоритм должен быть записан **только** с использованием команд из СКИ. Если ты скажешь роботу-пылесосу "приготовь кофе", он тебя не поймёт — этой команды нет в его СКИ.

**Пример задачи:**

Дан алгоритм для исполнителя "Калькулятор" с СКИ: {+, -, ×, ÷}.

**Задача:** Вычислить \(5^3\) (5 в степени 3).

**Решение:**
```
1. 5 × 5 = 25
2. 25 × 5 = 125
```

Готово. Мы использовали только команды из СКИ (умножение).

**Анти-пример:** "Калькулятор, возведи 5 в степень 3" — если команды "возведение в степень" нет в СКИ, калькулятор не поймёт.

---

## 5.1.4. Способы описания алгоритмов

Алгоритм можно описать разными способами. Выбор зависит от аудитории (для кого пишешь), задачи (насколько сложная) и этапа разработки (проектирование или реализация).

---

### 1. Словесный (текстовый) способ

**Идея:** Описываешь алгоритм **на естественном языке** (русском, английском). Как инструкцию для человека.

**Плюсы:**
- Понятно всем (не нужно знать программирование)
- Легко писать

**Минусы:**
- Нет строгости (можно понять по-разному)
- Громоздко для сложных алгоритмов

**Пример 1: Алгоритм заваривания чая**

```
1. Вскипятить воду
2. Положить чайный пакетик в кружку
3. Налить кипяток
4. Подождать 3 минуты
5. Вынуть пакетик
6. Добавить сахар (по желанию)
7. Готово
```

**Пример 2: Алгоритм нахождения НОД (наибольший общий делитель) двух чисел**

```
1. Взять два числа a и b
2. Пока b ≠ 0:
   2.1. Вычислить остаток от деления a на b, сохранить в r
   2.2. Присвоить a = b
   2.3. Присвоить b = r
3. Вернуть a (это и есть НОД)
```

Это **алгоритм Евклида**. Работает быстро и точно.

---

### 2. Блок-схема (графический способ)

**Идея:** Рисуешь алгоритм в виде **графа** (диаграммы) из блоков, соединённых стрелками.

**Основные блоки:**

| Блок          | Обозначение          | Назначение                          |
| ------------- | -------------------- | ----------------------------------- |
| **Начало/Конец** | Овал ⬭           | Начало или конец алгоритма          |
| **Процесс**      | Прямоугольник ▭   | Вычисление, операция (a = b + c)    |
| **Решение**      | Ромб ◇            | Условие (if-else), проверка         |
| **Ввод/Вывод**   | Параллелограмм ▱  | Чтение или вывод данных             |
| **Стрелки**      | →                 | Направление выполнения              |

**Пример 1: Блок-схема "Проверка числа на чётность"**

```
        ⬭ Начало
          |
          ↓
      ▱ Ввести число n
          |
          ↓
    ◇ n mod 2 = 0?
      /       \
    Да         Нет
    /           \
   ↓             ↓
▱ Вывести      ▱ Вывести
"Чётное"      "Нечётное"
   |             |
   ↓             ↓
   ⬭ Конец      ⬭ Конец
```

**Пример 2: Блок-схема "Найти максимум из двух чисел"**

```
        ⬭ Начало
          |
          ↓
   ▱ Ввести a и b
          |
          ↓
      ◇ a > b?
      /       \
    Да         Нет
    /           \
   ↓             ↓
▭ max = a     ▭ max = b
   |             |
   ↓             ↓
    \           /
     \         /
      ↓       ↓
    ▱ Вывести max
          |
          ↓
        ⬭ Конец
```

**Плюсы блок-схем:**
- Наглядность (видно структуру алгоритма)
- Легко найти ошибки в логике

**Минусы:**
- Долго рисовать для сложных алгоритмов
- Занимает много места

**Когда использовать:** На этапе **проектирования** (до написания кода). Рисуешь схему → проверяешь логику → пишешь код.

---

### 3. Псевдокод (алгоритмический язык)

**Псевдокод** — это промежуточный язык между естественным языком и программированием. Похож на код, но не привязан к конкретному языку программирования.

**Правила:**
- Используем ключевые слова: `если`, `то`, `иначе`, `пока`, `для`, `вернуть`
- Переменные обозначаем буквами
- Операции: `=` (присваивание), `+`, `-`, `*`, `/`, `mod` (остаток от деления)

**Пример 1: Алгоритм Евклида (НОД)**

```
Алгоритм НОД(a, b):
    Пока b ≠ 0:
        r = a mod b
        a = b
        b = r
    Вернуть a
```

**Пример 2: Поиск максимума в массиве**

```
Алгоритм НайтиМаксимум(массив A, размер n):
    max = A[0]
    Для i от 1 до n-1:
        Если A[i] > max, то:
            max = A[i]
    Вернуть max
```

**Пример 3: Бинарный поиск**

```
Алгоритм БинарныйПоиск(массив A, размер n, искомое значение x):
    left = 0
    right = n - 1
    Пока left ≤ right:
        mid = (left + right) / 2  // целочисленное деление
        Если A[mid] = x, то:
            Вернуть mid  // нашли, вернуть индекс
        Иначе если A[mid] < x, то:
            left = mid + 1
        Иначе:
            right = mid - 1
    Вернуть -1  // не найдено
```

**Плюсы:**
- Компактность (короче словесного описания)
- Понятность (не нужно знать синтаксис конкретного языка)
- Легко переводится в код

**Минусы:**
- Не выполняется на компьютере (нужно переводить в реальный код)

**Когда использовать:** На экзаменах, в учебниках, при обсуждении алгоритмов с коллегами.

---

### 4. Программный код (на языке программирования)

**Идея:** Записываешь алгоритм на **конкретном языке программирования** (Python, C++, Java).

**Плюсы:**
- Точность (компьютер выполнит код без "интерпретации")
- Можно запустить и протестировать

**Минусы:**
- Нужно знать синтаксис языка
- Код одного языка не понятен тем, кто знает только другой язык

**Пример 1: Алгоритм Евклида на Python**

```python
def gcd(a, b):
    while b != 0:
        r = a % b
        a = b
        b = r
    return a

# Пример использования
print(gcd(48, 18))  # Вывод: 6
```

**Пример 2: Поиск максимума в массиве на C++**

```cpp
#include <iostream>
using namespace std;

int findMax(int arr[], int n) {
    int max = arr[0];
    for (int i = 1; i < n; i++) {
        if (arr[i] > max) {
            max = arr[i];
        }
    }
    return max;
}

int main() {
    int arr[] = {3, 7, 2, 9, 5};
    cout << "Max: " << findMax(arr, 5) << endl;  // Вывод: Max: 9
    return 0;
}
```

**Пример 3: Бинарный поиск на Java**

```java
public class BinarySearch {
    public static int binarySearch(int[] arr, int x) {
        int left = 0, right = arr.length - 1;
        while (left <= right) {
            int mid = (left + right) / 2;
            if (arr[mid] == x)
                return mid;  // нашли
            else if (arr[mid] < x)
                left = mid + 1;
            else
                right = mid - 1;
        }
        return -1;  // не найдено
    }

    public static void main(String[] args) {
        int[] arr = {1, 3, 5, 7, 9, 11};
        System.out.println(binarySearch(arr, 7));  // Вывод: 3
    }
}
```

**Когда использовать:** Когда нужно **реализовать** алгоритм и запустить на компьютере.

---

### Сравнение способов описания

| Способ          | Понятность | Точность | Выполнимость | Применение                |
| --------------- | ---------- | -------- | ------------ | ------------------------- |
| Словесный       | ✅ Высокая | ⚠️ Низкая | ❌ Нет       | Обучение, документация    |
| Блок-схема      | ✅ Высокая | ⚠️ Средняя | ❌ Нет      | Проектирование, визуализация |
| Псевдокод       | ✅ Высокая | ✅ Высокая | ❌ Нет      | Экзамены, учебники        |
| Программный код | ⚠️ Средняя | ✅ Высокая | ✅ Да       | Реализация, разработка    |

---

## 5.1.5. Примеры алгоритмов

Разберём несколько классических алгоритмов с описанием в **разных форматах**.

---

### Пример 1: Алгоритм Евклида (НОД)

**Задача:** Найти наибольший общий делитель (НОД) двух чисел.

**Словесное описание:**

```
1. Взять два числа a и b
2. Пока b не равно 0:
   - Вычислить остаток от деления a на b, сохранить в r
   - Присвоить a = b
   - Присвоить b = r
3. Вернуть a (это НОД)
```

**Блок-схема:**

```
        ⬭ Начало
          |
          ↓
     ▱ Ввести a, b
          |
          ↓
      ◇ b = 0?
      /       \
    Нет        Да
    /           \
   ↓             ↓
▭ r = a mod b  ▱ Вывести a
▭ a = b           |
▭ b = r           ↓
   |            ⬭ Конец
   ↓
(вернуться к проверке b = 0)
```

**Псевдокод:**

```
Алгоритм НОД(a, b):
    Пока b ≠ 0:
        r = a mod b
        a = b
        b = r
    Вернуть a
```

**Программный код (Python):**

```python
def gcd(a, b):
    while b != 0:
        a, b = b, a % b
    return a
```

**Пример выполнения:**

Найдём НОД(48, 18):

```
Шаг 1: a = 48, b = 18
       r = 48 mod 18 = 12
       a = 18, b = 12

Шаг 2: a = 18, b = 12
       r = 18 mod 12 = 6
       a = 12, b = 6

Шаг 3: a = 12, b = 6
       r = 12 mod 6 = 0
       a = 6, b = 0

b = 0 → НОД = 6
```

**Ответ:** НОД(48, 18) = 6.

---

### Пример 2: Линейный поиск

**Задача:** Найти элемент `x` в массиве. Вернуть его индекс или -1, если не найден.

**Словесное описание:**

```
1. Взять массив A размером n и искомое значение x
2. Для каждого индекса i от 0 до n-1:
   - Если A[i] = x, вернуть i (нашли)
3. Если цикл завершился, вернуть -1 (не найдено)
```

**Псевдокод:**

```
Алгоритм ЛинейныйПоиск(A, n, x):
    Для i от 0 до n-1:
        Если A[i] = x, то:
            Вернуть i
    Вернуть -1
```

**Программный код (C++):**

```cpp
int linearSearch(int arr[], int n, int x) {
    for (int i = 0; i < n; i++) {
        if (arr[i] == x)
            return i;
    }
    return -1;
}
```

**Пример выполнения:**

Массив: `[5, 2, 9, 1, 5, 6]`, ищем `x = 9`

```
i = 0: A[0] = 5 ≠ 9
i = 1: A[1] = 2 ≠ 9
i = 2: A[2] = 9 = 9 → вернуть 2
```

**Ответ:** Индекс 2.

**Сложность:** O(n) — в худшем случае проверяем все элементы.

---

### Пример 3: Бинарный поиск

**Задача:** Найти элемент `x` в **отсортированном** массиве. Вернуть индекс или -1.

**Идея:** Делим массив пополам. Если средний элемент равен искомому — нашли. Если меньше — ищем в правой половине, если больше — в левой.

**Словесное описание:**

```
1. Взять отсортированный массив A, размер n, искомое значение x
2. Установить left = 0, right = n-1
3. Пока left ≤ right:
   3.1. Вычислить mid = (left + right) / 2
   3.2. Если A[mid] = x, вернуть mid
   3.3. Если A[mid] < x, установить left = mid + 1
   3.4. Иначе установить right = mid - 1
4. Вернуть -1 (не найдено)
```

**Псевдокод:**

```
Алгоритм БинарныйПоиск(A, n, x):
    left = 0
    right = n - 1
    Пока left ≤ right:
        mid = (left + right) / 2
        Если A[mid] = x, то:
            Вернуть mid
        Иначе если A[mid] < x, то:
            left = mid + 1
        Иначе:
            right = mid - 1
    Вернуть -1
```

**Программный код (Python):**

```python
def binary_search(arr, x):
    left, right = 0, len(arr) - 1
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == x:
            return mid
        elif arr[mid] < x:
            left = mid + 1
        else:
            right = mid - 1
    return -1
```

**Пример выполнения:**

Массив: `[1, 3, 5, 7, 9, 11, 13]`, ищем `x = 7`

```
Шаг 1: left = 0, right = 6, mid = 3
       A[3] = 7 = x → вернуть 3
```

**Ответ:** Индекс 3.

**Пример 2:** Ищем `x = 10`

```
Шаг 1: left = 0, right = 6, mid = 3
       A[3] = 7 < 10 → left = 4

Шаг 2: left = 4, right = 6, mid = 5
       A[5] = 11 > 10 → right = 4

Шаг 3: left = 4, right = 4, mid = 4
       A[4] = 9 < 10 → left = 5

Шаг 4: left = 5, right = 4 (left > right) → вернуть -1
```

**Ответ:** Не найдено (-1).

**Сложность:** O(log n) — в два раза быстрее каждый шаг сокращает область поиска.

---

### Пример 4: Сортировка пузырьком (Bubble Sort)

**Идея:** Проходим по массиву, сравниваем соседние элементы. Если левый больше правого — меняем местами. Повторяем, пока массив не станет отсортированным.

**Словесное описание:**

```
1. Взять массив A размером n
2. Повторять n-1 раз:
   2.1. Для каждого индекса i от 0 до n-2:
        - Если A[i] > A[i+1], поменять их местами
3. Массив отсортирован
```

**Псевдокод:**

```
Алгоритм СортировкаПузырьком(A, n):
    Для j от 0 до n-2:
        Для i от 0 до n-2:
            Если A[i] > A[i+1], то:
                Поменять A[i] и A[i+1] местами
```

**Программный код (Python):**

```python
def bubble_sort(arr):
    n = len(arr)
    for j in range(n - 1):
        for i in range(n - 1):
            if arr[i] > arr[i + 1]:
                arr[i], arr[i + 1] = arr[i + 1], arr[i]
```

**Пример выполнения:**

Массив: `[5, 2, 9, 1, 5, 6]`

```
Проход 1:
[5, 2, 9, 1, 5, 6]
[2, 5, 9, 1, 5, 6]  (поменяли 5 и 2)
[2, 5, 1, 9, 5, 6]  (поменяли 9 и 1)
[2, 5, 1, 5, 9, 6]  (поменяли 9 и 5)
[2, 5, 1, 5, 6, 9]  (поменяли 9 и 6)

Проход 2:
[2, 1, 5, 5, 6, 9]  (поменяли 5 и 1)

Проход 3:
[1, 2, 5, 5, 6, 9]  (поменяли 2 и 1)

Проходы 4-5: нет изменений
```

**Ответ:** `[1, 2, 5, 5, 6, 9]`

**Сложность:** O(n²) — медленно, но понятно.

---

### Пример 5: Возведение в степень (наивный алгоритм)

**Задача:** Вычислить \(a^n\) (a в степени n).

**Наивный алгоритм (умножаем n раз):**

```
Алгоритм Степень(a, n):
    result = 1
    Для i от 1 до n:
        result = result * a
    Вернуть result
```

**Программный код (Python):**

```python
def power(a, n):
    result = 1
    for i in range(n):
        result *= a
    return result
```

**Пример:** \(2^5\)

```
Шаг 1: result = 1 * 2 = 2
Шаг 2: result = 2 * 2 = 4
Шаг 3: result = 4 * 2 = 8
Шаг 4: result = 8 * 2 = 16
Шаг 5: result = 16 * 2 = 32
```

**Ответ:** 32.

**Сложность:** O(n) — n умножений.

**Улучшенный алгоритм (быстрое возведение в степень):**

Идея: \(a^{2n} = (a^n)^2\), \(a^{2n+1} = a \cdot (a^n)^2\)

```
Алгоритм БыстраяСтепень(a, n):
    Если n = 0, вернуть 1
    Если n чётное, то:
        half = БыстраяСтепень(a, n/2)
        Вернуть half * half
    Иначе:
        half = БыстраяСтепень(a, (n-1)/2)
        Вернуть a * half * half
```

**Сложность:** O(log n) — гораздо быстрее.

**Пример:** \(2^{10}\)

```
2^10 = (2^5)^2
2^5 = 2 * (2^2)^2 = 2 * 16 = 32
2^2 = (2^1)^2 = 4
2^1 = 2 * (2^0)^2 = 2 * 1 = 2
2^0 = 1

2^10 = (32)^2 = 1024
```

Вместо 10 умножений делаем 4 (log₂(10) ≈ 3.3).

---

## 5.1.6. Сложность алгоритма

### Что такое сложность?

**Сложность алгоритма** — это оценка **количества ресурсов** (времени или памяти), необходимых для выполнения алгоритма в зависимости от размера входных данных.

Есть два типа сложности:

1. **Временная сложность** — сколько **операций** выполняется
2. **Пространственная сложность** — сколько **памяти** используется

Обычно на экзаменах спрашивают про **временную сложность**.

### Нотация O-большое (Big-O)

**O-большое** — это способ **оценить** сложность алгоритма, отбросив константы и младшие члены.

**Формальное определение (не обязательно знать на экзамене):**  
Функция \(f(n) = O(g(n))\), если существуют константы \(c > 0\) и \(n_0\), такие что для всех \(n \geq n_0\) выполняется \(f(n) \leq c \cdot g(n)\).

**Простыми словами:** O(g(n)) — это **верхняя граница** роста времени выполнения.

### Основные классы сложности

| Сложность      | Название            | Пример алгоритма               | Скорость        |
| -------------- | ------------------- | ------------------------------ | --------------- |
| **O(1)**       | Константная         | Обращение к элементу массива   | Очень быстро    |
| **O(log n)**   | Логарифмическая     | Бинарный поиск                 | Быстро          |
| **O(n)**       | Линейная            | Линейный поиск                 | Нормально       |
| **O(n log n)** | Линейно-логарифмическая | QuickSort, MergeSort       | Хорошо          |
| **O(n²)**      | Квадратичная        | Сортировка пузырьком           | Медленно        |
| **O(2ⁿ)**      | Экспоненциальная    | Перебор всех подмножеств       | Очень медленно  |
| **O(n!)**      | Факториальная       | Перебор всех перестановок (TSP)| Катастрофа      |

### Примеры

**1. O(1) — константная сложность**

```python
def get_first(arr):
    return arr[0]  # одна операция
```

Не важно, массив из 10 элементов или из миллиона — выполняется **одна операция**.

**2. O(n) — линейная сложность**

```python
def find_max(arr):
    max_val = arr[0]
    for x in arr:  # n итераций
        if x > max_val:
            max_val = x
    return max_val
```

Для массива из n элементов выполняется **n операций**.

**3. O(n²) — квадратичная сложность**

```python
def bubble_sort(arr):
    n = len(arr)
    for i in range(n):      # n итераций
        for j in range(n):  # n итераций (вложенный цикл)
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
```

Два вложенных цикла → n × n = **n² операций**.

**4. O(log n) — логарифмическая сложность**

```python
def binary_search(arr, x):
    left, right = 0, len(arr) - 1
    while left <= right:  # каждый шаг область поиска уменьшается вдвое
        mid = (left + right) // 2
        if arr[mid] == x:
            return mid
        elif arr[mid] < x:
            left = mid + 1
        else:
            right = mid - 1
    return -1
```

Для массива из n элементов выполняется **log₂(n) итераций**.

**Пример:** n = 1024 → log₂(1024) = 10 итераций. Вместо 1024 проверок (линейный поиск) делаем всего 10. Охренеть какая разница.

**5. O(2ⁿ) — экспоненциальная сложность**

```python
def fibonacci(n):
    if n <= 1:
        return n
    return fibonacci(n-1) + fibonacci(n-2)  # два рекурсивных вызова
```

Для каждого вызова делается ещё 2 вызова → дерево вызовов растёт экспоненциально.

**Пример:** fibonacci(10) делает **177 вызовов**. fibonacci(30) — уже **2 692 537 вызовов**. Компьютер будет думать несколько секунд. fibonacci(50) — вообще не дождёшься.

**Решение:** Использовать динамическое программирование (как в [главе 4.4](04_04_модели_решения_задач.md)) — сложность станет O(n).

### Сравнение сложностей

Пусть n = 1 000 000 (миллион элементов):

| Сложность      | Количество операций | Время (условно, 1 операция = 1 нс) |
| -------------- | ------------------- | ----------------------------------- |
| O(1)           | 1                   | 1 нс                                |
| O(log n)       | 20                  | 20 нс                               |
| O(n)           | 1 000 000           | 1 мс                                |
| O(n log n)     | 20 000 000          | 20 мс                               |
| O(n²)          | 10¹²                | 11 дней                             |
| O(2ⁿ)          | невообразимо        | больше возраста Вселенной           |

**Вывод:** Сложность имеет **огромное значение**. Разница между O(n log n) и O(n²) может быть критичной.

---

## Термины и определения

**Алгоритм** — конечная последовательность чётко определённых действий для решения задачи.

**Дискретность** — алгоритм состоит из отдельных шагов.

**Детерминированность** — каждый шаг алгоритма однозначно определён.

**Конечность** — алгоритм завершается за конечное число шагов.

**Массовость** — алгоритм решает класс задач, а не одну конкретную.

**Результативность** — алгоритм даёт результат (или сообщает о невозможности).

**Исполнитель** — тот, кто выполняет алгоритм (человек, компьютер, робот).

**СКИ (Система Команд Исполнителя)** — набор элементарных действий, которые исполнитель умеет выполнять.

**Словесный способ описания** — описание алгоритма на естественном языке.

**Блок-схема** — графическое представление алгоритма в виде блоков и стрелок.

**Псевдокод** — промежуточный язык между естественным языком и программированием.

**Программный код** — алгоритм, записанный на языке программирования.

**Алгоритм Евклида** — алгоритм нахождения НОД двух чисел.

**Линейный поиск** — последовательная проверка всех элементов массива.

**Бинарный поиск** — поиск в отсортированном массиве методом деления пополам.

**Сортировка пузырьком (Bubble Sort)** — простой алгоритм сортировки сравнением соседних элементов.

**Временная сложность** — количество операций, выполняемых алгоритмом.

**Пространственная сложность** — количество памяти, используемой алгоритмом.

**O-большое (Big-O)** — нотация для оценки сложности алгоритма.

**O(1)** — константная сложность (не зависит от размера входных данных).

**O(log n)** — логарифмическая сложность (область задачи уменьшается вдвое на каждом шаге).

**O(n)** — линейная сложность (время пропорционально размеру данных).

**O(n²)** — квадратичная сложность (два вложенных цикла).

**O(2ⁿ)** — экспоненциальная сложность (катастрофически медленно).

---

## Контрольные вопросы

### Теоретические:

1. **Что такое алгоритм? Дайте определение.**  
   _Подсказка: конечная последовательность чётко определённых действий для решения задачи._

2. **Назовите 5 свойств алгоритма. Объясните каждое.**  
   _Подсказка: Д-Д-К-М-Р (дискретность, детерминированность, конечность, массовость, результативность)._

3. **Что такое СКИ (Система Команд Исполнителя)? Приведите пример.**  
   _Подсказка: набор элементарных действий исполнителя. Пример: СКИ процессора — MOV, ADD, SUB..._

4. **Перечислите 4 способа описания алгоритмов.**  
   _Подсказка: словесный, блок-схема, псевдокод, программный код._

5. **Чем отличается псевдокод от программного кода?**  
   _Подсказка: псевдокод не привязан к конкретному языку программирования, его нельзя запустить на компьютере._

6. **Что означает нотация O(n)? O(n²)? O(log n)?**  
   _Подсказка: линейная сложность, квадратичная, логарифмическая._

7. **Какой алгоритм быстрее: с O(n) или с O(n²)? Во сколько раз при n = 1000?**  
   _Ответ: O(n) быстрее. При n = 1000: O(n) = 1000 операций, O(n²) = 1 000 000 операций. В 1000 раз._

8. **Почему бинарный поиск быстрее линейного?**  
   _Подсказка: бинарный — O(log n), линейный — O(n). Для n = 1024: линейный — 1024 операций, бинарный — 10._

### Практические:

9. **Задача:** Опишите словесно алгоритм заваривания кофе (минимум 5 шагов).  
   _Ответ: 1) Взять турку, 2) Насыпать кофе, 3) Налить воду, 4) Поставить на огонь, 5) Дождаться закипания, 6) Снять с огня._

10. **Задача:** Найдите НОД(36, 48) с помощью алгоритма Евклида. Распишите шаги.  
    _Ответ:_
    ```
    Шаг 1: a = 36, b = 48 → r = 36 mod 48 = 36 → a = 48, b = 36
    Шаг 2: a = 48, b = 36 → r = 48 mod 36 = 12 → a = 36, b = 12
    Шаг 3: a = 36, b = 12 → r = 36 mod 12 = 0 → a = 12, b = 0
    НОД = 12
    ```

11. **Задача:** Найдите максимум в массиве [3, 7, 2, 9, 5] линейным поиском. Распишите шаги.  
    _Ответ:_
    ```
    Шаг 1: max = 3
    Шаг 2: 7 > 3 → max = 7
    Шаг 3: 2 < 7 → max = 7
    Шаг 4: 9 > 7 → max = 9
    Шаг 5: 5 < 9 → max = 9
    Ответ: 9
    ```

12. **Задача:** Примените бинарный поиск для нахождения числа 11 в массиве [1, 3, 5, 7, 9, 11, 13, 15]. Распишите шаги.  
    _Ответ:_
    ```
    Шаг 1: left = 0, right = 7, mid = 3 → A[3] = 7 < 11 → left = 4
    Шаг 2: left = 4, right = 7, mid = 5 → A[5] = 11 = 11 → найдено, индекс 5
    ```

13. **Задача:** Отсортируйте массив [5, 2, 9, 1] методом пузырька. Покажите состояние массива после каждого прохода.  
    _Ответ:_
    ```
    Исходный: [5, 2, 9, 1]
    Проход 1: [2, 5, 1, 9]
    Проход 2: [2, 1, 5, 9]
    Проход 3: [1, 2, 5, 9]
    ```

14. **Задача:** Вычислите 3⁴ наивным алгоритмом (умножением 4 раза). Распишите шаги.  
    _Ответ:_
    ```
    result = 1
    Шаг 1: result = 1 * 3 = 3
    Шаг 2: result = 3 * 3 = 9
    Шаг 3: result = 9 * 3 = 27
    Шаг 4: result = 27 * 3 = 81
    Ответ: 81
    ```

15. **Задача:** Оцените сложность следующего алгоритма:
    ```
    Для i от 1 до n:
        Для j от 1 до n:
            Вывести i + j
    ```
    _Ответ: O(n²) — два вложенных цикла по n итераций._

16. **Задача:** Сколько операций выполнит алгоритм с O(log n) для n = 1024?  
    _Ответ: log₂(1024) = 10 операций._

17. **Задача:** Нарисуйте блок-схему алгоритма "Найти минимум из трёх чисел a, b, c".  
    _Подсказка: Сравнить a и b → если a < b, то min = a, иначе min = b → сравнить min и c → если c < min, то min = c → вывести min._

18. **Задача:** Напишите псевдокод алгоритма "Проверить, является ли число простым".  
    _Ответ:_
    ```
    Алгоритм ПростоеЧисло(n):
        Если n < 2, вернуть Ложь
        Для i от 2 до √n:
            Если n mod i = 0, вернуть Ложь
        Вернуть Истина
    ```

19. **Задача:** Опишите словесно алгоритм нахождения суммы всех элементов массива.  
    _Ответ:_
    ```
    1. Взять массив A размером n
    2. Установить sum = 0
    3. Для каждого элемента A[i]:
       - Прибавить A[i] к sum
    4. Вернуть sum
    ```

20. **Задача:** Какой алгоритм лучше использовать для поиска элемента в **неотсортированном** массиве: линейный или бинарный? Почему?  
    _Ответ: Линейный. Бинарный поиск требует отсортированного массива._

---

## Заключение

Алгоритмы — это **основа программирования**. Без понимания алгоритмов ты будешь писать код, который работает, но медленно, криво и непонятно.

**Главное, что нужно запомнить:**

1. **5 свойств алгоритма:** Дискретность, Детерминированность, Конечность, Массовость, Результативность (Д-Д-К-М-Р).
2. **4 способа описания:** Словесный, блок-схема, псевдокод, программный код.
3. **Сложность имеет значение:** O(n) лучше, чем O(n²). O(log n) — вообще красота.
4. **Классические алгоритмы:** Евклид (НОД), линейный поиск, бинарный поиск, сортировка пузырьком.

На экзамене могут попросить:
- Назвать свойства алгоритма → Д-Д-К-М-Р
- Нарисовать блок-схему → рисуй овалы, прямоугольники, ромбы
- Оценить сложность → считай вложенные циклы
- Применить алгоритм Евклида → вспоминай mod

**Следующая глава:** 5.2 Основные алгоритмические конструкции (там будем разбирать последовательность, ветвление, циклы)  
**Предыдущая глава:** 4.4 Модели решения функциональных задач. Системный подход

Теперь ты знаешь, что такое алгоритм. В следующей главе мы разберём, **из каких конструкций** строятся все алгоритмы (спойлер: их всего три — последовательность, условие, цикл). Удачи на экзамене!


---

[← К оглавлению](README.md)

*Глава 5.1: Алгоритм и его свойства. Способы описания*
