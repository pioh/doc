[← К оглавлению](README.md)

---

# [Глава 7.1](07_01_инфологическое_моделирование.md). Инфологическое моделирование предметной области

## Введение

Представь: тебе надо создать базу данных для университета. С чего начать? С создания таблиц в MySQL? С написания кода на Python? Нихуя подобного. Сначала надо **понять**, что вообще хранить, как это связано между собой, и какие данные критичны. Вот для этого и существует **инфологическое моделирование** — первый и самый важный этап проектирования баз данных.

Инфологическое моделирование — это описание предметной области на языке, понятном человеку, **без привязки к конкретной СУБД**. Ты просто рисуешь картинку: вот тут студенты, вот тут курсы, вот они связаны вот так. Никаких `VARCHAR(255)`, никаких `FOREIGN KEY REFERENCES` — только чистая логика.

Эта глава связана с:
- **Главой 4.1 (Жизненный цикл БД)** — инфологическое моделирование является первым этапом проектирования
- **Главой 7.2 (Архитектура БД)** — модель будет преобразована в логическую, а затем в физическую
- **Главой 7.3 (Реляционные БД)** — ER-диаграммы превратятся в таблицы с ключами и индексами

---

## 1. Уровни представления данных

Проектирование БД происходит в три этапа, каждый со своей моделью:

### 1.1. Инфологическая (концептуальная) модель

**Что**: описание предметной области на языке бизнес-логики  
**Для кого**: аналитики, заказчики, менеджеры  
**Инструмент**: ER-диаграммы (Entity-Relationship)  
**Привязка к СУБД**: нет

Пример: «Студент учится на курсе. Преподаватель ведёт курс. Студент получает оценку за курс.»

### 1.2. Даталогическая (логическая) модель

**Что**: преобразование ER-диаграммы в структуру таблиц  
**Для кого**: разработчики, архитекторы БД  
**Инструмент**: схемы таблиц с типами данных  
**Привязка к СУБД**: да (реляционная модель, но без специфики СУБД)

Пример:
```
Студент (id, фамилия, имя, группа)
Курс (id, название, кредиты)
Оценка (студент_id, курс_id, балл, дата)
```

### 1.3. Физическая модель

**Что**: реализация в конкретной СУБД с индексами, триггерами, хранимыми процедурами  
**Для кого**: DBA (администраторы БД)  
**Инструмент**: SQL DDL (Data Definition Language)  
**Привязка к СУБД**: жёсткая (MySQL, PostgreSQL, Oracle)

Пример:
```sql
CREATE TABLE student (
    id INT PRIMARY KEY AUTO_INCREMENT,
    surname VARCHAR(50) NOT NULL,
    name VARCHAR(50) NOT NULL,
    group_name VARCHAR(10),
    INDEX idx_group (group_name)
) ENGINE=InnoDB;
```

**Зачем три уровня?** Чтобы отделить бизнес-логику (инфологическая) от реализации (физическая). Можно сначала нарисовать ER-диаграмму с заказчиком, а потом спокойно портировать БД с MySQL на PostgreSQL, не меняя концептуальную модель.

---

## 2. ER-диаграммы (Entity-Relationship)

**ER-модель** — это графический способ описания сущностей (entities) и связей (relationships) между ними. Придумана Питером Ченом в 1976 году, и с тех пор стала стандартом де-факто.

### 2.1. Основные элементы

#### Сущность (Entity)

**Сущность** — это объект реального мира, информацию о котором мы хотим хранить.

Примеры:
- Студент
- Курс
- Преподаватель
- Книга
- Заказ
- Товар

На диаграмме: **прямоугольник** с названием сущности.

```
┌─────────────┐
│   Студент   │
└─────────────┘
```

#### Атрибут (Attribute)

**Атрибут** — это свойство сущности.

Примеры атрибутов сущности «Студент»:
- Фамилия
- Имя
- Дата рождения
- Номер зачётки
- Email
- Группа

На диаграмме: **овалы**, соединённые с сущностью, или просто список внутри прямоугольника (зависит от нотации).

```
┌─────────────────────┐
│      Студент        │
├─────────────────────┤
│ • id                │
│ • фамилия           │
│ • имя               │
│ • дата_рождения     │
│ • номер_зачётки     │
│ • email             │
│ • группа            │
└─────────────────────┘
```

#### Ключ (Key)

**Первичный ключ (Primary Key, PK)** — атрибут, однозначно идентифицирующий экземпляр сущности.

Пример: `id`, `номер_зачётки` (если уникален)

На диаграмме: подчёркивание или пометка `PK`.

```
┌─────────────────────┐
│      Студент        │
├─────────────────────┤
│ PK: id              │  ← первичный ключ
│ • фамилия           │
│ • имя               │
│ • email             │
└─────────────────────┘
```

**Внешний ключ (Foreign Key, FK)** — атрибут, ссылающийся на первичный ключ другой сущности. Используется для связывания таблиц.

**Уникальный ключ (Unique Key)** — атрибут, который должен быть уникальным, но не является первичным ключом (например, `email`).

**Составной ключ (Composite Key)** — первичный ключ, состоящий из нескольких атрибутов.

Пример: в таблице `Оценка` ключ = `(студент_id, курс_id)`, если студент может получить только одну оценку за курс.

#### Связь (Relationship)

**Связь** — это ассоциация между двумя (или более) сущностями.

Примеры:
- Студент **учится на** Курсе
- Преподаватель **ведёт** Курс
- Читатель **берёт** Книгу

На диаграмме: **ромб** (классическая нотация Chen) или **линия** с пометками кардинальности (Crow's Foot).

```
┌─────────┐         ┌─────────┐
│ Студент │────────│  Курс   │
└─────────┘         └─────────┘
     учится на
```

---

### 2.2. Типы связей (кардинальность)

#### Один-к-одному (1:1)

Каждая запись сущности A связана **максимум с одной** записью сущности B, и наоборот.

Пример: **Человек ↔ Паспорт**
- У человека один паспорт
- У паспорта один владелец

```
┌─────────┐  1:1  ┌─────────┐
│ Человек │───────│ Паспорт │
└─────────┘       └─────────┘
```

В реальности такие связи встречаются редко. Часто их можно объединить в одну таблицу.

#### Один-ко-многим (1:M или 1:N)

Одна запись сущности A связана с **несколькими** записями сущности B, но каждая запись B связана только с одной записью A.

Пример: **Преподаватель → Курсы**
- Один преподаватель ведёт несколько курсов
- Каждый курс ведёт один преподаватель (упрощение)

```
┌──────────────┐  1    N  ┌──────┐
│ Преподаватель│──────────│ Курс │
└──────────────┘          └──────┘
```

Это **самый распространённый** тип связи. В реляционной БД реализуется через внешний ключ в таблице «многих» (Курс.преподаватель_id).

#### Многие-ко-многим (M:N)

Одна запись сущности A связана с **несколькими** записями сущности B, и наоборот.

Пример: **Студент ↔ Курс**
- Один студент учится на нескольких курсах
- Один курс посещают несколько студентов

```
┌─────────┐  M    N  ┌──────┐
│ Студент │──────────│ Курс │
└─────────┘          └──────┘
```

**Проблема**: в реляционной БД связь M:N напрямую не реализуется. Нужна **промежуточная таблица** (associative entity, junction table).

Решение:

```
┌─────────┐  1    N  ┌──────────┐  N    1  ┌──────┐
│ Студент │──────────│ Запись_на│──────────│ Курс │
└─────────┘          │   курс   │          └──────┘
                     └──────────┘
```

Таблица `Запись_на_курс` содержит:
- `студент_id` (FK)
- `курс_id` (FK)
- дополнительные атрибуты (например, `дата_записи`, `статус`)

Первичный ключ: `(студент_id, курс_id)` (составной ключ).

---

### 2.3. Обязательность связи

**Обязательная связь** (mandatory): сущность **должна** участвовать в связи.

Пример: Заказ **должен** принадлежать Клиенту (не бывает заказов без клиента).

**Необязательная связь** (optional): сущность **может** участвовать в связи.

Пример: Сотрудник **может** иметь Служебный автомобиль (не у всех есть).

Обозначение (нотация Crow's Foot):
- **Обязательная**: вертикальная черта `|`
- **Необязательная**: кружок `○`

```
┌─────────┐       ┌─────────┐
│ Клиент  │|─────○│  Заказ  │
└─────────┘       └─────────┘
    1               0..N
```

Чтение: «Один клиент может иметь ноль или несколько заказов. Каждый заказ принадлежит ровно одному клиенту (обязательно).»

---

## 3. Нотации ER-диаграмм

Существует несколько нотаций для рисования ER-диаграмм. Выбор — дело вкуса, но **Crow's Foot** самая популярная.

### 3.1. Chen Notation (классическая)

**Сущности**: прямоугольники  
**Атрибуты**: овалы  
**Связи**: ромбы  
**Кардинальность**: `1`, `M`, `N` около линии

Плюсы: классика, строгость  
Минусы: громоздко для больших диаграмм

### 3.2. Crow's Foot (вороньи лапки)

**Сущности**: прямоугольники с атрибутами внутри  
**Связи**: линии  
**Кардинальность**: символы на концах линий

Символы:
- `|` — ровно один (обязательно)
- `○` — ноль или один (необязательно)
- `<` (три линии, похоже на вороньи лапки) — много

```
┌─────────┐       ┌──────┐
│ Клиент  │|─────<│ Заказ│
└─────────┘       └──────┘
    1              0..N
```

Чтение: «Клиент может иметь ноль или много заказов. Заказ принадлежит ровно одному клиенту.»

Плюсы: компактность, интуитивность, популярность  
Минусы: иногда путают символы

### 3.3. UML Class Diagram

**Сущности**: классы (прямоугольники с тремя секциями: имя, атрибуты, методы)  
**Связи**: линии с множественностью `1`, `0..1`, `*`, `1..*`

Используется в объектно-ориентированном анализе. В базах данных редко.

### 3.4. IDEF1X

**Стандарт**: федеральный стандарт США для CASE-инструментов  
**Особенности**: строгая нотация, зависимые/независимые сущности, идентифицирующие/неидентифицирующие связи

Плюсы: формальность, поддержка сложных моделей  
Минусы: сложность для новичков

**Вывод**: для учёбы используй **Crow's Foot**. Для работы — то, что принято в компании.

---

## 4. Этапы инфологического моделирования

### Шаг 1: Выделение сущностей

Смотри на задачу и находи **существительные** — кандидаты в сущности.

Пример: «Университет. Студенты учатся на курсах. Преподаватели ведут курсы. Студенты получают оценки.»

Сущности:
- Студент
- Курс
- Преподаватель
- Оценка (или это атрибут? Пока оставим как сущность)

### Шаг 2: Определение атрибутов

Для каждой сущности выпиши её **свойства**.

**Студент**:
- id (PK)
- фамилия
- имя
- отчество
- дата_рождения
- номер_зачётки
- email
- группа

**Курс**:
- id (PK)
- название
- кредиты (количество зачётных единиц)
- семестр

**Преподаватель**:
- id (PK)
- фамилия
- имя
- отчество
- должность (доцент, профессор)
- кафедра

**Оценка**:
- студент_id (FK)
- курс_id (FK)
- балл (0-100)
- дата_сдачи

### Шаг 3: Выбор ключей

Для каждой сущности выбери **первичный ключ** (PK).

Правила:
- Уникальность (без дубликатов)
- Неизменность (не меняется со временем)
- Компактность (лучше `INT`, чем `VARCHAR(200)`)

Часто используют **суррогатный ключ** — искусственный идентификатор `id`, не имеющий бизнес-смысла.

Альтернатива — **естественный ключ** (например, `номер_зачётки`). Но если номера могут измениться или содержать дубликаты — лучше `id`.

### Шаг 4: Определение связей

Смотри на **глаголы** в описании задачи и определяй связи.

- «Студент **учится на** Курсе» → связь M:N (Студент ↔ Курс)
- «Преподаватель **ведёт** Курс» → связь 1:N (Преподаватель → Курс)
- «Студент **получает** Оценку за Курс» → связь M:N (Студент ↔ Курс), реализуется через таблицу Оценка

Рисуем связи и указываем кардинальность (1:1, 1:M, M:N).

### Шаг 5: Проверка модели

Задай себе вопросы:
- Все ли сущности нужны? (Может, какие-то можно объединить?)
- Все ли атрибуты на своих местах? (Может, email нужен в отдельной таблице?)
- Нет ли избыточности? (Не хранится ли одна и та же информация в двух местах?)
- Нет ли аномалий? (Можно ли вставить/удалить/обновить данные без проблем?)

---

## 5. Типы атрибутов

### 5.1. Простые vs составные

**Простой атрибут** — неделимый.

Пример: `возраст`, `email`, `город`

**Составной атрибут** — состоит из нескольких частей.

Пример: `ФИО` = `фамилия` + `имя` + `отчество`

Рекомендация: в БД лучше хранить составные атрибуты как несколько простых. Иначе потом будет боль при сортировке по фамилии или поиске по имени.

### 5.2. Одиночные vs множественные

**Одиночный атрибут** — одно значение.

Пример: `дата_рождения` (одна на человека)

**Множественный атрибут** — несколько значений.

Пример: `телефоны` (домашний, мобильный, рабочий)

Проблема: в реляционной БД нельзя хранить массив в одном поле (нарушение 1НФ, первой нормальной формы).

Решение:
- Вариант 1: несколько полей (`телефон_1`, `телефон_2`, `телефон_3`) — костыль, не расширяется
- Вариант 2: отдельная таблица `Телефоны` (телефон, тип, владелец_id) — правильно

### 5.3. Обязательные vs необязательные

**Обязательный атрибут** (NOT NULL) — должен быть заполнен.

Пример: `фамилия`, `дата_рождения`

**Необязательный атрибут** (NULL allowed) — может быть пустым.

Пример: `отчество` (не у всех есть), `email` (можно не указывать)

### 5.4. Вычисляемые атрибуты

**Вычисляемый атрибут** — значение выводится из других атрибутов.

Пример: `возраст` = текущий год минус `год_рождения`

Рекомендация: не хранить вычисляемые атрибуты в БД (избыточность, риск несоответствия). Вычисляй на лету в запросах или в приложении.

Исключение: если вычисление сложное и используется часто, можно хранить с периодическим пересчётом.

---

## 6. Слабые сущности

**Слабая сущность** — сущность, которая не может существовать без другой сущности (владельца).

Признаки:
- Нет собственного первичного ключа (или ключ зависит от владельца)
- Удаление владельца удаляет все связанные слабые сущности (каскадное удаление)

Пример: **Комментарий** к посту в соцсети.
- Комментарий не существует без поста
- Если пост удалён, все комментарии тоже удаляются
- Ключ комментария: `(пост_id, комментарий_id)` — составной ключ, включающий FK

На диаграмме (Chen): двойной прямоугольник.

```
┌────────┐  1    N  ╔═══════════╗
│  Пост  │──────────║ Комментарий║
└────────┘          ╚═══════════╝
```

В реальности различие между слабыми и обычными сущностями размыто. Главное — понять зависимость и настроить `ON DELETE CASCADE` в БД.

---

## 7. Обобщение и специализация

**Обобщение (generalization)** — выделение общих свойств нескольких сущностей в родительскую сущность.

**Специализация (specialization)** — создание подтипов сущности с дополнительными атрибутами.

Это **наследование** в базах данных.

### Пример: Пользователи вуза

Есть три типа пользователей: Студент, Преподаватель, Администратор.

Общие атрибуты (для всех):
- id
- фамилия
- имя
- email
- дата_регистрации

Специфичные атрибуты:
- **Студент**: номер_зачётки, группа, курс
- **Преподаватель**: должность, кафедра, учёная_степень
- **Администратор**: права_доступа, отдел

### Способы реализации в БД

#### 1. Одна таблица для всех (Single Table Inheritance)

```
Пользователь (id, фамилия, имя, email, тип, номер_зачётки, группа, должность, кафедра, права_доступа, ...)
```

Плюсы: простота, один запрос  
Минусы: много NULL-полей, смешение атрибутов

#### 2. Таблица для каждого подтипа (Class Table Inheritance)

```
Пользователь (id, фамилия, имя, email, дата_регистрации)
Студент (id FK, номер_зачётки, группа, курс)
Преподаватель (id FK, должность, кафедра, учёная_степень)
Администратор (id FK, права_доступа, отдел)
```

Плюсы: нормализация, нет лишних NULL  
Минусы: JOIN при выборке, сложнее запросы

#### 3. Конкретные таблицы (Concrete Table Inheritance)

```
Студент (id, фамилия, имя, email, номер_зачётки, группа, курс)
Преподаватель (id, фамилия, имя, email, должность, кафедра)
Администратор (id, фамилия, имя, email, права_доступа, отдел)
```

Плюсы: производительность (нет JOIN)  
Минусы: дублирование структуры, сложно делать запросы по всем пользователям

**Рекомендация**: если подтипов мало и они похожи — вариант 1. Если много и сильно различаются — вариант 2.

---

## 8. Агрегация и композиция

Эти концепции пришли из ООП, но применимы и в БД.

### Агрегация

**Агрегация** — отношение «целое-часть», где части могут существовать независимо.

Пример: **Университет** содержит **Факультеты**. Факультет может существовать и без университета (теоретически).

На диаграмме UML: пустой ромбик.

### Композиция

**Композиция** — отношение «целое-часть», где части **не могут** существовать без целого.

Пример: **Заказ** содержит **Позиции заказа**. Позиция заказа не имеет смысла без заказа.

На диаграмме UML: закрашенный ромбик.

**Реализация в БД**: композиция часто реализуется через `ON DELETE CASCADE` — при удалении заказа автоматически удаляются все его позиции.

---

## 9. Примеры ER-диаграмм

### Пример 1: Интернет-магазин

**Сущности**:
- Пользователь
- Товар
- Категория
- Заказ
- Позиция_заказа
- Корзина
- Позиция_корзины

**Связи**:
- Пользователь 1 — N Заказ (один пользователь делает много заказов)
- Заказ 1 — N Позиция_заказа (один заказ содержит много позиций)
- Товар 1 — N Позиция_заказа (один товар может быть в нескольких заказах)
- Товар M — N Категория (один товар может быть в нескольких категориях)
- Пользователь 1 — 1 Корзина (у пользователя одна корзина)
- Корзина 1 — N Позиция_корзины

**Атрибуты Товара**:
- id (PK)
- название
- описание
- цена
- количество_на_складе
- изображение_url

**Атрибуты Заказа**:
- id (PK)
- пользователь_id (FK)
- дата_создания
- статус (новый, оплачен, отправлен, доставлен)
- сумма_итого
- адрес_доставки

**Атрибуты Позиции_заказа**:
- id (PK)
- заказ_id (FK)
- товар_id (FK)
- количество
- цена_за_единицу (цена на момент заказа, а не текущая!)

### Пример 2: Библиотека

**Сущности**:
- Книга
- Читатель
- Выдача
- Автор

**Связи**:
- Книга M — N Автор (книга может иметь нескольких авторов)
- Читатель 1 — N Выдача (читатель может брать много книг)
- Книга 1 — N Выдача (книга может быть выдана много раз, но не одновременно)

**Атрибуты Книги**:
- id (PK)
- название
- ISBN
- год_издания
- издательство
- количество_экземпляров

**Атрибуты Выдачи**:
- id (PK)
- книга_id (FK)
- читатель_id (FK)
- дата_выдачи
- дата_возврата_план
- дата_возврата_факт
- статус (на руках, возвращена, просрочена)

### Пример 3: Социальная сеть (упрощённая)

**Сущности**:
- Пользователь
- Пост
- Комментарий
- Лайк
- Дружба

**Связи**:
- Пользователь 1 — N Пост (пользователь пишет много постов)
- Пост 1 — N Комментарий (пост имеет много комментариев)
- Пользователь 1 — N Комментарий (пользователь пишет много комментариев)
- Пост 1 — N Лайк (пост имеет много лайков)
- Пользователь 1 — N Лайк (пользователь ставит много лайков)
- Пользователь M — N Пользователь через Дружба (друзья друг с другом)

**Особенность**: связь Дружба — это M:N между Пользователь и Пользователь (рекурсивная связь).

Таблица Дружба:
- пользователь_1_id (FK)
- пользователь_2_id (FK)
- дата_добавления
- статус (запрос, подтверждено, отклонено)

Первичный ключ: `(пользователь_1_id, пользователь_2_id)` или отдельное `id`.

---

## 10. Инструменты для создания ER-диаграмм

### Онлайн-инструменты

1. **draw.io** (diagrams.net)
   - Бесплатный, без регистрации
   - Есть шаблоны ER-диаграмм
   - Экспорт в PNG, SVG, PDF
   - Интеграция с Google Drive, GitHub

2. **dbdiagram.io**
   - Специализированный инструмент для БД
   - Описание схемы на языке DBML (Database Markup Language)
   - Автоматическая генерация диаграмм
   - Экспорт в SQL, PDF, PNG

3. **Lucidchart**
   - Профессиональный инструмент (платная подписка)
   - Коллаборация в реальном времени
   - Шаблоны для Crow's Foot, Chen, UML

4. **Miro**
   - Онлайн-доска для совместной работы
   - Можно рисовать ER-диаграммы
   - Хорошо для мозговых штурмов

### Десктопные инструменты

1. **MySQL Workbench**
   - Бесплатный, open-source
   - Визуальное проектирование БД
   - Генерация SQL из ER-диаграммы
   - Обратное проектирование (создание диаграммы из существующей БД)

2. **pgModeler** (для PostgreSQL)
   - Open-source
   - Поддержка расширенных возможностей PostgreSQL

3. **ERwin Data Modeler**
   - Профессиональный инструмент (дорогой)
   - Используется в крупных компаниях
   - Поддержка IDEF1X, UML

4. **Enterprise Architect**
   - UML и ER-моделирование
   - Поддержка большого числа нотаций
   - Генерация кода и SQL

**Рекомендация**: для учёбы используй **draw.io** или **dbdiagram.io**. Для работы — **MySQL Workbench** или **pgModeler**.

---

## 11. Связь с другими главами

- **Глава 4.1 (Жизненный цикл БД)**: инфологическое моделирование — это фаза **концептуального проектирования** (первая фаза после анализа требований).

- **Глава 4.2 (Информационные модели)**: ER-диаграмма — это **структурная информационная модель** предметной области.

- **Глава 7.2 (Понятие БД. Архитектура)**: инфологическая модель преобразуется в **даталогическую** (логическую), а затем в **физическую** модель.

- **Глава 7.3 (Реляционные БД. Нормализация)**: ER-диаграммы превращаются в таблицы. Связи M:N превращаются в промежуточные таблицы. Проводится нормализация (1НФ, 2НФ, 3НФ) для устранения избыточности.

---

## 12. Типичные ошибки при моделировании

### 1. Хранение вычисляемых данных

**Ошибка**: в таблице `Товар` хранить `цена_со_скидкой`.

**Проблема**: при изменении процента скидки придётся обновлять все записи. Риск несоответствия данных.

**Решение**: хранить `цена` и `процент_скидки`, вычислять цену со скидкой в запросе.

### 2. Избыточность данных

**Ошибка**: в таблице `Заказ` хранить `имя_клиента`, `email_клиента`, `адрес_клиента`.

**Проблема**: при изменении email клиента придётся обновлять все его заказы. Аномалия обновления.

**Решение**: хранить только `клиент_id` (FK), остальные данные — в таблице `Клиент`.

### 3. Множественные значения в одном поле

**Ошибка**: в таблице `Книга` поле `авторы = "Кнут, Таненбаум, Кормен"`.

**Проблема**: поиск по автору становится кошмаром. Нарушение 1НФ.

**Решение**: отдельная таблица `Автор` и связь M:N через таблицу `Книга_Автор`.

### 4. Отсутствие первичного ключа

**Ошибка**: таблица `Оценка` без ключа.

**Проблема**: дубликаты записей, невозможность однозначно идентифицировать запись.

**Решение**: добавить составной ключ `(студент_id, курс_id)` или суррогатный ключ `id`.

### 5. Неправильная кардинальность

**Ошибка**: связь Студент 1 — 1 Курс (один студент учится на одном курсе).

**Проблема**: студент не может посещать несколько курсов. Нереалистичная модель.

**Решение**: связь Студент M — N Курс.

### 6. Слишком много атрибутов в одной сущности

**Ошибка**: сущность `Пользователь` с 50 атрибутами (личные данные, настройки, статистика, платёжные данные...).

**Проблема**: «толстая» таблица, долгие запросы, нарушение принципа единственной ответственности.

**Решение**: декомпозиция на несколько таблиц (`Пользователь`, `Профиль`, `Настройки`, `Статистика`, `Платёжная_информация`).

---

## Ключевые термины и определения

- **Инфологическая модель** — концептуальная модель предметной области, описывающая сущности и связи без привязки к СУБД.
- **ER-диаграмма** — графическое представление сущностей и связей (Entity-Relationship Diagram).
- **Сущность (Entity)** — объект реального мира, информацию о котором мы храним (например, Студент, Курс).
- **Атрибут (Attribute)** — свойство сущности (например, фамилия, дата_рождения).
- **Первичный ключ (Primary Key, PK)** — атрибут, однозначно идентифицирующий экземпляр сущности.
- **Внешний ключ (Foreign Key, FK)** — атрибут, ссылающийся на первичный ключ другой таблицы.
- **Связь (Relationship)** — ассоциация между сущностями (например, «Студент учится на Курсе»).
- **Кардинальность** — количественная характеристика связи: 1:1, 1:N, M:N.
- **Слабая сущность** — сущность, не имеющая собственного первичного ключа и зависящая от другой сущности.
- **Суррогатный ключ** — искусственный идентификатор (обычно `id`), не имеющий бизнес-смысла.
- **Естественный ключ** — ключ, имеющий бизнес-смысл (например, `номер_паспорта`, `ISBN`).
- **Нотация Crow's Foot** — популярная нотация ER-диаграмм с символами в виде вороньих лапок для обозначения кардинальности.
- **Обязательность связи** — должна ли сущность участвовать в связи (обязательная | или необязательная ○).

---

## Контрольные вопросы

### Теоретические вопросы

1. **Чем отличается инфологическая модель от даталогической и физической?**  
   Ответ: Инфологическая — концептуальное описание предметной области без привязки к СУБД. Даталогическая — структура таблиц с типами данных (реляционная модель). Физическая — реализация в конкретной СУБД с индексами, триггерами, хранимыми процедурами.

2. **Что такое кардинальность связи? Перечислите три типа.**  
   Ответ: Кардинальность — количественная характеристика связи между сущностями. Типы: 1:1 (один-к-одному), 1:N (один-ко-многим), M:N (многие-ко-многим).

3. **Почему связь M:N нельзя реализовать напрямую в реляционной БД? Как её реализовать?**  
   Ответ: В реляционной БД нельзя хранить массивы внешних ключей в одном поле. Решение: создать промежуточную таблицу (associative entity) с двумя внешними ключами.

### Практические задачи

4. **Спроектируйте ER-диаграмму для системы управления проектами. Сущности: Пользователь, Проект, Задача, Комментарий.**

   Подсказка:
   - Пользователь 1 — N Проект (один пользователь создаёт много проектов)
   - Проект 1 — N Задача (проект содержит много задач)
   - Задача 1 — N Комментарий (задача имеет много комментариев)
   - Пользователь M — N Проект (участники проекта)
   - Пользователь 1 — N Задача (исполнитель задачи)

5. **В интернет-магазине таблица "Позиция_заказа" содержит атрибуты: заказ_id, товар_id, количество, цена_за_единицу. Почему важно хранить цену_за_единицу, а не брать её из таблицы Товар?**

   Ответ: Цена товара может измениться. Если хранить только ссылку на товар, то при изменении цены в таблице Товар изменится и сумма в старых заказах. Это приведёт к несоответствию между суммой заказа и фактически оплаченной суммой. Поэтому цена фиксируется на момент создания заказа.

---

## Заключение

Инфологическое моделирование — это первый и самый важный шаг в проектировании БД. Хорошая ER-диаграмма — это половина успеха. Если накосячить на этом этапе, то дальше будет только хуже: кривые таблицы, аномалии, баги, бесконечные миграции.

Потрать время на продумывание модели. Нарисуй диаграмму, покажи коллегам (или преподавателю), поищи дырки. Лучше исправить ошибку в диаграмме, чем потом переписывать половину кода.

И помни: **ER-диаграмма не высечена в камне**. Требования меняются, бизнес-логика меняется, модель тоже меняется. Главное — фиксировать изменения и обновлять документацию.

Удачи с моделированием! В следующей главе разберём архитектуру БД и преобразование ER-диаграмм в реляционные таблицы.


---

[← К оглавлению](README.md)

*Глава 7.1: . Инфологическое моделирование предметной области*
