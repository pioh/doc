[← К оглавлению](README.md)

---

# [Глава 7.2](07_02_понятие_бд_архитектура.md). Понятие база данных. Архитектура БД

## Введение

Помнишь времена, когда все данные хранились в файлах Excel? Или ещё хуже — в текстовых файлах? Представь: у тебя интернет-магазин, и данные о клиентах лежат в `clients.txt`, заказы — в `orders.xlsx`, товары — в `products.csv`. А теперь надо узнать, кто купил самый дорогой товар за последний месяц. Приятного аппетита — полдня гребёшься в файлах, сводишь данные вручную, и в итоге получаешь хуйню, потому что кто-то удалил строку или перепутал ID.

Вот для того, чтобы не страдать этой хернёй, и придумали **базы данных (БД)**. Это не просто "папка с файлами", а **организованная система хранения данных**, которая умеет:
- Быстро искать (индексы)
- Контролировать целостность (если удалили товар, заказы на него тоже удаляются)
- Работать с тысячами пользователей одновременно (многопользовательский доступ)
- Откатывать изменения, если что-то пошло не так (транзакции)
- Защищать данные от несанкционированного доступа (права доступа)

Эта глава связана с:
- **Главой 4.1 (Жизненный цикл БД)** — там мы разобрали фазы проектирования и эксплуатации БД
- **Главой 7.1 (Инфологическое моделирование)** — это концептуальный уровень архитектуры БД
- **Главой 7.3 (Реляционные БД)** — детально разберём реляционную модель и нормализацию

---

## 7.2.1. Понятие базы данных

### Определение

**База данных (БД, Database)** — это структурированная совокупность данных, организованная по определённым правилам, которая позволяет эффективно хранить, обрабатывать и извлекать информацию.

**Ключевые слова:**
- **Структурированная** — данные не валяются кучей, а организованы (таблицы, связи, ключи)
- **Совокупность** — не один файл, а множество взаимосвязанных данных
- **По правилам** — есть схема БД (какие таблицы, какие столбцы, какие типы данных)
- **Эффективно** — быстрый поиск, минимум избыточности, контроль целостности

### БД vs файловая система

Почему БД лучше, чем папка с файлами? Сравним:

| Критерий | Файловая система | База данных |
|----------|------------------|-------------|
| **Избыточность** | Дублирование данных (один клиент в 10 файлах) | Нормализация (клиент один раз в таблице) |
| **Целостность** | Нет контроля (можно удалить клиента, заказы останутся) | Контроль (внешние ключи, каскадное удаление) |
| **Многопользовательский доступ** | Блокировки файлов, конфликты | Транзакции, изоляция, MVCC |
| **Поиск** | Линейный (O(n)) по всему файлу | Индексы (O(log n)) |
| **Безопасность** | Права доступа к файлам (грубо) | Детальные права (на таблицу, столбец, строку) |
| **Резервное копирование** | Копировать каждый файл | Одна команда `mysqldump` |
| **Язык запросов** | Нет (пиши парсер вручную) | SQL (стандартизирован) |

**Пример 1: Проблема файловой системы**

Представь: у тебя интернет-магазин, данные хранятся в файлах.

**Файл `clients.txt`:**
```
1|Иванов Иван|ivan@mail.ru|Москва, ул. Ленина, 10
2|Петров Пётр|petr@mail.ru|СПб, Невский проспект, 5
```

**Файл `orders.txt`:**
```
101|1|Носки|150|2025-01-10
102|2|Трусы|200|2025-01-11
103|1|Майка|300|2025-01-12
```

**Задача:** Найти все заказы клиента `ivan@mail.ru`.

**Решение:**
1. Открыть `clients.txt`, найти строку с `ivan@mail.ru`, взять ID (это `1`)
2. Открыть `orders.txt`, пройтись по всем строкам, выбрать те, где второе поле = `1`
3. Вручную склеить данные

**Проблемы:**
- Если у тебя 1 млн заказов, будешь читать весь файл (медленно)
- Если два пользователя одновременно меняют файл, один потеряет изменения
- Если удалить клиента из `clients.txt`, заказы в `orders.txt` станут "висячими" (ID несуществующего клиента)
- Если в `orders.txt` опечатка (ID клиента `999`, которого нет), заказ "потеряется"

**С базой данных:**

```sql
-- Найти все заказы клиента ivan@mail.ru
SELECT orders.*
FROM orders
JOIN clients ON orders.client_id = clients.id
WHERE clients.email = 'ivan@mail.ru';
```

**Преимущества:**
- Запрос выполняется за миллисекунды (индексы)
- Если удалить клиента, можно настроить каскадное удаление заказов
- Если попытаться добавить заказ с несуществующим `client_id`, БД выдаст ошибку (целостность)

---

### Преимущества БД

1. **Централизация данных**  
   Все данные в одном месте, а не разбросаны по 100 файлам.

2. **Контроль целостности**  
   Можно задать правила:
   - Первичный ключ (PRIMARY KEY) — уникальность записей
   - Внешний ключ (FOREIGN KEY) — связи между таблицами
   - Ограничения (CHECK) — например, цена товара > 0

3. **Многопользовательский доступ**  
   1000 пользователей одновременно могут читать и писать, и никто никому не мешает (благодаря **транзакциям** и **блокировкам**).

4. **Безопасность**  
   Можно настроить права доступа:
   - Пользователь `admin` видит всё
   - Пользователь `manager` видит только таблицу `orders`
   - Пользователь `guest` может только читать, но не изменять

5. **Резервное копирование**  
   Одна команда — и вся БД сохранена. Можно настроить автоматические бэкапы.

6. **Язык запросов (SQL)**  
   Стандартизированный язык для работы с данными. Выучил раз — используешь везде (MySQL, PostgreSQL, Oracle).

### Недостатки БД

Но не всё так радужно:

1. **Сложность**  
   Надо учить SQL, понимать нормализацию, настраивать СУБД. Для маленького проекта (10 записей) — овёркилл.

2. **Стоимость**  
   Некоторые СУБД (Oracle, MS SQL Server) стоят дофига денег. Хотя есть бесплатные (PostgreSQL, MySQL, SQLite).

3. **Производительность**  
   Для некоторых задач (например, обработка больших файлов log'ов) БД медленнее, чем просто чтение файлов. Или если нужна сверхнизкая задержка (real-time системы), БД может быть узким местом.

4. **Зависимость от СУБД**  
   Если написал кучу SQL-запросов под MySQL, а потом решил переехать на PostgreSQL, часть запросов надо переписывать (хотя стандарт SQL единый, в деталях отличия есть).

---

## 7.2.2. СУБД (Система Управления Базами Данных)

### Определение

**СУБД (DBMS, Database Management System)** — это программное обеспечение для создания, управления и доступа к базам данных.

**Аналогия:** БД — это библиотека (книги на полках), а СУБД — это библиотекарь, который знает, где какая книга лежит, может быстро найти нужную, выдать тебе, и записать, что ты взял.

Без СУБД БД — это просто файлы на диске. СУБД делает всю магию: парсит SQL-запросы, оптимизирует их, выполняет, управляет транзакциями, блокировками, индексами.

### Функции СУБД

СУБД выполняет 4 основные группы функций:

#### 1. DDL (Data Definition Language) — Определение данных

Создание структуры БД: таблицы, индексы, ограничения.

**Команды:**
- `CREATE TABLE` — создать таблицу
- `ALTER TABLE` — изменить структуру таблицы
- `DROP TABLE` — удалить таблицу
- `CREATE INDEX` — создать индекс

**Пример:**
```sql
CREATE TABLE students (
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(100) NOT NULL,
    age INT CHECK (age >= 16),
    email VARCHAR(100) UNIQUE
);
```

#### 2. DML (Data Manipulation Language) — Манипуляция данными

Работа с данными: добавление, изменение, удаление, поиск.

**Команды:**
- `INSERT` — добавить запись
- `UPDATE` — изменить запись
- `DELETE` — удалить запись
- `SELECT` — выбрать записи

**Пример:**
```sql
-- Добавить студента
INSERT INTO students (name, age, email) VALUES ('Иван Иванов', 20, 'ivan@mail.ru');

-- Найти всех студентов старше 18 лет
SELECT * FROM students WHERE age > 18;

-- Изменить возраст студента
UPDATE students SET age = 21 WHERE email = 'ivan@mail.ru';

-- Удалить студента
DELETE FROM students WHERE id = 5;
```

#### 3. DCL (Data Control Language) — Контроль доступа

Управление правами пользователей.

**Команды:**
- `GRANT` — дать права
- `REVOKE` — отозвать права

**Пример:**
```sql
-- Дать пользователю manager право читать таблицу orders
GRANT SELECT ON orders TO manager;

-- Отозвать право изменять таблицу orders
REVOKE UPDATE ON orders FROM manager;
```

#### 4. TCL (Transaction Control Language) — Управление транзакциями

**Транзакция** — это последовательность операций, которая выполняется как единое целое (либо все операции успешны, либо ни одной).

**Команды:**
- `BEGIN` / `START TRANSACTION` — начать транзакцию
- `COMMIT` — зафиксировать изменения
- `ROLLBACK` — откатить изменения

**Пример:**
```sql
START TRANSACTION;

-- Списать 100 рублей со счёта Ивана
UPDATE accounts SET balance = balance - 100 WHERE user = 'Ivan';

-- Добавить 100 рублей на счёт Петра
UPDATE accounts SET balance = balance + 100 WHERE user = 'Petr';

COMMIT;  -- Если всё ОК, зафиксировать
-- Или ROLLBACK, если что-то пошло не так
```

**Зачем?** Если между двумя операциями произошёл сбой (отключилось электричество), без транзакции деньги могут "потеряться" (списались с Ивана, но не добавились Петру). С транзакцией — либо обе операции выполнятся, либо ни одна.

### Примеры СУБД

| СУБД | Тип | Платная? | Описание |
|------|-----|----------|----------|
| **MySQL** | Реляционная | Бесплатная (Community Edition) | Самая популярная open-source СУБД. Используют WordPress, Joomla, Facebook (ранние версии). |
| **PostgreSQL** | Реляционная | Бесплатная | Более "продвинутая" чем MySQL: поддержка JSON, массивов, full-text search. Используют Instagram, Reddit, Spotify. |
| **Oracle Database** | Реляционная | Платная (дорогая) | Корпоративная СУБД для банков, гос. структур. Мощная, но стоит как самолёт. |
| **MS SQL Server** | Реляционная | Платная (есть Express бесплатная) | От Microsoft. Хорошо интегрируется с .NET, Windows. |
| **SQLite** | Реляционная | Бесплатная | Лёгкая встраиваемая СУБД (один файл). Используют мобильные приложения (Android, iOS). |
| **MongoDB** | Документоориентированная (NoSQL) | Бесплатная (Community) | Хранит данные в JSON-подобном формате. Хороша для гибких схем (не надо заранее задавать структуру таблиц). |
| **Redis** | Ключ-значение (NoSQL) | Бесплатная | In-memory БД (данные в оперативной памяти). Используют для кэширования, очередей. Очень быстрая. |
| **Cassandra** | Колоночная (NoSQL) | Бесплатная | Распределённая БД для больших данных. Используют Netflix, Uber. |
| **Neo4j** | Графовая (NoSQL) | Бесплатная (Community) | Для хранения графов (социальные сети, рекомендательные системы). |

**Какую выбрать?**
- Простой сайт / приложение → **MySQL** или **PostgreSQL**
- Мобильное приложение → **SQLite**
- Микросервисы, гибкая схема → **MongoDB**
- Кэширование, очереди → **Redis**
- Социальная сеть, рекомендации → **Neo4j**

---

## 7.2.3. Архитектура БД (трёхуровневая модель ANSI-SPARC)

Представь: у тебя университет. Есть 3 типа пользователей:
1. **Студент** — видит только свои оценки
2. **Преподаватель** — видит оценки студентов своих курсов
3. **Декан** — видит всё: оценки всех студентов, зарплаты преподавателей, финансы

Как организовать БД, чтобы каждый видел только то, что ему нужно? Вот для этого придумали **трёхуровневую архитектуру ANSI-SPARC** (стандарт 1975 года).

### Три уровня архитектуры

```
┌─────────────────────────────────────┐
│  Внешний уровень (External Level)   │  ← Представления (Views) для пользователей
│  Студент видит: свои оценки         │
│  Преподаватель видит: оценки курса  │
└─────────────────────────────────────┘
            ↓ Отображение
┌─────────────────────────────────────┐
│ Концептуальный уровень (Conceptual) │  ← Логическая структура всей БД (таблицы, связи)
│  Таблицы: Students, Courses, Grades │
└─────────────────────────────────────┘
            ↓ Отображение
┌─────────────────────────────────────┐
│  Внутренний уровень (Internal)      │  ← Физическое хранение данных (файлы, индексы)
│  Файлы на диске, B-деревья, буферы  │
└─────────────────────────────────────┘
```

### Уровень 1: Внешний (External / View Level)

**Что:** Представления данных для пользователей и приложений.

**Для кого:** Конечные пользователи (студенты, преподаватели, админы).

**Как:** Через **представления (Views)** — виртуальные таблицы, созданные SQL-запросами.

**Пример 2: Представления для университета**

```sql
-- Представление для студента (только свои оценки)
CREATE VIEW my_grades AS
SELECT courses.name, grades.score, grades.date
FROM grades
JOIN courses ON grades.course_id = courses.id
WHERE grades.student_id = CURRENT_USER_ID();  -- ID текущего пользователя

-- Представление для преподавателя (оценки студентов своих курсов)
CREATE VIEW my_students_grades AS
SELECT students.name, courses.name, grades.score
FROM grades
JOIN students ON grades.student_id = students.id
JOIN courses ON grades.course_id = courses.id
WHERE courses.teacher_id = CURRENT_USER_ID();
```

**Студент делает запрос:**
```sql
SELECT * FROM my_grades;
```

Он видит только свои оценки, хотя физически в таблице `grades` лежат оценки всех студентов.

**Зачем?**
- **Безопасность:** каждый видит только то, что ему разрешено
- **Упрощение:** пользователю не надо знать структуру всех таблиц, он работает с простым представлением

### Уровень 2: Концептуальный (Conceptual / Logical Level)

**Что:** Логическая структура всей БД (какие таблицы, какие столбцы, какие связи).

**Для кого:** Разработчики, архитекторы БД.

**Как:** Схема БД (ER-диаграмма → таблицы).

**Пример 3: Концептуальная схема университета**

```sql
-- Таблица студентов
CREATE TABLE students (
    id INT PRIMARY KEY,
    name VARCHAR(100),
    email VARCHAR(100) UNIQUE,
    group_id INT,
    FOREIGN KEY (group_id) REFERENCES groups(id)
);

-- Таблица курсов
CREATE TABLE courses (
    id INT PRIMARY KEY,
    name VARCHAR(100),
    credits INT,
    teacher_id INT,
    FOREIGN KEY (teacher_id) REFERENCES teachers(id)
);

-- Таблица оценок
CREATE TABLE grades (
    student_id INT,
    course_id INT,
    score INT CHECK (score >= 0 AND score <= 100),
    date DATE,
    PRIMARY KEY (student_id, course_id),
    FOREIGN KEY (student_id) REFERENCES students(id),
    FOREIGN KEY (course_id) REFERENCES courses(id)
);
```

**Зачем?**
- Описывает всю логику предметной области (что с чем связано)
- Не зависит от конкретной СУБД (можно портировать с MySQL на PostgreSQL)

### Уровень 3: Внутренний (Internal / Physical Level)

**Что:** Физическое хранение данных на диске (файлы, индексы, буферы).

**Для кого:** DBA (администраторы БД), разработчики СУБД.

**Как:** 
- Файловая структура (InnoDB, MyISAM для MySQL)
- Индексы (B-деревья, хэш-таблицы)
- Буферы (кэш в оперативной памяти)

**Пример 4: Физическая структура**

```sql
-- Создать индекс для ускорения поиска студентов по email
CREATE INDEX idx_email ON students(email);

-- Задать тип таблицы (для MySQL)
ALTER TABLE students ENGINE = InnoDB;  -- поддержка транзакций, внешних ключей
```

**Что происходит на диске:**
- Таблица `students` хранится в файле `students.ibd` (InnoDB)
- Индекс `idx_email` — это B-дерево, хранится в том же файле
- При поиске `WHERE email = 'ivan@mail.ru'` СУБД использует индекс (O(log n) вместо O(n))

**Зачем?**
- Оптимизация производительности (индексы, кэширование)
- Управление дисковым пространством (сжатие, партиционирование)

---

## 7.2.4. Независимость данных

Одна из главных идей трёхуровневой архитектуры — **независимость данных** (Data Independence). Это значит, что изменения на одном уровне не влияют на другие.

### Логическая независимость

**Определение:** Изменение концептуальной схемы (добавление/удаление таблиц, столбцов) не влияет на внешние представления (Views).

**Пример 5:**

Допустим, в таблице `students` добавили столбец `phone`:

```sql
ALTER TABLE students ADD COLUMN phone VARCHAR(20);
```

Представление `my_grades` (которое использует только `students.name`) **не сломается** — оно продолжит работать, потому что использует только нужные ему столбцы.

**Зачем?** Можно менять структуру БД (добавлять новые таблицы, столбцы), не переписывая все приложения.

### Физическая независимость

**Определение:** Изменение физической структуры (индексы, файловая система, оптимизация) не влияет на концептуальную схему.

**Пример 6:**

Добавили индекс для ускорения поиска:

```sql
CREATE INDEX idx_student_name ON students(name);
```

SQL-запросы **не меняются** — они как писали `SELECT * FROM students WHERE name = 'Иван'`, так и пишут. Но теперь запрос работает быстрее (благодаря индексу).

**Или:** Переехали с HDD на SSD, или изменили файловую систему (с MyISAM на InnoDB). Логическая схема (таблицы, столбцы) осталась прежней.

**Зачем?** Можно оптимизировать производительность БД (индексы, партиционирование, кэширование), не трогая логику приложений.

---

## 7.2.5. Модели данных

**Модель данных** — это способ организации данных в БД (как структурировать, как связывать).

### 1. Иерархическая модель

**Структура:** Дерево (один родитель — много детей).

**Пример:** Файловая система (папки и файлы), Windows Registry, XML.

```
Университет
├── Факультет физики
│   ├── Группа Ф-101
│   │   ├── Иванов Иван
│   │   └── Петров Пётр
│   └── Группа Ф-102
│       └── Сидоров Сидор
└── Факультет математики
    └── Группа М-101
        └── Смирнов Андрей
```

**Проблемы:**
- Нельзя связать данные из разных веток (например, студент не может быть в двух группах)
- Сложно удалять (если удалить факультет, удалятся все группы и студенты)

**Использование:** Редко, в основном legacy-системы (IBM IMS).

### 2. Сетевая модель

**Структура:** Граф (узлы могут иметь много родителей и детей).

**Пример:** CODASYL (стандарт 1970-х).

```
Студент ←→ Курс ←→ Преподаватель
```

Студент может быть записан на много курсов, курс могут вести несколько преподавателей, и т.д.

**Проблемы:**
- Сложная для понимания
- Много указателей (как в С с указателями — легко ошибиться)

**Использование:** Устарела, почти не используется.

### 3. Реляционная модель (таблицы)

**Структура:** Данные хранятся в таблицах (отношениях).

**Основные понятия:**
- **Таблица (Table)** = отношение (Relation)
- **Строка (Row)** = запись = кортеж (Tuple)
- **Столбец (Column)** = атрибут (Attribute)
- **Первичный ключ (Primary Key, PK)** — уникальный идентификатор записи
- **Внешний ключ (Foreign Key, FK)** — ссылка на запись в другой таблице

**Пример 7: Реляционная модель университета**

**Таблица `students`:**

| id | name | email | group_id |
|----|------|-------|----------|
| 1 | Иванов Иван | ivan@mail.ru | 1 |
| 2 | Петров Пётр | petr@mail.ru | 1 |
| 3 | Сидоров Сидор | sidor@mail.ru | 2 |

**Таблица `groups`:**

| id | name | faculty |
|----|------|---------|
| 1 | Ф-101 | Физика |
| 2 | М-101 | Математика |

**Таблица `courses`:**

| id | name | credits |
|----|------|---------|
| 1 | Физика 1 | 4 |
| 2 | Математический анализ | 5 |

**Таблица `grades` (связь многие-ко-многим):**

| student_id | course_id | score | date |
|------------|-----------|-------|------|
| 1 | 1 | 85 | 2025-01-10 |
| 1 | 2 | 90 | 2025-01-11 |
| 2 | 1 | 75 | 2025-01-10 |

**Связи:**
- `students.group_id` → `groups.id` (внешний ключ)
- `grades.student_id` → `students.id` (внешний ключ)
- `grades.course_id` → `courses.id` (внешний ключ)

**SQL-запрос:** Найти все оценки студента Иванова.

```sql
SELECT students.name, courses.name, grades.score
FROM grades
JOIN students ON grades.student_id = students.id
JOIN courses ON grades.course_id = courses.id
WHERE students.name = 'Иванов Иван';
```

**Результат:**

| name | name | score |
|------|------|-------|
| Иванов Иван | Физика 1 | 85 |
| Иванов Иван | Математический анализ | 90 |

**Преимущества реляционной модели:**
- Простая и понятная (таблицы как в Excel)
- Математически обоснованная (реляционная алгебра)
- SQL — стандартизированный язык
- Доминирующая модель (90% БД — реляционные)

**Недостатки:**
- Для некоторых задач избыточна (например, хранение JSON-документов — лучше MongoDB)
- Нормализация может привести к сложным JOIN'ам (медленно)

### 4. Объектно-ориентированная модель

**Структура:** Объекты (как в ООП: классы, наследование, методы).

**Пример:** `db4o` (для Java, C#).

```java
class Student {
    String name;
    int age;
    List<Course> courses;
}
```

**Использование:** Редко (сложно, не стандартизировано).

### 5. NoSQL (Not Only SQL)

**Когда появились:** 2000-е годы (Google BigTable, Amazon DynamoDB).

**Зачем?** Реляционные БД плохо масштабируются на тысячи серверов. NoSQL — это альтернатива для больших данных (Big Data), гибких схем, распределённых систем.

#### 5.1. Документоориентированные (MongoDB, CouchDB)

**Структура:** Коллекции документов (JSON-подобные объекты).

**Пример:**

```json
{
  "_id": 1,
  "name": "Иванов Иван",
  "email": "ivan@mail.ru",
  "courses": [
    { "name": "Физика 1", "score": 85 },
    { "name": "Математический анализ", "score": 90 }
  ]
}
```

**Преимущества:**
- Гибкая схема (не надо заранее задавать структуру)
- Удобно для вложенных данных (JSON)

**Недостатки:**
- Нет JOIN'ов (надо денормализовывать данные)
- Нет гарантий целостности (можно записать что угодно)

#### 5.2. Ключ-значение (Redis, Memcached)

**Структура:** Хэш-таблица (ключ → значение).

**Пример:**

```
user:1 → {"name": "Иванов", "email": "ivan@mail.ru"}
session:abc123 → {"user_id": 1, "expires": 1234567890}
```

**Использование:** Кэширование, очереди, счётчики.

**Преимущества:**
- Очень быстрая (O(1) для поиска)
- Простая

**Недостатки:**
- Нет запросов (только get/set по ключу)
- Нет связей между данными

#### 5.3. Колоночные (Cassandra, HBase)

**Структура:** Данные хранятся по столбцам (а не по строкам, как в реляционных БД).

**Зачем?** Для аналитики (выборка по столбцам) быстрее.

**Пример:** Cassandra используют Netflix, Uber для хранения логов, событий.

**Преимущества:**
- Горизонтальное масштабирование (тысячи серверов)
- Высокая доступность (нет single point of failure)

**Недостатки:**
- Сложная в настройке
- Eventual consistency (не ACID)

#### 5.4. Графовые (Neo4j, ArangoDB)

**Структура:** Граф (узлы и рёбра).

**Пример:** Социальная сеть.

```
(Иван) --[ДРУГ]--> (Пётр)
(Иван) --[ПОДПИСАН]--> (Канал "Физика")
(Пётр) --[ПОДПИСАН]--> (Канал "Математика")
```

**Использование:** Рекомендательные системы, анализ социальных сетей, логистика.

**Преимущества:**
- Быстрый поиск связей (кратчайший путь, друзья друзей)

**Недостатки:**
- Сложная для традиционных задач (CRUD)

---

## 7.2.6. Связь с жизненным циклом БД

Вспомним **главу 4.1 (Жизненный цикл БД)**. Архитектура БД — это часть фазы **проектирования**:

1. **Анализ требований** → "Нам нужна БД для университета"
2. **Проектирование:**
   - **Концептуальное** (инфологическое) → ER-диаграммы ([глава 7.1](07_01_инфологическое_моделирование.md))
   - **Логическое** (даталогическое) → **Концептуальный уровень архитектуры** (таблицы, связи)
   - **Физическое** → **Внутренний уровень архитектуры** (индексы, файлы)
3. **Реализация** → Создание БД в СУБД (MySQL, PostgreSQL)
4. **Заполнение данными** → INSERT'ы
5. **Эксплуатация** → Пользователи работают через **внешний уровень** (Views)

**Три уровня архитектуры = три этапа проектирования.**

---

## 7.2.7. Пример 8: Разработка БД для интернет-магазина (полный цикл)

Разберём на примере, как всё связано.

### Этап 1: Анализ требований

**Задача:** Создать БД для интернет-магазина.

**Требования:**
- Хранить товары (название, цена, количество на складе)
- Регистрация пользователей (email, пароль, адрес)
- Оформление заказов (корзина → заказ → оплата)
- История заказов пользователя

### Этап 2: Концептуальное проектирование (инфологическое)

**ER-диаграмма:**

```
[Пользователь] --< делает >-- [Заказ] --< содержит >-- [Товар]
```

**Сущности:**
- Пользователь (User): id, email, password, address
- Заказ (Order): id, user_id, date, status
- Товар (Product): id, name, price, stock
- ОрдерТовар (OrderProduct): order_id, product_id, quantity, price

**Связи:**
- Пользователь → Заказ (1:N) — один пользователь может сделать много заказов
- Заказ → Товар (M:N) — заказ содержит много товаров, товар может быть в разных заказах

### Этап 3: Логическое проектирование (концептуальный уровень архитектуры)

**Таблицы:**

```sql
CREATE TABLE users (
    id INT PRIMARY KEY AUTO_INCREMENT,
    email VARCHAR(100) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    address TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE products (
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(100) NOT NULL,
    price DECIMAL(10, 2) NOT NULL CHECK (price > 0),
    stock INT NOT NULL CHECK (stock >= 0)
);

CREATE TABLE orders (
    id INT PRIMARY KEY AUTO_INCREMENT,
    user_id INT NOT NULL,
    date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    status ENUM('pending', 'paid', 'shipped', 'delivered') DEFAULT 'pending',
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);

CREATE TABLE order_products (
    order_id INT,
    product_id INT,
    quantity INT NOT NULL CHECK (quantity > 0),
    price DECIMAL(10, 2) NOT NULL,  -- цена на момент покупки (может измениться в будущем)
    PRIMARY KEY (order_id, product_id),
    FOREIGN KEY (order_id) REFERENCES orders(id) ON DELETE CASCADE,
    FOREIGN KEY (product_id) REFERENCES products(id)
);
```

### Этап 4: Физическое проектирование (внутренний уровень архитектуры)

**Индексы для ускорения:**

```sql
-- Ускорить поиск пользователя по email
CREATE INDEX idx_users_email ON users(email);

-- Ускорить выборку заказов пользователя
CREATE INDEX idx_orders_user_id ON orders(user_id);

-- Ускорить поиск товаров в заказе
CREATE INDEX idx_order_products_order_id ON order_products(order_id);
```

**Оптимизация:**

```sql
-- Использовать InnoDB для поддержки транзакций
ALTER TABLE orders ENGINE = InnoDB;
```

### Этап 5: Внешний уровень (представления для пользователей)

**Представление: История заказов пользователя**

```sql
CREATE VIEW my_orders AS
SELECT orders.id, orders.date, orders.status, 
       SUM(order_products.quantity * order_products.price) AS total
FROM orders
JOIN order_products ON orders.id = order_products.order_id
WHERE orders.user_id = CURRENT_USER_ID()
GROUP BY orders.id;
```

**Пользователь делает запрос:**

```sql
SELECT * FROM my_orders;
```

**Результат:**

| id | date | status | total |
|----|------|--------|-------|
| 1 | 2025-01-10 14:30:00 | delivered | 1500.00 |
| 2 | 2025-01-12 09:15:00 | shipped | 2300.00 |

### Этап 6: Заполнение данными

```sql
-- Добавить пользователя
INSERT INTO users (email, password_hash, address) 
VALUES ('ivan@mail.ru', 'hashed_password_123', 'Москва, ул. Ленина, 10');

-- Добавить товары
INSERT INTO products (name, price, stock) VALUES
('Носки', 150.00, 100),
('Трусы', 200.00, 50),
('Майка', 300.00, 75);

-- Создать заказ
START TRANSACTION;

INSERT INTO orders (user_id, status) VALUES (1, 'pending');
SET @order_id = LAST_INSERT_ID();

-- Добавить товары в заказ
INSERT INTO order_products (order_id, product_id, quantity, price) VALUES
(@order_id, 1, 2, 150.00),  -- 2 пары носков
(@order_id, 3, 1, 300.00);  -- 1 майка

-- Уменьшить количество товаров на складе
UPDATE products SET stock = stock - 2 WHERE id = 1;
UPDATE products SET stock = stock - 1 WHERE id = 3;

COMMIT;
```

**Итого:** Заказ на 600 рублей (2×150 + 1×300).

---

## 7.2.8. Пример 9: Расчёт размера БД

**Задача:** Оценить размер БД для интернет-магазина на 1 млн пользователей, 10 тыс. товаров, 5 млн заказов.

**Таблица `users`:**
- `id` (INT, 4 байта) + `email` (VARCHAR(100), ~30 байт) + `password_hash` (VARCHAR(255), ~60 байт) + `address` (TEXT, ~100 байт) + `created_at` (TIMESTAMP, 4 байта) ≈ **200 байт/запись**
- 1 млн пользователей × 200 байт = **200 МБ**

**Таблица `products`:**
- `id` (INT, 4) + `name` (VARCHAR(100), ~50) + `price` (DECIMAL(10,2), 5) + `stock` (INT, 4) ≈ **65 байт/запись**
- 10 тыс. товаров × 65 байт = **650 КБ**

**Таблица `orders`:**
- `id` (INT, 4) + `user_id` (INT, 4) + `date` (TIMESTAMP, 4) + `status` (ENUM, 1) ≈ **15 байт/запись**
- 5 млн заказов × 15 байт = **75 МБ**

**Таблица `order_products`:**
- `order_id` (INT, 4) + `product_id` (INT, 4) + `quantity` (INT, 4) + `price` (DECIMAL(10,2), 5) ≈ **17 байт/запись**
- Допустим, в среднем 3 товара на заказ → 5 млн × 3 = 15 млн записей
- 15 млн × 17 байт = **255 МБ**

**Индексы (примерно 20-30% от данных):** ~150 МБ

**Итого:** 200 + 0.65 + 75 + 255 + 150 ≈ **680 МБ**

**Вывод:** БД помещается на любой современный диск (SSD на 1 ТБ стоит ~$100). Но если пользователей 100 млн — будет уже **68 ГБ**, и тут нужны более мощные серверы, репликация, шардирование.

---

## 7.2.9. Пример 10: Сравнение реляционной БД и NoSQL

**Задача:** Хранить профили пользователей социальной сети.

### Вариант 1: Реляционная БД (MySQL)

**Таблица `users`:**

| id | name | email | city | age |
|----|------|-------|------|-----|
| 1 | Иван | ivan@mail.ru | Москва | 25 |
| 2 | Пётр | petr@mail.ru | СПб | 30 |

**Таблица `friends` (связь M:N):**

| user_id | friend_id |
|---------|-----------|
| 1 | 2 |
| 2 | 1 |

**Запрос:** Найти всех друзей Ивана.

```sql
SELECT users.name
FROM friends
JOIN users ON friends.friend_id = users.id
WHERE friends.user_id = 1;
```

**Проблемы:**
- JOIN медленный (особенно если друзей 1000)
- Сложно добавить новые поля (например, хобби, список фото) — надо менять схему

### Вариант 2: Документоориентированная БД (MongoDB)

**Документ:**

```json
{
  "_id": 1,
  "name": "Иван",
  "email": "ivan@mail.ru",
  "city": "Москва",
  "age": 25,
  "friends": [2, 5, 10],  // ID друзей
  "hobbies": ["футбол", "программирование"],
  "photos": [
    {"url": "photo1.jpg", "date": "2025-01-01"},
    {"url": "photo2.jpg", "date": "2025-01-05"}
  ]
}
```

**Запрос:** Найти всех друзей Ивана.

```javascript
db.users.find({ _id: { $in: db.users.findOne({ _id: 1 }).friends } })
```

**Преимущества:**
- Нет JOIN'ов (данные в одном документе)
- Гибкая схема (можно добавить поле `hobbies` без изменения структуры)

**Недостатки:**
- Денормализация (если изменилось имя друга, надо обновить во всех документах)
- Нет гарантий целостности (можно записать `friends: [999]`, даже если пользователя 999 не существует)

**Вывод:** Для социальной сети с гибкой схемой и сложными связями (друзья друзей) лучше подходит **графовая БД (Neo4j)** или **документоориентированная (MongoDB)**.

---

## Ключевые термины

- **База данных (БД)** — структурированная совокупность данных
- **СУБД (DBMS)** — программа для управления БД (MySQL, PostgreSQL, Oracle)
- **DDL** — определение данных (CREATE, ALTER, DROP)
- **DML** — манипуляция данными (SELECT, INSERT, UPDATE, DELETE)
- **DCL** — контроль доступа (GRANT, REVOKE)
- **TCL** — управление транзакциями (COMMIT, ROLLBACK)
- **Трёхуровневая архитектура ANSI-SPARC** — внешний, концептуальный, внутренний уровни
- **Внешний уровень** — представления (Views) для пользователей
- **Концептуальный уровень** — логическая структура БД (таблицы, связи)
- **Внутренний уровень** — физическое хранение (индексы, файлы)
- **Логическая независимость** — изменение концептуальной схемы не влияет на представления
- **Физическая независимость** — изменение физической структуры не влияет на концептуальную схему
- **Реляционная модель** — данные хранятся в таблицах (отношениях)
- **NoSQL** — альтернатива реляционным БД (документоориентированные, ключ-значение, колоночные, графовые)
- **Иерархическая модель** — данные в виде дерева
- **Сетевая модель** — данные в виде графа (устарела)

---

## Контрольные вопросы

1. **Теория:** Объясни, чем отличается БД от файловой системы. Приведи 3 преимущества БД.

2. **Теория:** Опиши трёхуровневую архитектуру ANSI-SPARC. Что такое логическая и физическая независимость данных?

3. **Практика:** Есть таблица `students` с 1 млн записей. Каждая запись занимает 150 байт. Сколько места займут данные? Сколько места займут индексы, если они составляют 25% от данных?

4. **Практика:** Придумай ER-диаграмму для библиотеки (сущности: Книга, Автор, Читатель, Аренда). Преобразуй в таблицы с первичными и внешними ключами.

5. **Теория:** В чём разница между реляционной БД (MySQL) и документоориентированной (MongoDB)? Когда какую лучше использовать?

6. **Практика:** Есть БД с таблицами `users` (10 млн записей × 200 байт), `posts` (50 млн записей × 500 байт), `comments` (200 млн записей × 100 байт). Оцени размер БД с учётом индексов (30% от данных).

7. **Теория:** Что такое СУБД? Какие функции она выполняет (DDL, DML, DCL, TCL)?

---

## Заключение

База данных — это не просто "табличка с данными". Это целая система: от логической структуры (концептуальный уровень) до физического хранения (внутренний уровень), с представлениями для пользователей (внешний уровень). Благодаря трёхуровневой архитектуре можно менять один уровень, не трогая другие — это и есть независимость данных.

Реляционные БД (MySQL, PostgreSQL) — это стандарт де-факто для 90% задач. Но для специфических случаев (Big Data, гибкие схемы, графы) используют NoSQL (MongoDB, Redis, Neo4j).

Следующая глава — **7.3 Реляционные БД. Нормализация** — погрузимся глубже в реляционную модель: что такое нормальные формы, как избежать аномалий, и почему нельзя хранить всё в одной таблице.

---

**Статус:** Глава готова ✅  
**Объём:** ~15000 символов  
**Примеры:** 10 детальных примеров  
**Термины:** 17 ключевых терминов  
**Вопросы:** 7 контрольных вопросов


---

[← К оглавлению](README.md)

*Глава 7.2: . Понятие база данных. Архитектура БД*
