[← К оглавлению](README.md)

---

# [Глава 8.4](08_04_протоколы_internet.md). Протоколы Internet

## Введение: Как пакеты летают по интернету

Окей, дружище, мы уже разобрали, **где** находятся устройства (IP-адреса), **какие** бывают сети (LAN, WAN, GAN) и **как** они соединены (топологии). Но вот вопрос: как, блять, данные **на самом деле** передаются? Как твой браузер понимает, что получил именно ту картинку кота, а не порнуху для соседа?

Всё это работает благодаря **протоколам** — это типа правила игры. Если два компьютера не договорятся о правилах, они не смогут общаться, даже если соединены кабелем толщиной с руку.

**Протокол** — это набор правил, определяющих формат и порядок передачи данных между устройствами.

Эта глава связана с:
- **Главой 8.01 (Адресация)** — IP-адреса, порты, DNS
- **Главой 8.02 (Сетевые компоненты)** — роутеры работают на уровне IP, свитчи — на Ethernet
- **Главой 8.03 (Топологии)** — протоколы работают поверх физической инфраструктуры
- **Главой 8.07 (Модель OSI)** — TCP/IP — это реализация модели OSI
- **Главой 9.02 (Криптография)** — HTTPS, TLS/SSL-шифрование

---

## 8.4.1. Стек протоколов TCP/IP: многослойный пирог

**TCP/IP** — это не один протокол, а **семейство протоколов** (protocol suite), которое управляет интернетом. Название происходит от двух ключевых протоколов: **TCP (Transmission Control Protocol)** и **IP (Internet Protocol)**.

### Четыре уровня стека TCP/IP

Протоколы организованы в **четыре уровня** (слоя). Каждый уровень решает свои задачи и общается только с соседними уровнями.

| Уровень | Название | Что делает | Примеры протоколов |
|---------|----------|------------|-------------------|
| 4 | Прикладной (Application) | Приложения пользователя | HTTP, HTTPS, FTP, SMTP, DNS, SSH |
| 3 | Транспортный (Transport) | Доставка данных между приложениями | TCP, UDP |
| 2 | Сетевой (Network/Internet) | Маршрутизация пакетов между сетями | IP (IPv4, IPv6), ICMP, ARP |
| 1 | Канальный + Физический (Link) | Передача данных по физической среде | Ethernet, Wi-Fi, PPP |

**Аналогия**: Представь, что ты отправляешь посылку через почту:

1. **Прикладной уровень** — ты пишешь письмо (HTTP-запрос)
2. **Транспортный уровень** — кладёшь письмо в конверт с адресом получателя (TCP-сегмент)
3. **Сетевой уровень** — почтальон кладёт конверт в мешок с другими письмами и определяет маршрут (IP-пакет)
4. **Канальный уровень** — мешок грузят в грузовик и везут (Ethernet-кадр)

Каждый уровень добавляет свои **заголовки** (headers), оборачивая данные предыдущего уровня. Это называется **инкапсуляция**.

---

## 8.4.2. IP (Internet Protocol): как пакеты находят дорогу

**IP (Internet Protocol)** — это протокол **сетевого уровня**, отвечающий за **маршрутизацию пакетов** между сетями. Он знает IP-адреса, но не гарантирует доставку.

### Основные функции IP:

1. **Адресация**: каждому устройству присваивается IP-адрес (IPv4 или IPv6)
2. **Маршрутизация**: определение пути от источника к получателю через роутеры
3. **Фрагментация**: разбиение больших пакетов на меньшие, если канал не поддерживает большой размер

### Структура IP-пакета (IPv4)

IP-пакет состоит из **заголовка** (header) и **данных** (payload).

**Заголовок IPv4 (минимум 20 байт)**:

| Поле | Размер | Описание |
|------|--------|----------|
| Version | 4 бита | Версия IP (4 для IPv4) |
| Header Length | 4 бита | Длина заголовка (обычно 20 байт) |
| Type of Service (ToS) | 8 бит | Приоритет пакета (QoS) |
| Total Length | 16 бит | Общая длина пакета (заголовок + данные), макс. 65,535 байт |
| Identification | 16 бит | ID пакета (для сборки фрагментов) |
| Flags | 3 бита | Флаги фрагментации (DF = Don't Fragment, MF = More Fragments) |
| Fragment Offset | 13 бит | Смещение фрагмента |
| Time To Live (TTL) | 8 бит | Максимальное количество прыжков (hops) через роутеры |
| Protocol | 8 бит | Протокол верхнего уровня (6 = TCP, 17 = UDP, 1 = ICMP) |
| Header Checksum | 16 бит | Контрольная сумма заголовка |
| Source IP Address | 32 бита | IP-адрес отправителя |
| Destination IP Address | 32 бита | IP-адрес получателя |
| Options | Переменная | Опции (редко используются) |
| Data | Переменная | Полезная нагрузка (TCP-сегмент, UDP-датаграмма, и т.д.) |

**TTL (Time To Live)** — это счётчик жизни пакета. Каждый роутер уменьшает TTL на 1. Если TTL = 0, пакет **выбрасывается**. Это предотвращает бесконечное блуждание пакетов в случае петли маршрутизации.

**Пример**: Ты пингуешь `google.com` из Москвы. TTL = 64. Пакет проходит через 15 роутеров → TTL становится 49. Ответ приходит обратно.

---

### MTU (Maximum Transmission Unit) и фрагментация

**MTU (Maximum Transmission Unit)** — это максимальный размер пакета, который может быть передан по каналу без фрагментации.

**Типичные значения MTU**:
- **Ethernet**: 1500 байт
- **Wi-Fi**: 2304 байта (но обычно ограничен 1500)
- **PPPoE**: 1492 байта (из-за заголовка PPPoE)
- **Internet**: обычно 1500 байт

**Проблема**: Если пакет больше MTU, его нужно **разбить на фрагменты** (fragmentation).

**Пример**: У тебя пакет размером 3000 байт, а MTU канала = 1500 байт.

1. IP разбивает пакет на **2 фрагмента**:
   - Фрагмент 1: 1500 байт (заголовок 20 байт + данные 1480 байт)
   - Фрагмент 2: 1520 байт (заголовок 20 байт + данные 1500 байт)
   
2. Каждый фрагмент имеет:
   - Одинаковый **Identification** (ID)
   - Флаг **MF (More Fragments)** = 1 для первого, 0 для последнего
   - **Fragment Offset** указывает позицию фрагмента

3. Получатель **собирает фрагменты** обратно в исходный пакет

**Проблема фрагментации**: Если хотя бы **один фрагмент потерян**, весь пакет нужно передавать заново. Поэтому современные протоколы стараются **избегать фрагментации** (используют **Path MTU Discovery**).

---

## 8.4.3. TCP (Transmission Control Protocol): надёжная доставка

**TCP** — это протокол **транспортного уровня**, который обеспечивает **надёжную, упорядоченную доставку** данных.

### Основные характеристики TCP:

✅ **Надёжность**: TCP гарантирует доставку (если пакет потерялся, он будет отправлен повторно)  
✅ **Упорядоченность**: данные приходят в том же порядке, в котором были отправлены  
✅ **Контроль потока**: TCP не перегружает получателя (если получатель медленный, отправитель замедлится)  
✅ **Контроль перегрузки**: TCP замедляет передачу, если сеть перегружена  
❌ **Медленнее UDP**: из-за всех этих проверок TCP медленнее UDP  

### Когда использовать TCP:

- **Веб (HTTP/HTTPS)**: загрузка веб-страниц — важно, чтобы все данные пришли
- **Почта (SMTP, IMAP)**: письма должны доставиться полностью
- **Передача файлов (FTP, SFTP)**: файл должен быть идентичен оригиналу
- **SSH**: удалённое управление — нельзя терять команды

### Структура TCP-сегмента

TCP-сегмент состоит из **заголовка** (минимум 20 байт) и **данных**.

**Заголовок TCP**:

| Поле | Размер | Описание |
|------|--------|----------|
| Source Port | 16 бит | Порт отправителя (например, 12345) |
| Destination Port | 16 бит | Порт получателя (например, 80 для HTTP) |
| Sequence Number | 32 бита | Номер первого байта данных в этом сегменте |
| Acknowledgment Number | 32 бита | Номер следующего ожидаемого байта |
| Data Offset | 4 бита | Длина заголовка (обычно 20 байт) |
| Flags | 9 бит | Флаги: SYN, ACK, FIN, RST, PSH, URG |
| Window Size | 16 бит | Размер окна приёма (для контроля потока) |
| Checksum | 16 бит | Контрольная сумма |
| Urgent Pointer | 16 бит | Указатель на срочные данные |
| Options | Переменная | Опции (MSS, Window Scale) |
| Data | Переменная | Полезная нагрузка (HTTP-запрос, и т.д.) |

---

### Трёхстороннее рукопожатие (Three-Way Handshake)

Перед передачей данных TCP устанавливает **соединение** с помощью **трёхстороннего рукопожатия** (3-way handshake).

**Шаги**:

1. **Клиент → Сервер: SYN**  
   "Привет, сервер! Я хочу с тобой соединиться. Мой начальный Sequence Number = 1000."  
   Флаг **SYN = 1**, Sequence Number = 1000

2. **Сервер → Клиент: SYN-ACK**  
   "Привет, клиент! Я согласен. Мой Sequence Number = 5000. Подтверждаю твой SYN (ACK = 1001)."  
   Флаги **SYN = 1, ACK = 1**, Sequence Number = 5000, Acknowledgment Number = 1001

3. **Клиент → Сервер: ACK**  
   "Отлично, начинаем передачу! Подтверждаю твой SYN (ACK = 5001)."  
   Флаг **ACK = 1**, Acknowledgment Number = 5001

**Готово!** Соединение установлено, можно передавать данные.

**Зачем это нужно?**
- Синхронизация Sequence Numbers (чтобы понимать порядок пакетов)
- Проверка, что сервер жив и готов принимать данные
- Согласование параметров (например, MSS — Maximum Segment Size)

**Время установки соединения**: Трёхстороннее рукопожатие занимает **1.5 × RTT (Round-Trip Time)**, где RTT — время туда и обратно.

**Пример**: Клиент в Москве, сервер в Калифорнии. RTT = 150 мс.  
Время установки TCP-соединения = 1.5 × 150 = **225 мс**.  
Это **прежде чем** начать передавать данные!

---

### Завершение соединения (FIN)

Когда данные переданы, TCP **закрывает соединение** с помощью флага **FIN**.

**Шаги**:

1. **Клиент → Сервер: FIN**  
   "Я закончил, больше данных не будет."

2. **Сервер → Клиент: ACK**  
   "Понял, подтверждаю."

3. **Сервер → Клиент: FIN**  
   "Я тоже закончил."

4. **Клиент → Сервер: ACK**  
   "Окей, закрываю соединение."

**Готово!** Соединение закрыто.

---

### Повторная передача (Retransmission)

Если сегмент **потерялся** (не пришёл ACK), TCP **отправляет его повторно**.

**Пример**:

1. Клиент отправляет сегмент с Sequence Number = 1000
2. Ждёт ACK = 1001
3. Если ACK не пришёл через **timeout** (обычно ~200 мс), сегмент отправляется повторно
4. Повторяется несколько раз (обычно до 5-7 попыток)
5. Если всё равно не удалось → **соединение разрывается**

**Вывод**: TCP — это как перфекционист с ОКР. Он будет пиздить пакет снова и снова, пока тот не дойдёт.

---

## 8.4.4. UDP (User Datagram Protocol): быстро и без гарантий

**UDP** — это протокол **транспортного уровня**, который обеспечивает **быструю, но ненадёжную доставку** данных.

### Основные характеристики UDP:

✅ **Скорость**: UDP быстрее TCP (нет установки соединения, нет подтверждений)  
✅ **Простота**: заголовок всего 8 байт (у TCP — минимум 20)  
❌ **Ненадёжность**: UDP не гарантирует доставку (пакет может потеряться)  
❌ **Не упорядоченность**: пакеты могут прийти в другом порядке  

### Когда использовать UDP:

- **Видео/аудио стриминг**: потеря 1-2% пакетов незаметна, важнее скорость
- **Онлайн-игры**: важна низкая задержка (лучше потерять пакет, чем ждать повторной передачи)
- **DNS**: запросы короткие, проще отправить повторно, чем возиться с TCP
- **VoIP (звонки)**: задержка критична, небольшие потери допустимы
- **IoT-датчики**: отправка данных каждую секунду (если один пакет потерялся, придёт следующий)

### Структура UDP-датаграммы

**Заголовок UDP (8 байт)**:

| Поле | Размер | Описание |
|------|--------|----------|
| Source Port | 16 бит | Порт отправителя |
| Destination Port | 16 бит | Порт получателя |
| Length | 16 бит | Длина датаграммы (заголовок + данные) |
| Checksum | 16 бит | Контрольная сумма (опционально) |
| Data | Переменная | Полезная нагрузка |

**Сравнение размеров заголовков**:
- **TCP**: минимум 20 байт
- **UDP**: 8 байт
- **IP**: 20 байт (IPv4)

**Пример**: Отправка 100 байт данных:
- **TCP**: 20 (TCP) + 20 (IP) + 100 (данные) = **140 байт**
- **UDP**: 8 (UDP) + 20 (IP) + 100 (данные) = **128 байт**

**Экономия**: 8.6% меньше служебной информации.

---

### TCP vs UDP: когда что использовать?

| Критерий | TCP | UDP |
|----------|-----|-----|
| Надёжность | ✅ Гарантирует доставку | ❌ Может потерять пакеты |
| Скорость | ❌ Медленнее | ✅ Быстрее |
| Установка соединения | ❌ Требует (3-way handshake) | ✅ Не требует |
| Упорядоченность | ✅ Пакеты в порядке | ❌ Могут прийти вразнобой |
| Контроль потока | ✅ Есть | ❌ Нет |
| Размер заголовка | 20+ байт | 8 байт |
| Примеры | HTTP, HTTPS, FTP, SSH, SMTP | DNS, VoIP, стриминг, игры |

**Золотое правило**:
- **Важна надёжность** (файлы, веб, почта) → **TCP**
- **Важна скорость** (видео, игры, звонки) → **UDP**

---

## 8.4.5. Порты и сокеты: как различать приложения

**Порт** — это 16-битное число (от 0 до 65535), которое указывает, **какое приложение** должно получить данные.

### Зачем нужны порты?

IP-адрес указывает на **компьютер**, но на одном компьютере может работать **куча приложений** (браузер, Skype, Steam, торрент-клиент). Порт указывает, **какому приложению** предназначены данные.

**Аналогия**: IP-адрес — это адрес дома, а порт — это номер квартиры.

### Диапазоны портов

| Диапазон | Название | Описание |
|----------|----------|----------|
| 0–1023 | Well-Known Ports | Зарезервированы для стандартных сервисов (HTTP, FTP, SSH) |
| 1024–49151 | Registered Ports | Зарегистрированы для приложений (MySQL, PostgreSQL) |
| 49152–65535 | Dynamic/Ephemeral Ports | Временные порты для клиентов |

### Популярные порты (выучи наизусть!)

| Протокол | Порт | Транспорт | Описание |
|----------|------|-----------|----------|
| **HTTP** | 80 | TCP | Веб-сервер (незащищённый) |
| **HTTPS** | 443 | TCP | Веб-сервер (с шифрованием TLS/SSL) |
| **FTP** | 21 | TCP | Передача файлов (команды) |
| **FTP Data** | 20 | TCP | Передача файлов (данные) |
| **SSH** | 22 | TCP | Удалённое управление (безопасное) |
| **Telnet** | 23 | TCP | Удалённое управление (небезопасное, устарело) |
| **SMTP** | 25 | TCP | Отправка почты |
| **DNS** | 53 | UDP/TCP | Разрешение доменных имён |
| **DHCP Server** | 67 | UDP | Выдача IP-адресов |
| **DHCP Client** | 68 | UDP | Получение IP-адреса |
| **TFTP** | 69 | UDP | Простая передача файлов |
| **POP3** | 110 | TCP | Получение почты (скачивание) |
| **IMAP** | 143 | TCP | Получение почты (доступ к серверу) |
| **SNMP** | 161 | UDP | Мониторинг сетевых устройств |
| **HTTPS (alt)** | 8080, 8443 | TCP | Альтернативные порты для веб |
| **MySQL** | 3306 | TCP | База данных |
| **PostgreSQL** | 5432 | TCP | База данных |
| **RDP** | 3389 | TCP | Удалённый рабочий стол Windows |
| **Minecraft** | 25565 | TCP | Игровой сервер |

**Пример**: Ты открываешь `https://google.com` в браузере.

1. Браузер отправляет **TCP-сегмент** на порт **443** (HTTPS)
2. IP-пакет идёт на IP-адрес Google (`142.250.186.46`)
3. Сервер Google слушает порт 443 → принимает соединение
4. Браузер отправляет HTTP-запрос: `GET / HTTP/1.1`
5. Сервер отвечает HTML-страницей

### Сокет (Socket)

**Сокет** — это комбинация **IP-адреса + порт**.

**Формат**: `IP:порт`

**Примеры**:
- `192.168.1.1:80` — веб-сервер в локальной сети
- `8.8.8.8:53` — DNS-сервер Google
- `142.250.186.46:443` — HTTPS-сервер Google

**Уникальное соединение** определяется **парой сокетов**:
- **Клиент**: `192.168.1.100:54321` (клиент выбирает **случайный** порт из диапазона 49152-65535)
- **Сервер**: `142.250.186.46:443`

Это позволяет одному клиенту иметь **несколько одновременных соединений** к одному серверу (например, 10 вкладок браузера к Google).

---

## 8.4.6. Протоколы прикладного уровня: что делают приложения

**Прикладной уровень** — это самый верхний уровень стека TCP/IP. Здесь работают протоколы, с которыми взаимодействуют пользователи и приложения.

---

### HTTP (HyperText Transfer Protocol) — протокол веба

**HTTP** — это протокол передачи гипертекста, используемый для загрузки веб-страниц.

**Характеристики**:
- **Порт**: 80
- **Транспорт**: TCP
- **Режим**: запрос-ответ (клиент отправляет запрос → сервер отвечает)

**Методы HTTP** (самые важные):

| Метод | Описание | Пример |
|-------|----------|--------|
| **GET** | Получить ресурс | `GET /index.html` — загрузить главную страницу |
| **POST** | Отправить данные | Отправка формы (логин, пароль) |
| **PUT** | Обновить ресурс | Загрузить файл на сервер |
| **DELETE** | Удалить ресурс | Удалить файл |
| **HEAD** | Получить только заголовки | Проверить, изменился ли файл |

**Пример HTTP-запроса**:

```
GET /search?q=tcp HTTP/1.1
Host: google.com
User-Agent: Mozilla/5.0
Accept: text/html
```

**Расшифровка**:
- `GET /search?q=tcp` — получить страницу поиска с запросом "tcp"
- `HTTP/1.1` — версия протокола
- `Host: google.com` — доменное имя (обязательно!)
- `User-Agent` — информация о браузере
- `Accept` — какие типы данных клиент понимает

**Пример HTTP-ответа**:

```
HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 1234

<html>
<body>Результаты поиска...</body>
</html>
```

**Расшифровка**:
- `HTTP/1.1 200 OK` — статус ответа (200 = успешно)
- `Content-Type: text/html` — тип данных (HTML)
- `Content-Length: 1234` — размер ответа (1234 байта)
- Пустая строка, затем **тело ответа** (HTML-код)

**Статус-коды HTTP** (выучи наизусть!):

| Код | Описание | Пример |
|-----|----------|--------|
| **200 OK** | Успешно | Страница загрузилась |
| **301 Moved Permanently** | Редирект (постоянный) | Сайт переехал на новый домен |
| **302 Found** | Редирект (временный) | Временная страница |
| **400 Bad Request** | Ошибка в запросе | Неправильный синтаксис |
| **401 Unauthorized** | Требуется авторизация | Нужен логин/пароль |
| **403 Forbidden** | Доступ запрещён | У тебя нет прав |
| **404 Not Found** | Страница не найдена | Битая ссылка |
| **500 Internal Server Error** | Ошибка сервера | Баг в коде сервера |
| **502 Bad Gateway** | Шлюз не отвечает | Сервер за прокси недоступен |
| **503 Service Unavailable** | Сервис недоступен | Перегрузка сервера |

**Проблема HTTP**: Данные передаются **в открытом виде** (без шифрования). Любой, кто перехватит трафик, увидит всё (пароли, личные данные).

---

### HTTPS (HTTP Secure) — безопасный HTTP

**HTTPS** — это HTTP поверх **TLS/SSL** (Transport Layer Security / Secure Sockets Layer).

**Характеристики**:
- **Порт**: 443
- **Транспорт**: TCP
- **Шифрование**: TLS 1.2 / TLS 1.3

**Что делает HTTPS**:
1. **Шифрование**: данные зашифрованы (перехватчик увидит только мусор)
2. **Аутентификация**: проверка, что сервер действительно тот, за кого себя выдаёт (SSL-сертификат)
3. **Целостность**: данные не были изменены по пути

**Процесс установки HTTPS-соединения** (TLS Handshake):

1. **Клиент → Сервер: ClientHello**  
   "Привет! Вот список алгоритмов шифрования, которые я поддерживаю."

2. **Сервер → Клиент: ServerHello + Сертификат**  
   "Привет! Я выбрал алгоритм AES-256. Вот мой SSL-сертификат (подтверждает, что я настоящий google.com)."

3. **Клиент проверяет сертификат**  
   "Сертификат подписан доверенным центром (CA)? Да? Окей, тебе можно верить."

4. **Обмен ключами** (Diffie-Hellman или RSA)  
   Клиент и сервер договариваются о **сеансовом ключе** (session key) для шифрования.

5. **Готово!** Дальше весь трафик шифруется этим ключом.

**Время установки HTTPS-соединения**: Больше, чем HTTP (из-за TLS Handshake). Обычно **+1-2 RTT**.

**Пример**: RTT = 100 мс.  
- HTTP: TCP handshake (150 мс) + HTTP-запрос (100 мс) = **250 мс**  
- HTTPS: TCP handshake (150 мс) + TLS handshake (200 мс) + HTTP-запрос (100 мс) = **450 мс**

**Вывод**: HTTPS медленнее, но **безопаснее**. Сейчас почти все сайты используют HTTPS (Google даже наказывает HTTP-сайты в поиске).

---

### FTP (File Transfer Protocol) — передача файлов

**FTP** — это протокол для передачи файлов между клиентом и сервером.

**Характеристики**:
- **Порт**: 21 (команды), 20 (данные)
- **Транспорт**: TCP
- **Проблема**: Данные передаются **в открытом виде** (логин, пароль, файлы)

**Два канала**:
1. **Командный канал** (порт 21): отправка команд (`LIST`, `RETR`, `STOR`)
2. **Канал данных** (порт 20): передача файлов

**Режимы FTP**:
- **Active mode**: сервер подключается к клиенту (проблемы с NAT и фаерволами)
- **Passive mode**: клиент подключается к серверу (работает везде)

**Альтернативы FTP**:
- **SFTP (SSH File Transfer Protocol)**: передача файлов поверх SSH (шифрование)
- **FTPS (FTP Secure)**: FTP поверх TLS/SSL (аналог HTTPS)

**Вердикт**: Обычный FTP — устарел и небезопасен. Используй **SFTP**.

---

### SMTP, POP3, IMAP — протоколы почты

#### SMTP (Simple Mail Transfer Protocol) — отправка почты

**SMTP** — это протокол для **отправки** почты от клиента к серверу или между серверами.

**Характеристики**:
- **Порт**: 25 (между серверами), 587 (от клиента к серверу, с аутентификацией)
- **Транспорт**: TCP

**Пример SMTP-сессии**:

```
HELO mail.example.com
MAIL FROM:<sender@example.com>
RCPT TO:<recipient@example.com>
DATA
Subject: Hello!

This is the email body.
.
QUIT
```

**Проблема SMTP**: Не поддерживает шифрование (изначально). Сейчас используют **STARTTLS** (шифрование поверх SMTP).

---

#### POP3 (Post Office Protocol v3) — получение почты (скачивание)

**POP3** — это протокол для **скачивания** почты с сервера на клиент.

**Характеристики**:
- **Порт**: 110 (незащищённый), 995 (с TLS)
- **Транспорт**: TCP

**Как работает**:
1. Клиент подключается к серверу
2. Скачивает все письма
3. **Удаляет их с сервера** (обычно)

**Проблема**: Письма удаляются с сервера → если ты проверяешь почту с двух устройств (компьютер + телефон), письма будут только на одном.

---

#### IMAP (Internet Message Access Protocol) — получение почты (доступ к серверу)

**IMAP** — это протокол для **работы с почтой на сервере** (письма остаются на сервере).

**Характеристики**:
- **Порт**: 143 (незащищённый), 993 (с TLS)
- **Транспорт**: TCP

**Как работает**:
1. Клиент подключается к серверу
2. **Синхронизирует** письма (скачивает заголовки, но не тела писем)
3. Письма остаются на сервере

**Плюсы**:
- Можно работать с почтой с любого устройства (синхронизация)
- Экономия места (письма на сервере)

**Минусы**:
- Требует постоянного подключения к интернету

**Вердикт**: Сейчас почти все используют **IMAP** (Gmail, Outlook, и т.д.).

---

### SSH (Secure Shell) — удалённое управление

**SSH** — это протокол для **безопасного удалённого доступа** к серверу.

**Характеристики**:
- **Порт**: 22
- **Транспорт**: TCP
- **Шифрование**: Всё шифруется (команды, пароли, данные)

**Что можно делать через SSH**:
- Подключиться к серверу и выполнять команды (`ssh user@server`)
- Передавать файлы (`scp`, `sftp`)
- Пробрасывать порты (SSH tunneling)
- Запускать X11-приложения удалённо

**Пример**:

```bash
ssh admin@192.168.1.1
```

Ты вводишь пароль (или используешь SSH-ключ) → подключаешься к серверу → можешь выполнять команды.

**Вердикт**: SSH — **стандарт** для удалённого управления Linux/Unix-серверами.

---

### Telnet — устаревший SSH

**Telnet** — это протокол для удалённого доступа, но **без шифрования**.

**Характеристики**:
- **Порт**: 23
- **Транспорт**: TCP
- **Проблема**: Всё передаётся **в открытом виде** (пароли, команды)

**Вердикт**: **НЕ ИСПОЛЬЗУЙ TELNET**. Он устарел ещё в 1990-х. Используй SSH.

---

### DNS (Domain Name System) — уже разбирали в [главе 8.01](08_01_адресация_internet.md)

**DNS** — это протокол для преобразования доменных имён в IP-адреса.

**Характеристики**:
- **Порт**: 53
- **Транспорт**: **UDP** (для коротких запросов), **TCP** (для длинных ответов или зонного трансфера)

**Почему UDP?**  
DNS-запросы **короткие** (обычно <512 байт), поэтому проще использовать UDP (не нужно устанавливать соединение). Если ответ не пришёл → клиент повторяет запрос.

---

## 8.4.7. Инкапсуляция: как пакет оборачивается слоями

**Инкапсуляция** — это процесс оборачивания данных заголовками на каждом уровне стека.

**Пример**: Ты отправляешь HTTP-запрос `GET /index.html`.

1. **Прикладной уровень (HTTP)**: Создаётся HTTP-запрос (текст):
   ```
   GET /index.html HTTP/1.1
   Host: example.com
   ```

2. **Транспортный уровень (TCP)**: HTTP-запрос оборачивается в **TCP-сегмент**:
   - Добавляются порты (Source: 54321, Destination: 80)
   - Добавляются Sequence Number, ACK, флаги

3. **Сетевой уровень (IP)**: TCP-сегмент оборачивается в **IP-пакет**:
   - Добавляются IP-адреса (Source: 192.168.1.100, Destination: 93.184.216.34)
   - Добавляются TTL, Protocol (6 = TCP)

4. **Канальный уровень (Ethernet)**: IP-пакет оборачивается в **Ethernet-кадр**:
   - Добавляются MAC-адреса (Source: твоя сетевая карта, Destination: роутер)
   - Добавляется контрольная сумма (CRC)

5. **Физический уровень**: Кадр преобразуется в **электрические сигналы** (или световые импульсы для оптоволокна) и передаётся по кабелю.

**На приёмной стороне** происходит **декапсуляция** (обратный процесс): снимаются заголовки слой за слоем.

---

### Размер пакета: сколько служебной информации?

**Пример**: Ты отправляешь 100 байт данных через HTTP.

| Уровень | Заголовок | Размер |
|---------|-----------|--------|
| HTTP | `GET / HTTP/1.1\r\nHost: example.com\r\n\r\n` | ~35 байт |
| TCP | Source/Dest Port, Seq, ACK, Flags, Window | 20 байт |
| IP | Source/Dest IP, TTL, Protocol | 20 байт |
| Ethernet | Source/Dest MAC, Type, CRC | 18 байт |

**Итого**: 35 (HTTP) + 20 (TCP) + 20 (IP) + 18 (Ethernet) = **93 байта** заголовков!

Если полезные данные = 100 байт, то **общий размер пакета** = 193 байта.

**Эффективность** = 100 / 193 ≈ **52%**. Почти **половина трафика** — это заголовки!

**Вывод**: Для коротких сообщений (например, ping) эффективность **очень низкая**. Для больших файлов (гигабайты) заголовки — это **ничто** (<1%).

---

## 8.4.8. Примеры задач и расчётов

### Пример 1: Время установки TCP-соединения

**Задача**: Клиент в Москве подключается к серверу в Нью-Йорке. RTT (Round-Trip Time) = 120 мс. Сколько времени займёт установка TCP-соединения?

**Решение**:

TCP использует **трёхстороннее рукопожатие**:
1. Клиент → Сервер: SYN (**0.5 RTT**)
2. Сервер → Клиент: SYN-ACK (**1 RTT**)
3. Клиент → Сервер: ACK (**1.5 RTT**)

После третьего шага клиент может начать отправлять данные.

**Время установки соединения** = **1.5 × RTT** = 1.5 × 120 = **180 мс**.

**Ответ**: 180 мс.

---

### Пример 2: Размер TCP-пакета с данными

**Задача**: Клиент отправляет 500 байт данных через TCP/IP. Рассчитай общий размер IP-пакета.

**Решение**:

- **Данные**: 500 байт
- **TCP-заголовок**: 20 байт (минимум)
- **IP-заголовок**: 20 байт (IPv4)

**Общий размер IP-пакета** = 500 + 20 + 20 = **540 байт**.

**Ответ**: 540 байт.

---

### Пример 3: Фрагментация пакета

**Задача**: Приложение отправляет 3000 байт данных через TCP/IP. MTU канала = 1500 байт. На сколько IP-пакетов будет разбито сообщение?

**Решение**:

1. **Размер TCP-сегмента** = 3000 (данные) + 20 (TCP-заголовок) = **3020 байт**

2. **Размер IP-пакета (без фрагментации)** = 3020 + 20 (IP-заголовок) = **3040 байт**

3. **MTU = 1500 байт** → пакет нужно фрагментировать.

4. **Полезная нагрузка на фрагмент** = MTU - IP-заголовок = 1500 - 20 = **1480 байт**

5. **Количество фрагментов**:
   - Фрагмент 1: 1480 байт
   - Фрагмент 2: 1480 байт
   - Фрагмент 3: 3020 - 1480 - 1480 = **60 байт**

**Ответ**: **3 IP-пакета** (фрагмента).

---

### Пример 4: Сравнение TCP и UDP (накладные расходы)

**Задача**: Нужно отправить 10 сообщений по 100 байт каждое. Сравни общий объём трафика для TCP и UDP.

**Решение**:

**UDP**:
- Заголовок UDP: 8 байт
- Заголовок IP: 20 байт
- Размер одного пакета: 100 + 8 + 20 = **128 байт**
- Всего: 10 × 128 = **1280 байт**

**TCP**:
- Заголовок TCP: 20 байт
- Заголовок IP: 20 байт
- Размер одного сегмента: 100 + 20 + 20 = **140 байт**
- Всего: 10 × 140 = **1400 байт**

**Плюс** TCP требует:
- Установку соединения: 3 пакета (SYN, SYN-ACK, ACK) ≈ 120 байт
- Закрытие соединения: 4 пакета (FIN, ACK, FIN, ACK) ≈ 160 байт

**Итого TCP**: 1400 + 120 + 280 = **1680 байт**  
**Итого UDP**: **1280 байт**

**Вывод**: UDP на **31% эффективнее** для коротких сообщений.

---

### Пример 5: HTTP-запрос и ответ

**Задача**: Клиент запрашивает файл размером 10 КБ через HTTP. RTT = 50 мс. Сколько времени займёт загрузка (без учёта DNS и других факторов)?

**Решение**:

1. **Установка TCP-соединения**: 1.5 × RTT = 1.5 × 50 = **75 мс**

2. **HTTP-запрос** (клиент → сервер): 0.5 × RTT = **25 мс**

3. **HTTP-ответ** (сервер → клиент): 0.5 × RTT + время передачи данных

   **Время передачи данных** зависит от скорости канала. Предположим канал = 1 Мбит/с.
   
   \[
   t = \frac{10 \text{ КБ}}{1 \text{ Мбит/с}} = \frac{10 \times 8 \text{ Кбит}}{1000 \text{ Кбит/с}} = 0.08 \text{ с} = 80 \text{ мс}
   \]
   
   Итого для ответа: 25 + 80 = **105 мс**

**Общее время**: 75 + 25 + 105 = **205 мс**

**Ответ**: **~205 мс**.

---

### Пример 6: Количество портов на сервере

**Задача**: Веб-сервер обрабатывает 10,000 одновременных подключений от разных клиентов. Все подключения идут на порт 443 (HTTPS). Сколько портов использует сервер?

**Решение**:

**Один порт**: 443.

**Но как сервер различает 10,000 соединений?**  
Каждое соединение уникально идентифицируется **парой сокетов**:
- Клиент 1: `192.168.1.100:54321` ↔ Сервер: `203.0.113.1:443`
- Клиент 2: `192.168.1.100:54322` ↔ Сервер: `203.0.113.1:443`
- ...

Сервер использует **один порт** (443), но операционная система создаёт **отдельный сокет** для каждого соединения (с уникальной комбинацией IP клиента + порт клиента).

**Ответ**: Сервер использует **1 порт** (443), но обрабатывает 10,000 соединений.

---

### Пример 7: TTL и максимальное расстояние

**Задача**: Пакет отправлен с TTL = 64. Каждый роутер уменьшает TTL на 1. Через сколько максимум роутеров может пройти пакет?

**Решение**:

TTL = 64 → пакет может пройти через **64 роутера** (после 64-го TTL станет 0, и пакет будет выброшен).

**Но**: обычно между двумя точками в интернете **10-30 роутеров**. TTL = 64 достаточно для большинства маршрутов.

**Ответ**: **64 роутера**.

---

### Пример 8: Полоса пропускания для видеостриминга

**Задача**: YouTube-видео требует 5 Мбит/с. Используется UDP. Сколько UDP-пакетов в секунду нужно передать, если каждый пакет содержит 1000 байт данных?

**Решение**:

1. **Полезная нагрузка** = 1000 байт = 8000 бит

2. **Пакетов в секунду**:
   \[
   \frac{5 \text{ Мбит/с}}{8000 \text{ бит}} = \frac{5000000}{8000} = 625 \text{ пакетов/с}
   \]

**Ответ**: **625 пакетов в секунду**.

---

### Пример 9: Сравнение HTTP и HTTPS (задержка)

**Задача**: RTT = 80 мс. Сравни время загрузки одного файла (без учёта передачи данных) через HTTP и HTTPS.

**Решение**:

**HTTP**:
- TCP handshake: 1.5 × RTT = 120 мс
- HTTP-запрос: 0.5 × RTT = 40 мс
- **Итого**: **160 мс**

**HTTPS**:
- TCP handshake: 1.5 × RTT = 120 мс
- TLS handshake: 2 × RTT = 160 мс (упрощённо)
- HTTP-запрос: 0.5 × RTT = 40 мс
- **Итого**: **320 мс**

**Вывод**: HTTPS **в 2 раза медленнее** для первого запроса. Но зато **безопаснее**.

**Оптимизация**: TLS 1.3 сократил TLS handshake до **1 RTT** → HTTPS стало быстрее.

---

### Пример 10: Максимальная скорость TCP (Window Size)

**Задача**: TCP Window Size = 65,535 байт (максимум без расширений). RTT = 100 мс. Какова максимальная скорость передачи?

**Решение**:

**Максимальная скорость** (без Window Scaling):
\[
\text{Скорость} = \frac{\text{Window Size}}{\text{RTT}} = \frac{65535 \text{ байт}}{0.1 \text{ с}} = 655350 \text{ байт/с} \approx 5.2 \text{ Мбит/с}
\]

**Вывод**: Без **Window Scaling** TCP не может передавать быстрее **~5 Мбит/с** на каналах с RTT = 100 мс.

**Решение**: TCP Window Scaling (опция TCP) позволяет увеличить Window Size до **1 ГБ** → скорость до **80 Гбит/с** на RTT = 100 мс.

**Ответ**: **~5 Мбит/с** (без Window Scaling).

---

## Ключевые термины и определения

**Протокол** — набор правил для обмена данными между устройствами.

**TCP/IP** — семейство протоколов, управляющих интернетом.

**TCP (Transmission Control Protocol)** — протокол транспортного уровня, обеспечивающий надёжную, упорядоченную доставку данных.

**UDP (User Datagram Protocol)** — протокол транспортного уровня, обеспечивающий быструю, но ненадёжную доставку данных.

**IP (Internet Protocol)** — протокол сетевого уровня, отвечающий за маршрутизацию пакетов.

**Трёхстороннее рукопожатие (3-Way Handshake)** — процесс установки TCP-соединения (SYN, SYN-ACK, ACK).

**Порт** — 16-битное число (0-65535), указывающее на приложение на устройстве.

**Сокет (Socket)** — комбинация IP-адреса и порта (например, `192.168.1.1:80`).

**HTTP (HyperText Transfer Protocol)** — протокол передачи гипертекста (веб-страниц).

**HTTPS (HTTP Secure)** — HTTP поверх TLS/SSL (с шифрованием).

**FTP (File Transfer Protocol)** — протокол передачи файлов.

**SMTP (Simple Mail Transfer Protocol)** — протокол отправки почты.

**POP3 (Post Office Protocol v3)** — протокол получения почты (скачивание).

**IMAP (Internet Message Access Protocol)** — протокол работы с почтой на сервере.

**SSH (Secure Shell)** — протокол безопасного удалённого доступа.

**DNS (Domain Name System)** — система преобразования доменных имён в IP-адреса.

**MTU (Maximum Transmission Unit)** — максимальный размер пакета, передаваемого без фрагментации (обычно 1500 байт).

**Фрагментация** — разбиение больших пакетов на меньшие.

**TTL (Time To Live)** — счётчик жизни IP-пакета (количество роутеров, через которые может пройти пакет).

**RTT (Round-Trip Time)** — время туда и обратно (задержка).

**Инкапсуляция** — оборачивание данных заголовками на каждом уровне стека.

**Декапсуляция** — снятие заголовков на приёмной стороне.

**TLS/SSL (Transport Layer Security / Secure Sockets Layer)** — протоколы шифрования для HTTPS.

**Window Size** — размер буфера приёма TCP (для контроля потока).

---

## Контрольные вопросы

1. **Теория**: В чём разница между TCP и UDP? Приведи примеры, когда использовать каждый.

2. **Теория**: Объясни, как работает трёхстороннее рукопожатие TCP (3-Way Handshake). Зачем оно нужно?

3. **Расчёт**: Клиент в Санкт-Петербурге подключается к серверу в Токио. RTT = 200 мс. Сколько времени займёт установка TCP-соединения?

4. **Теория**: Что такое порт? Назови 5 стандартных портов (HTTP, HTTPS, SSH, FTP, DNS) и их номера.

5. **Расчёт**: Приложение отправляет 800 байт данных через TCP/IP (IPv4). Рассчитай общий размер IP-пакета (с учётом всех заголовков).

6. **Теория**: Что такое MTU? Что происходит, если размер пакета превышает MTU канала?

7. **Практика**: Ты заходишь на сайт `https://example.com`. Опиши пошагово, какие протоколы используются (DNS, TCP, TLS, HTTP).

8. **Расчёт**: Канал пропускает 10 Мбит/с. Ты отправляешь UDP-пакеты размером 1000 байт данных (+ заголовки UDP 8 байт + IP 20 байт). Сколько пакетов в секунду можно передать?

9. **Теория**: В чём разница между HTTP и HTTPS? Почему HTTPS медленнее?

10. **Критическое мышление**: Почему онлайн-игры используют UDP, а не TCP? Какие минусы UDP приходится компенсировать в игровом коде?

---

## Заключение: Протоколы — это язык интернета

Теперь ты знаешь:
- **TCP/IP стек**: 4 уровня (Application, Transport, Network, Link)
- **TCP**: надёжный, медленный, для файлов и веба
- **UDP**: быстрый, ненадёжный, для видео и игр
- **Порты**: как приложения различают трафик
- **HTTP/HTTPS**: как работает веб
- **Инкапсуляция**: как пакет оборачивается слоями заголовков

Без протоколов интернет — это просто куча кабелей и роутеров. Протоколы — это **правила игры**, которые позволяют миллиардам устройств общаться друг с другом.

В следующей главе разберём **сервисы Internet** (WWW, email, FTP, облачные сервисы) — то, **что** конкретно делают эти протоколы для пользователей.

А пока — **поздравляю, чувак**! Ты разобрался в TCP, UDP, портах и HTTP. Это **основа основ** сетевых технологий. Теперь можешь пойти и рассказать друзьям, почему их CS:GO лагает (спойлер: потому что пакеты теряются, а UDP не умеет их пересылать). 🎉🚀


---

[← К оглавлению](README.md)

*Глава 8.4: . Протоколы Internet*
