# Глава 1.2: Представление данных в памяти ЭВМ

## Введение

В предыдущей главе мы рассмотрели арифметику в двоичной системе счисления — фундаментальную основу работы с данными в компьютерах. Теперь настало время разобраться, как эти двоичные числа и другие типы информации физически организованы и хранятся в оперативной памяти электронно-вычислительных машин.

Понимание организации памяти критически важно для любого специалиста в области информационных технологий. Это знание позволяет не только эффективно программировать, но и понимать принципы работы операционных систем, баз данных, сетевых протоколов. Кроме того, представление данных напрямую влияет на производительность программ, размер занимаемой памяти и возможности по обработке информации.

Данная глава тесно связана с темами архитектуры ЭВМ (глава 2.1), представления числовых данных (глава 1.9), а также с темами представления символьных, графических и звуковых данных (главы 1.4, 1.8, 1.3). Здесь мы заложим общие принципы, которые будут детализированы в последующих разделах.

## Иерархическая структура памяти ЭВМ

### Понятие оперативной памяти

**Оперативная память** (ОЗУ — оперативное запоминающее устройство, англ. RAM — Random Access Memory) представляет собой быстродействующую энергозависимую память компьютера, предназначенную для временного хранения данных и программ в процессе их выполнения. Основное свойство оперативной памяти — возможность прямого доступа к любой ячейке за одинаковое время, независимо от её расположения.

Память организована как линейная последовательность **ячеек**, каждая из которых имеет уникальный **адрес**. Эта организация похожа на многоэтажный дом, где каждая квартира имеет свой номер, по которому можно однозначно её идентифицировать.

### Минимальная адресуемая единица: байт

Исторически сложилось, что минимальной адресуемой единицей памяти в современных компьютерах является **байт** (англ. byte) — группа из 8 бит. Это означает, что каждый байт памяти имеет свой уникальный адрес, и процессор может обращаться к памяти с точностью до байта.

**Почему именно 8 бит?** Это исторический стандарт, обусловленный тем, что 8 бит достаточно для представления одного символа в большинстве систем кодирования (например, ASCII использует 7 бит, расширенные кодировки — 8 бит).

```
Байт (8 бит):  [b₇][b₆][b₅][b₄][b₃][b₂][b₁][b₀]
                 ↑                             ↑
            старший бит               младший бит
                (MSB)                      (LSB)
```

Один байт может представлять:
- Целое число без знака от 0 до 255 (2⁸ = 256 значений)
- Целое число со знаком от -128 до +127
- Один символ в кодировке ASCII или Latin-1
- Часть более сложного типа данных

### Более крупные единицы: слово, двойное слово, четверное слово

Для эффективной работы процессоры обычно оперируют более крупными порциями данных:

**Слово** (англ. word) — базовая единица данных, обрабатываемая процессором за одну операцию. Размер слова зависит от архитектуры:
- 16-разрядные системы: слово = 2 байта = 16 бит
- 32-разрядные системы: слово = 4 байта = 32 бита
- 64-разрядные системы: слово = 8 байт = 64 бита

**Двойное слово** (англ. double word, dword) — удвоенный размер базового слова:
- В 16-разрядных системах: 4 байта
- В 32-разрядных системах: 8 байт

**Четверное слово** (англ. quad word, qword) — учетверенный размер:
- В 32-разрядных системах: 16 байт
- В 64-разрядных системах: 32 байта

**Важно**: в современной литературе термин "слово" часто используется для обозначения 2-байтной величины (16 бит), а "двойное слово" — для 4 байт (32 бита), независимо от разрядности процессора.

## Адресация памяти

### Понятие адреса

**Адрес** — это целое неотрицательное число, однозначно идентифицирующее конкретную ячейку (байт) в оперативной памяти. Адресация начинается с нуля: первый байт имеет адрес 0, второй — адрес 1, и так далее.

Размер адресного пространства определяется разрядностью адресной шины процессора:
- 16-разрядная шина: 2¹⁶ = 65 536 адресов = 64 КБ
- 32-разрядная шина: 2³² = 4 294 967 296 адресов = 4 ГБ
- 64-разрядная шина: 2⁶⁴ ≈ 18,4 эксабайта (теоретически)

### Порядок байтов: Little Endian и Big Endian

При хранении многобайтовых данных (например, 32-битного целого числа) возникает вопрос: в каком порядке располагать байты в памяти? Существуют два основных подхода:

**Little Endian** (младший байт первым):
- Младший байт располагается по младшему адресу
- Используется в архитектурах x86, x86-64 (процессоры Intel, AMD)

**Big Endian** (старший байт первым):
- Старший байт располагается по младшему адресу
- Используется в некоторых архитектурах (например, классические SPARC, PowerPC в режиме big endian)
- Соответствует естественной записи чисел (слева направо, от старшего к младшему)

### Пример 1: Представление числа в памяти

**Задача**: Рассмотрим 32-битное целое число 0x12345678 (в шестнадцатеричной системе). Как оно будет храниться в памяти, начиная с адреса 1000, в форматах Little Endian и Big Endian?

**Решение**:

Представим число побайтово:
- Байт 3 (старший): 0x12
- Байт 2: 0x34
- Байт 1: 0x56
- Байт 0 (младший): 0x78

**Little Endian** (x86):
```
Адрес:  1000  1001  1002  1003
Байты:  0x78  0x56  0x34  0x12
         ↑                   ↑
    младший              старший
```

**Big Endian**:
```
Адрес:  1000  1001  1002  1003
Байты:  0x12  0x34  0x56  0x78
         ↑                   ↑
    старший              младший
```

**Практическое значение**: Различие в порядке байтов критично при обмене данными между системами с разной архитектурой (например, в сетевых протоколах). Сетевой порядок байтов (network byte order) — это Big Endian.

## Типы данных и их представление

### Классификация типов данных

В памяти ЭВМ могут храниться данные различных типов, каждый из которых имеет свой способ представления:

1. **Целочисленные типы**:
   - Беззнаковые целые (unsigned): только положительные числа и ноль
   - Знаковые целые (signed): положительные и отрицательные числа
   - Размеры: 8, 16, 32, 64 бита и более

2. **Вещественные типы** (числа с плавающей точкой):
   - Одинарная точность (float): 32 бита
   - Двойная точность (double): 64 бита
   - Расширенная точность: 80, 128 бит

3. **Символьные типы**:
   - ASCII-символы: 8 бит (1 байт)
   - Unicode символы: 16 или 32 бита (UTF-16, UTF-32)

4. **Логический тип** (boolean):
   - Обычно занимает 1 байт (хотя логически нужен 1 бит)

5. **Составные типы**:
   - Строки (последовательности символов)
   - Массивы (последовательности однотипных элементов)
   - Структуры и записи (группы разнотипных данных)
   - Указатели (адреса ячеек памяти)

### Выравнивание данных

**Выравнивание** (alignment) — это размещение данных в памяти по адресам, кратным размеру данных или степени двойки. Например, 4-байтовое целое число предпочтительно размещать по адресу, кратному 4.

**Причины выравнивания**:
- Увеличение производительности: процессор быстрее читает выровненные данные
- Архитектурные требования: некоторые процессоры не могут читать невыравненные данные или делают это медленно
- Атомарность операций: выровненные данные можно атомарно читать/записывать

### Пример 2: Выравнивание структуры в памяти

**Задача**: Рассмотрим структуру данных:
```c
struct Example {
    char  a;    // 1 байт
    int   b;    // 4 байта
    char  c;    // 1 байт
};
```

Какой размер будет занимать эта структура в памяти с учётом выравнивания?

**Решение**:

Наивный подсчёт: 1 + 4 + 1 = 6 байт.

С учётом выравнивания по 4-байтовой границе:
```
Смещение: 0    1    2    3    4    5    6    7    8    9   10   11
Данные:  [a] [pad][pad][pad][ b  ][ b  ][ b  ][ b  ][c] [pad][pad][pad]
          ↑                   ↑                   ↑
        char                 int                 char

Размер: 12 байт
```

- `a` занимает байт 0
- 3 байта паддинга (1-3), чтобы `b` начинался с адреса, кратного 4
- `b` занимает байты 4-7
- `c` занимает байт 8
- 3 байта паддинга в конце (9-11), чтобы размер всей структуры был кратен 4

**Практическое значение**: Неоптимальное расположение полей в структуре может привести к увеличению расхода памяти. Переупорядочение полей по убыванию размера часто помогает минимизировать паддинг.

## Организация многомерных массивов

### Одномерные массивы

**Одномерный массив** — это последовательность элементов одного типа, расположенных в памяти непрерывно. Адрес элемента с индексом `i` вычисляется по формуле:

```
Адрес[i] = Базовый_адрес + i × Размер_элемента
```

### Пример 3: Адресация элементов одномерного массива

**Задача**: Массив из 5 целых чисел типа `int` (4 байта каждое) начинается с адреса 2000. Какие адреса имеют элементы массива?

**Решение**:

```
Индекс:    0      1      2      3      4
Адрес:  2000   2004   2008   2012   2016
Размер: [   4   ][   4   ][   4   ][   4   ][   4   ] байта
```

- `array[0]`: адрес = 2000 + 0×4 = 2000
- `array[1]`: адрес = 2000 + 1×4 = 2004
- `array[2]`: адрес = 2000 + 2×4 = 2008
- `array[3]`: адрес = 2000 + 3×4 = 2012
- `array[4]`: адрес = 2000 + 4×4 = 2016

### Многомерные массивы: row-major и column-major

Для многомерных массивов существуют два способа размещения в линейной памяти:

**Row-major order** (построчное размещение):
- Элементы одной строки располагаются последовательно
- Используется в C, C++, Python (NumPy по умолчанию)

**Column-major order** (постолбцовое размещение):
- Элементы одного столбца располагаются последовательно
- Используется в Fortran, MATLAB, R

### Пример 4: Размещение двумерного массива

**Задача**: Двумерный массив `A[3][4]` (3 строки, 4 столбца) целых чисел по 4 байта начинается с адреса 3000. Определить адрес элемента `A[1][2]` в обоих форматах.

**Решение**:

Элементы массива:
```
A[0][0]  A[0][1]  A[0][2]  A[0][3]
A[1][0]  A[1][1]  A[1][2]  A[1][3]
A[2][0]  A[2][1]  A[2][2]  A[2][3]
```

**Row-major** (построчно):
Порядок в памяти: A[0][0], A[0][1], A[0][2], A[0][3], A[1][0], A[1][1], A[1][2], ...

Формула: `Адрес[i][j] = Базовый_адрес + (i × Число_столбцов + j) × Размер_элемента`

Для A[1][2]:
```
Адрес = 3000 + (1 × 4 + 2) × 4 = 3000 + 6 × 4 = 3000 + 24 = 3024
```

**Column-major** (постолбцово):
Порядок в памяти: A[0][0], A[1][0], A[2][0], A[0][1], A[1][1], A[2][1], A[0][2], ...

Формула: `Адрес[i][j] = Базовый_адрес + (j × Число_строк + i) × Размер_элемента`

Для A[1][2]:
```
Адрес = 3000 + (2 × 3 + 1) × 4 = 3000 + 7 × 4 = 3000 + 28 = 3028
```

**Практическое значение**: Знание порядка размещения критично для оптимизации производительности. Обход массива в порядке, соответствующем его размещению в памяти, использует преимущества кэширования процессора.

## Стек и куча: динамическая организация памяти

### Сегменты памяти процесса

Память выполняющейся программы (процесса) организована в несколько сегментов:

1. **Сегмент кода** (text segment): содержит машинные инструкции программы
2. **Сегмент данных** (data segment): глобальные и статические переменные
3. **Стек** (stack): локальные переменные, параметры функций, адреса возврата
4. **Куча** (heap): динамически выделяемая память

### Стек

**Стек** работает по принципу LIFO (Last In, First Out — последним пришёл, первым ушёл). При вызове функции на стек помещаются:
- Параметры функции
- Адрес возврата
- Локальные переменные функции

При возврате из функции эти данные удаляются из стека.

**Характеристики стека**:
- Быстрое выделение и освобождение памяти
- Ограниченный размер (обычно несколько мегабайт)
- Автоматическое управление памятью

### Куча

**Куча** — это область памяти для динамического выделения произвольных блоков памяти. Программист явно запрашивает память (например, функциями `malloc`, `new`) и должен явно её освобождать (`free`, `delete`).

**Характеристики кучи**:
- Гибкое выделение блоков любого размера
- Больший доступный объём памяти
- Требует явного управления (может привести к утечкам памяти)
- Более медленное выделение/освобождение по сравнению со стеком

### Пример 5: Размещение данных в стеке и куче

**Задача**: Рассмотрим фрагмент кода:
```c
void function() {
    int localVar = 42;           // Локальная переменная
    int* heapVar = malloc(sizeof(int) * 100);  // Динамический массив
    *heapVar = 10;
    // ... работа с массивом ...
    free(heapVar);
}
```

Где будут размещены `localVar` и `heapVar`?

**Решение**:

- `localVar` — локальная переменная, размещается в **стеке**
  - Автоматически создаётся при входе в функцию
  - Автоматически уничтожается при выходе из функции
  - Адрес в стеке определяется указателем стека (stack pointer)

- Массив из 100 целых чисел — размещается в **куче**
  - Выделяется динамически функцией `malloc`
  - Память остаётся выделенной до явного освобождения функцией `free`
  - Адрес в куче возвращается функцией `malloc` и сохраняется в переменной `heapVar`

- `heapVar` (сам указатель) — размещается в **стеке**
  - Это локальная переменная, хранящая адрес
  - Размер указателя: 4 байта в 32-битных системах, 8 байт в 64-битных

**Практическое значение**: Понимание разницы между стеком и кучей помогает избежать распространённых ошибок:
- **Переполнение стека** (stack overflow) при рекурсии или больших локальных массивах
- **Утечки памяти** (memory leaks) при забытом освобождении памяти в куче
- **Висячие указатели** (dangling pointers) при обращении к освобождённой памяти

## Практическая значимость

Понимание представления данных в памяти ЭВМ имеет множество практических применений:

1. **Оптимизация программ**: Правильное использование типов данных и выравнивание структур может значительно повысить производительность.

2. **Отладка**: Знание организации памяти помогает находить ошибки, связанные с выходом за границы массива, повреждением памяти.

3. **Работа с низкоуровневыми API**: Взаимодействие с оборудованием, драйверами, операционной системой требует понимания байтового представления данных.

4. **Сетевое программирование**: Обмен данными между системами с разной архитектурой требует учёта порядка байтов.

5. **Разработка встраиваемых систем**: Ограниченные ресурсы памяти требуют максимально эффективного использования каждого байта.

6. **Безопасность**: Многие уязвимости (переполнение буфера, атаки на стек) основаны на особенностях организации памяти.

## Ключевые термины и определения

- **Оперативная память (ОЗУ, RAM)** — быстродействующая энергозависимая память для временного хранения данных и программ.

- **Байт** — минимальная адресуемая единица памяти, состоящая из 8 бит.

- **Адрес** — уникальный идентификатор (номер) ячейки памяти.

- **Слово (word)** — базовая единица данных, обрабатываемая процессором за одну операцию.

- **Little Endian** — порядок байтов, при котором младший байт располагается по младшему адресу.

- **Big Endian** — порядок байтов, при котором старший байт располагается по младшему адресу.

- **Выравнивание (alignment)** — размещение данных в памяти по адресам, кратным размеру данных или степени двойки.

- **Паддинг (padding)** — дополнительные неиспользуемые байты, вставляемые для обеспечения выравнивания.

- **Row-major order** — построчное размещение многомерного массива в линейной памяти.

- **Column-major order** — постолбцовое размещение многомерного массива в линейной памяти.

- **Стек (stack)** — область памяти для локальных переменных и адресов возврата, работающая по принципу LIFO.

- **Куча (heap)** — область памяти для динамического выделения блоков произвольного размера.

- **Утечка памяти (memory leak)** — ситуация, когда динамически выделенная память не освобождается после использования.

## Контрольные вопросы для самопроверки

1. **Теоретический вопрос**: Объясните, почему байт (8 бит) стал стандартной минимальной адресуемой единицей памяти в современных компьютерах. Какие альтернативы существовали в истории вычислительной техники?

2. **Практическая задача**: 64-битное целое число 0x123456789ABCDEF0 хранится в памяти, начиная с адреса 5000, в формате Little Endian. Запишите содержимое каждого байта памяти с адреса 5000 по 5007.

3. **Задача на вычисление**: Рассчитайте минимальный размер (с учётом выравнивания по 8-байтовой границе) следующей структуры:
   ```c
   struct Data {
       char   a;     // 1 байт
       double b;     // 8 байт
       short  c;     // 2 байта
       int    d;     // 4 байта
   };
   ```

4. **Задача на многомерные массивы**: Трёхмерный массив `B[2][3][4]` целых чисел (4 байта) начинается с адреса 6000. Массив размещён в row-major порядке (последний индекс изменяется быстрее всего). Найдите адрес элемента `B[1][2][1]`.

5. **Концептуальный вопрос**: В чём принципиальная разница между стеком и кучей с точки зрения управления памятью? Приведите примеры ситуаций, когда предпочтительнее использовать стек, и когда — кучу.

---

**Связь с другими главами**:
- Глава 1.1 (Арифметика в двоичной системе) — фундамент для понимания двоичного представления данных
- Глава 1.9 (Представление числовых данных) — детализация способов кодирования чисел
- Глава 2.1 (Архитектура ЭВМ) — аппаратная реализация организации памяти
- Глава 3.1 (Операционные системы) — управление памятью на уровне ОС

---

_Глава подготовлена в соответствии со спецификацией учебника. Объём: ~11500 символов._
