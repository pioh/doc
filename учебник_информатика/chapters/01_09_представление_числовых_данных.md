# Глава 1.9: Представление числовых данных в двоичном коде

## Введение

Числа — основа всех вычислений, выполняемых компьютером. От простых арифметических операций до сложных научных расчётов, от графики до искусственного интеллекта — везде используются числовые данные. Понимание того, как компьютер представляет и обрабатывает числа в двоичном коде, является фундаментальным для любого специалиста в области информатики.

Данная тема тесно связана с главой 1.1, где мы изучали арифметику в двоичной системе счисления, и главой 1.2, где рассматривали представление данных в памяти ЭВМ. Знания из этой главы понадобятся при изучении главы 1.11 (системы счисления), раздела 2 (архитектура ЭВМ) и раздела 6 (языки программирования).

В этой главе мы рассмотрим, как компьютер представляет целые числа (беззнаковые и знаковые) и вещественные числа (числа с плавающей точкой), изучим стандарт IEEE 754, разберём проблемы точности вычислений и познакомимся с практическими аспектами работы с числами в программировании.

## Представление целых чисел

### Беззнаковые целые числа

**Беззнаковые целые числа** (unsigned integers) — это неотрицательные целые числа, представленные в двоичной системе счисления без знака.

При представлении беззнакового целого числа в n битах можно закодировать числа в диапазоне от 0 до (2ⁿ − 1).

**Примеры:**

- **8 бит** (1 байт): диапазон от 0 до 255 (2⁸ − 1)
- **16 бит** (2 байта): диапазон от 0 до 65 535 (2¹⁶ − 1)
- **32 бит** (4 байта): диапазон от 0 до 4 294 967 295 (2³² − 1)
- **64 бит** (8 байт): диапазон от 0 до 18 446 744 073 709 551 615 (2⁶⁴ − 1)

**Преобразование десятичного числа в двоичный беззнаковый код:**

Используется метод последовательного деления на 2 (будет подробно рассмотрен в главе 1.11).

**Пример:** Представим число 75 в 8-битном беззнаковом формате.

```
75₁₀ = 64 + 8 + 2 + 1 = 2⁶ + 2³ + 2¹ + 2⁰

В двоичной системе:
75₁₀ = 01001011₂

Проверка: 0×128 + 1×64 + 0×32 + 0×16 + 1×8 + 0×4 + 1×2 + 1×1 = 75
```

### Знаковые целые числа

**Знаковые целые числа** (signed integers) могут быть положительными, отрицательными или нулём. Для их представления необходимо закодировать знак числа.

Существует три основных способа представления знаковых чисел:

#### 1. Прямой код (Sign-Magnitude)

В **прямом коде** старший бит отводится под знак (0 — положительное, 1 — отрицательное), остальные биты хранят модуль числа.

**Недостатки прямого кода:**
- Два представления нуля: +0 (00000000) и −0 (10000000)
- Усложнённая арифметика (требуется различная логика для положительных и отрицательных чисел)
- Практически не используется в современных компьютерах

**Пример (8 бит):**
```
+75₁₀ = 01001011₂  (знак = 0, модуль = 1001011)
−75₁₀ = 11001011₂  (знак = 1, модуль = 1001011)
```

#### 2. Обратный код (One's Complement)

В **обратном коде** положительные числа представляются как в прямом коде, а отрицательные получаются инверсией всех битов положительного числа.

**Недостатки обратного кода:**
- Два представления нуля: +0 (00000000) и −0 (11111111)
- При сложении требуется циклический перенос
- Используется редко (в некоторых старых системах)

**Пример (8 бит):**
```
+75₁₀ = 01001011₂
−75₁₀ = 10110100₂  (инверсия всех битов 01001011)

Проверка инверсии: 
01001011 → инверсия → 10110100
```

#### 3. Дополнительный код (Two's Complement) — основной метод

**Дополнительный код** является стандартом де-факто для представления знаковых чисел во всех современных компьютерах.

**Правила получения дополнительного кода:**

1. **Положительные числа и ноль**: представляются обычным двоичным кодом со старшим битом 0
2. **Отрицательные числа**: получаются двумя способами:
   - **Способ А**: инвертировать все биты положительного числа и прибавить 1
   - **Способ Б**: переписать биты справа налево до первой единицы включительно, остальные инвертировать

**Преимущества дополнительного кода:**
- ✅ Единственное представление нуля (00000000)
- ✅ Простая арифметика: сложение и вычитание выполняются одинаково для положительных и отрицательных чисел
- ✅ Старший бит указывает знак (0 = положительное, 1 = отрицательное)
- ✅ Естественное расширение разрядности

**Диапазон для n-битного знакового числа в дополнительном коде:**
- От −2ⁿ⁻¹ до (2ⁿ⁻¹ − 1)

**Примеры диапазонов:**
- **8 бит**: от −128 до +127
- **16 бит**: от −32 768 до +32 767
- **32 бит**: от −2 147 483 648 до +2 147 483 647
- **64 бит**: от −9 223 372 036 854 775 808 до +9 223 372 036 854 775 807

**Пример получения дополнительного кода (8 бит):**

Представим число −75₁₀.

**Способ А (инверсия + 1):**
```
Шаг 1: Представим +75 в двоичном коде:
+75₁₀ = 01001011₂

Шаг 2: Инвертируем все биты:
01001011 → 10110100

Шаг 3: Прибавляем 1:
  10110100
+        1
----------
  10110101

Результат: −75₁₀ = 10110101₂ (в дополнительном коде)
```

**Проверка:** Сложим +75 и −75, должен получиться 0:
```
  01001011  (+75)
+ 10110101  (−75)
----------
1 00000000

Перенос за пределы 8 бит отбрасывается → 00000000 = 0 ✓
```

**Способ Б (переписывание и инверсия):**
```
+75₁₀ = 01001011₂

Переписываем справа налево до первой 1 включительно: ...011
Инвертируем остальные: 01001 → 10110

Результат: 10110101₂
```

### Переполнение (Overflow)

**Переполнение** возникает, когда результат операции выходит за пределы допустимого диапазона представления.

**Пример переполнения при сложении (8 бит, знаковые):**
```
  01111111  (+127, максимум для 8 бит)
+        1  (+1)
----------
  10000000  (−128 в дополнительном коде!)

Результат: 127 + 1 = −128 (переполнение!)
```

В программировании переполнение может привести к серьёзным ошибкам, поэтому важно:
- Выбирать достаточную разрядность для данных
- Проверять результаты операций на переполнение
- Использовать типы данных с бо́льшей разрядностью при необходимости

## Представление вещественных чисел

**Вещественные числа** (floating-point numbers) — это числа с дробной частью, например: 3.14, −0.001, 2.5×10⁸.

Для представления вещественных чисел используется формат с **плавающей точкой** (floating point), стандартизированный в **IEEE 754**.

### Формат IEEE 754

Стандарт **IEEE 754** определяет два основных формата:

1. **Single precision (одинарная точность, float)** — 32 бита
2. **Double precision (двойная точность, double)** — 64 бита

**Общая структура числа с плавающей точкой:**

**(-1)^S × M × 2^E**

где:
- **S** (Sign) — знак (1 бит): 0 = положительное, 1 = отрицательное
- **E** (Exponent) — экспонента (смещённый порядок)
- **M** (Mantissa/Significand) — мантисса (значащие цифры)

### Float (32 бита)

**Структура 32-битного числа с плавающей точкой:**

```
| S (1 бит) | E (8 бит) | M (23 бита) |
  Знак        Экспонента  Мантисса
```

**Параметры:**
- **Знак (S)**: 1 бит
- **Экспонента (E)**: 8 бит, смещение = 127
  - Реальная экспонента = E − 127
  - Диапазон: от −126 до +127 (значения 0 и 255 зарезервированы)
- **Мантисса (M)**: 23 бита
  - Неявная единица: мантисса представляется как 1.ММММММ... (нормализованная форма)
  - Фактически хранится 24 бита точности (23 явно + 1 неявно)

**Диапазон значений float:**
- Минимальное положительное нормализованное: ≈ 1.18 × 10⁻³⁸
- Максимальное: ≈ 3.40 × 10³⁸
- Точность: около 7 десятичных цифр

### Double (64 бита)

**Структура 64-битного числа с плавающей точкой:**

```
| S (1 бит) | E (11 бит) | M (52 бита) |
  Знак        Экспонента   Мантисса
```

**Параметры:**
- **Знак (S)**: 1 бит
- **Экспонента (E)**: 11 бит, смещение = 1023
  - Реальная экспонента = E − 1023
  - Диапазон: от −1022 до +1023
- **Мантисса (M)**: 52 бита + 1 неявный = 53 бита точности

**Диапазон значений double:**
- Минимальное положительное нормализованное: ≈ 2.23 × 10⁻³⁰⁸
- Максимальное: ≈ 1.80 × 10³⁰⁸
- Точность: около 15-16 десятичных цифр

### Нормализованная форма

**Нормализованная форма** — это представление числа в виде 1.xxxx × 2^exp, где старший бит мантиссы равен 1 (неявный).

**Пример нормализации:**
```
Число: 13.625₁₀

Шаг 1: Переведём в двоичную систему:
13₁₀ = 1101₂
0.625₁₀ = 0.101₂ (0.625 = 1/2 + 1/8 = 0.5 + 0.125)

Результат: 13.625₁₀ = 1101.101₂

Шаг 2: Нормализуем (сдвиг точки до 1.xxxxx):
1101.101₂ = 1.101101₂ × 2³

Шаг 3: Запишем в формате IEEE 754 (float, 32 бита):
Знак S = 0 (положительное число)
Экспонента: 3 + 127 = 130₁₀ = 10000010₂
Мантисса: 101101 (23 бита): 10110100000000000000000

Итоговое представление (32 бита):
0 10000010 10110100000000000000000
│ └────┬───┘ └──────────┬───────────┘
│   Exp=130      Mantissa
Sign=0
```

### Специальные значения

Стандарт IEEE 754 определяет несколько специальных значений:

#### 1. Ноль (±0)

```
+0: S=0, E=0, M=0  (все биты = 0)
−0: S=1, E=0, M=0
```

Существование −0 может показаться странным, но это полезно в некоторых вычислениях (например, для сохранения знака при приближении к нулю).

#### 2. Бесконечность (±∞)

```
+∞: S=0, E=все единицы (255 для float), M=0
−∞: S=1, E=все единицы (255 для float), M=0
```

Возникает при делении на ноль или переполнении:
```
1.0 / 0.0 = +∞
−1.0 / 0.0 = −∞
```

#### 3. NaN (Not a Number)

```
NaN: E=все единицы (255 для float), M≠0
```

Возникает при неопределённых операциях:
```
0.0 / 0.0 = NaN
∞ − ∞ = NaN
√(−1) = NaN (для вещественных чисел)
```

**Важное свойство NaN:** Любая операция с NaN даёт NaN, включая сравнение. Даже `NaN == NaN` возвращает `false`!

#### 4. Денормализованные числа (Subnormal/Denormal)

**Денормализованные числа** используются для представления очень малых чисел, близких к нулю, когда экспонента равна 0, а мантисса ненулевая.

```
Денормализованное: E=0, M≠0
Значение: (−1)^S × 0.ММММ × 2^(−126)  (для float)
```

Денормализованные числа заполняют "щель" между нулём и минимальным нормализованным числом, предотвращая резкую потерю точности (underflow).

### Проблемы точности вычислений с плавающей точкой

#### Проблема 1: Конечная точность

Не все десятичные числа можно точно представить в двоичной форме.

**Пример:** Число 0.1₁₀ не имеет точного представления в двоичной системе:
```
0.1₁₀ = 0.0001100110011001100...₂  (бесконечная периодическая дробь)
```

В результате:
```python
# Python (аналогично в большинстве языков)
0.1 + 0.2 == 0.3  # False!
0.1 + 0.2          # 0.30000000000000004
```

#### Проблема 2: Потеря точности при операциях с числами разного масштаба

При сложении очень большого и очень маленького числа младшие разряды маленького числа могут быть потеряны.

**Пример (концептуально):**
```
10000000.0 + 0.00000001 ≈ 10000000.0  (в float точность недостаточна)
```

#### Проблема 3: Накопление ошибок округления

При многократных операциях ошибки округления накапливаются.

**Пример:**
```python
x = 0.0
for i in range(10):
    x += 0.1
print(x)  # 0.9999999999999999 вместо 1.0
```

### Рекомендации по работе с вещественными числами

1. **Не сравнивайте вещественные числа на точное равенство**. Используйте сравнение с погрешностью (epsilon):
   ```python
   epsilon = 1e-9
   if abs(a - b) < epsilon:
       # числа считаются равными
   ```

2. **Используйте double вместо float**, если требуется бо́льшая точность.

3. **Для финансовых расчётов** используйте специальные типы данных (Decimal в Python, BigDecimal в Java), которые работают с десятичными числами без потери точности.

4. **Будьте осторожны с циклами**, где накапливаются ошибки округления.

5. **Избегайте вычитания близких по значению чисел** — это может привести к катастрофической потере точности (catastrophic cancellation).

## Практические примеры

### Пример 1: Представление числа в дополнительном коде

**Задача:** Представьте число −42₁₀ в 8-битном дополнительном коде.

**Решение:**

Шаг 1: Представим +42 в двоичном коде:
```
42₁₀ = 32 + 8 + 2 = 2⁵ + 2³ + 2¹
42₁₀ = 00101010₂
```

Шаг 2: Инвертируем все биты:
```
00101010 → 11010101
```

Шаг 3: Прибавляем 1:
```
  11010101
+        1
----------
  11010110
```

**Ответ:** −42₁₀ = 11010110₂ (в дополнительном коде)

**Проверка:** Сложим +42 и −42:
```
  00101010  (+42)
+ 11010110  (−42)
----------
1 00000000

Старший бит переполнения отбрасывается → 00000000 = 0 ✓
```

### Пример 2: Декодирование числа из дополнительного кода

**Задача:** Какое десятичное число представляет 8-битный код 11100101₂ в дополнительном коде?

**Решение:**

Старший бит = 1, следовательно, число отрицательное.

Способ А (инверсия + 1 для получения модуля):
```
Шаг 1: Инвертируем все биты:
11100101 → 00011010

Шаг 2: Прибавляем 1:
  00011010
+        1
----------
  00011011

Шаг 3: Переводим в десятичную систему:
00011011₂ = 16 + 8 + 2 + 1 = 27₁₀

Шаг 4: Добавляем знак:
Результат: −27₁₀
```

Способ Б (прямой расчёт):
```
Вес старшего бита в дополнительном коде = −128

Значение = −128×1 + 64×1 + 32×1 + 16×0 + 8×0 + 4×1 + 2×0 + 1×1
         = −128 + 64 + 32 + 4 + 1
         = −27₁₀
```

**Ответ:** 11100101₂ = −27₁₀

### Пример 3: Диапазоны представления

**Задача:** Определите диапазон значений для:
- a) 16-битных беззнаковых целых
- b) 16-битных знаковых целых (дополнительный код)

**Решение:**

a) **16-битные беззнаковые целые:**
```
Диапазон: от 0 до (2¹⁶ − 1)
Диапазон: от 0 до 65 535
```

b) **16-битные знаковые целые (дополнительный код):**
```
Диапазон: от −2¹⁵ до (2¹⁵ − 1)
Диапазон: от −32 768 до +32 767
```

**Замечание:** Обратите внимание, что в дополнительном коде модуль наименьшего отрицательного числа (|−32 768| = 32 768) больше наибольшего положительного (32 767) на единицу. Это связано с тем, что существует только одно представление нуля.

### Пример 4: Переполнение при операциях

**Задача:** Используя 8-битную арифметику в дополнительном коде, вычислите:
- a) 100 + 50
- b) −100 − 50

**Решение:**

a) **100 + 50:**
```
+100₁₀ = 01100100₂
+50₁₀  = 00110010₂

  01100100
+ 00110010
----------
  10010110  (знаковый бит = 1, это отрицательное число!)

Декодируем: 10010110₂ = −128 + 16 + 4 + 2 = −106₁₀

Результат: 100 + 50 = −106 (переполнение!)
```

**Объяснение:** Правильный результат 150 выходит за пределы диапазона [−128, +127], произошло переполнение.

b) **−100 − 50:**
```
−100₁₀ = 10011100₂ (в дополнительном коде)
−50₁₀  = 11001110₂ (в дополнительном коде)

  10011100
+ 11001110
----------
1 01101010

Отбрасываем перенос за пределы 8 бит: 01101010₂

Переводим: 01101010₂ = 64 + 32 + 8 + 2 = 106₁₀

Результат: −100 − 50 = 106 (переполнение!)
```

**Объяснение:** Правильный результат −150 выходит за пределы диапазона [−128, +127], произошло переполнение.

### Пример 5: Представление числа в формате IEEE 754 float

**Задача:** Представьте число −6.25₁₀ в формате IEEE 754 single precision (32 бита).

**Решение:**

Шаг 1: Переведём модуль в двоичную систему:
```
6₁₀ = 110₂
0.25₁₀ = 0.01₂  (0.25 = 1/4 = 2⁻²)

6.25₁₀ = 110.01₂
```

Шаг 2: Нормализуем:
```
110.01₂ = 1.1001₂ × 2²
```

Шаг 3: Определяем компоненты:
```
Знак S: 1 (отрицательное число)
Экспонента: 2 + 127 = 129₁₀ = 10000001₂
Мантисса: 1001 (после десятичной точки, дополняем нулями до 23 бит)
          10010000000000000000000
```

Шаг 4: Собираем представление:
```
Знак: 1
Экспонента: 10000001
Мантисса: 10010000000000000000000

Полное представление (32 бита):
1 10000001 10010000000000000000000
```

**Ответ:** −6.25₁₀ в IEEE 754 float:
```
Шестнадцатеричное: 0xC0C80000
Двоичное: 11000000110010000000000000000000
```

### Пример 6: Декодирование из IEEE 754

**Задача:** Декодируйте число, представленное в формате IEEE 754 double (64 бита):
```
0 10000000011 1000000000000000000000000000000000000000000000000000
```

**Решение:**

Шаг 1: Разбиваем на компоненты:
```
Знак S = 0 (положительное)
Экспонента E = 10000000011₂ = 1024₁₀
Мантисса M = 1000...0 (52 бита)
```

Шаг 2: Вычисляем реальную экспонен ту:
```
Реальная экспонента = E − 1023 = 1024 − 1023 = 1
```

Шаг 3: Восстанавливаем мантиссу с неявной единицей:
```
Мантисса = 1.1000...0₂ = 1.5₁₀  (1 + 0.5)
```

Шаг 4: Вычисляем итоговое значение:
```
Значение = (−1)⁰ × 1.5 × 2¹
         = 1 × 1.5 × 2
         = 3.0
```

**Ответ:** Закодированное число = 3.0

### Пример 7: Проблема точности

**Задача:** Объясните, почему в программировании выражение `0.1 + 0.1 + 0.1 == 0.3` может вернуть `false`.

**Решение:**

**Объяснение:**

Число 0.1₁₀ не имеет точного представления в двоичной системе:
```
0.1₁₀ = 0.0001100110011001100110011...₂  (бесконечная периодическая дробь)
```

При хранении в формате float или double происходит округление, например, в double:
```
0.1 ≈ 0.1000000000000000055511151231257827021181583404541015625
```

При сложении трёх таких приближённых значений:
```
0.1 + 0.1 + 0.1 ≈ 0.30000000000000004
```

А число 0.3 также приближённо:
```
0.3 ≈ 0.299999999999999988897769753748434595763683319091796875
```

Эти два значения не совпадают побитово, поэтому сравнение на точное равенство `==` возвращает `false`.

**Правильное сравнение:**
```python
epsilon = 1e-9
result = 0.1 + 0.1 + 0.1
expected = 0.3
if abs(result - expected) < epsilon:
    print("Числа считаются равными")
```

## Типы данных в языках программирования

Различные языки программирования предоставляют различные типы данных для работы с числами.

### Целые числа

| Язык       | Тип                | Размер     | Диапазон (знаковые)                       |
| ---------- | ------------------ | ---------- | ----------------------------------------- |
| C/C++      | `char`             | 8 бит      | −128 ... 127                              |
|            | `short`            | 16 бит     | −32 768 ... 32 767                        |
|            | `int`              | 32 бита    | −2 147 483 648 ... 2 147 483 647          |
|            | `long long`        | 64 бита    | −2⁶³ ... (2⁶³−1)                          |
| Java       | `byte`             | 8 бит      | −128 ... 127                              |
|            | `short`            | 16 бит     | −32 768 ... 32 767                        |
|            | `int`              | 32 бита    | −2 147 483 648 ... 2 147 483 647          |
|            | `long`             | 64 бита    | −2⁶³ ... (2⁶³−1)                          |
| Python 3   | `int`              | Переменный | Ограничен только памятью                  |
| JavaScript | `Number` (целая ч.)| 53 бита    | −(2⁵³−1) ... (2⁵³−1) (целые в double)     |

**Замечание:** В Python 3 тип `int` имеет произвольную точность (arbitrary precision) и может представлять сколь угодно большие целые числа, ограничиваясь только доступной памятью.

### Вещественные числа

| Язык       | Тип      | Размер  | Точность           | Стандарт  |
| ---------- | -------- | ------- | ------------------ | --------- |
| C/C++      | `float`  | 32 бита | ~7 дес. цифр       | IEEE 754  |
|            | `double` | 64 бита | ~15-16 дес. цифр   | IEEE 754  |
| Java       | `float`  | 32 бита | ~7 дес. цифр       | IEEE 754  |
|            | `double` | 64 бита | ~15-16 дес. цифр   | IEEE 754  |
| Python     | `float`  | 64 бита | ~15-16 дес. цифр   | IEEE 754  |
| JavaScript | `Number` | 64 бита | ~15-16 дес. цифр   | IEEE 754  |

## Практическое значение и применение

### В архитектуре компьютеров

- **Регистры процессора:** Современные процессоры имеют регистры 32-битные (x86) или 64-битные (x64), определяющие разрядность целочисленных операций.
- **АЛУ (арифметико-логическое устройство):** Выполняет операции в дополнительном коде для целых чисел и по стандарту IEEE 754 для вещественных.
- **FPU (floating-point unit):** Специализированный блок процессора для быстрых операций с числами с плавающей точкой.

### В программировании

- **Выбор типа данных:** Правильный выбор типа данных (int, long, float, double) критичен для производительности и корректности программы.
- **Финансовые расчёты:** Использование специальных типов (Decimal) для избежания ошибок округления.
- **Научные вычисления:** Использование double для большей точности, библиотеки произвольной точности (mpmath, GMP) для экстремальных требований.

### В криптографии

- **Большие целые числа:** Алгоритмы шифрования (RSA, Diffie-Hellman) оперируют целыми числами размером 1024-4096 бит.
- **Модульная арифметика:** Использует целочисленные операции с большими модулями.

### В графике и обработке сигналов

- **Представление цвета:** RGB-компоненты обычно хранятся как беззнаковые 8-битные целые (0-255).
- **Аудио:** Сэмплы звука хранятся как знаковые 16-битные или 24-битные целые.
- **Координаты и трансформации:** Используются вещественные числа (float, double) для точности.

## Связь с другими темами

Изученная в этой главе тема тесно связана с:

- **Глава 1.1**: Арифметика в двоичной системе счисления — операции с двоичными числами, которые применяются к целым числам в дополнительном коде.
- **Глава 1.2**: Представление данных в памяти ЭВМ — числа хранятся в памяти согласно рассмотренным форматам, учитывается порядок байтов (Little/Big Endian).
- **Глава 1.11**: Системы счисления — перевод чисел между системами счисления необходим для понимания двоичного представления.
- **Раздел 2 (Архитектура ЭВМ)**: Процессор выполняет операции с числами в изученных форматах, АЛУ и FPU реализуют соответствующую логику.
- **Раздел 6 (Языки программирования)**: Типы данных в языках программирования напрямую соответствуют рассмотренным форматам представления чисел.

## Ключевые термины и определения

**Беззнаковое целое число (unsigned integer)** — неотрицательное целое число, представленное в двоичной системе без знака, диапазон от 0 до (2ⁿ − 1).

**Знаковое целое число (signed integer)** — целое число, которое может быть положительным, отрицательным или нулём.

**Прямой код (sign-magnitude)** — способ представления знаковых чисел, где старший бит кодирует знак, остальные биты — модуль числа.

**Обратный код (one's complement)** — способ представления знаковых чисел, где отрицательное число получается инверсией всех битов положительного.

**Дополнительный код (two's complement)** — стандартный способ представления знаковых чисел в современных компьютерах, где отрицательное число получается инверсией битов положительного числа и прибавлением 1.

**Переполнение (overflow)** — ситуация, когда результат операции выходит за пределы допустимого диапазона представления числа.

**Вещественное число (floating-point number)** — число с дробной частью, представленное в формате с плавающей точкой.

**IEEE 754** — международный стандарт представления вещественных чисел с плавающей точкой в компьютерах.

**Нормализованная форма** — представление числа с плавающей точкой в виде 1.xxxxx × 2^exp, где старший бит мантиссы равен 1.

**Мантисса (mantissa, significand)** — часть числа с плавающей точкой, хранящая значащие цифры.

**Экспонента (exponent)** — часть числа с плавающей точкой, определяющая порядок (степень двойки).

**NaN (Not a Number)** — специальное значение в формате IEEE 754, обозначающее результат неопределённой операции.

**Денормализованное число (subnormal, denormal)** — число с плавающей точкой с экспонентой 0 и ненулевой мантиссой, используется для представления очень малых чисел.

## Контрольные вопросы для самопроверки

1. **В чём основное преимущество дополнительного кода** перед прямым и обратным кодами при представлении знаковых целых чисел? Почему современные компьютеры используют именно дополнительный код?

2. **Представьте число −100₁₀** в 8-битном дополнительном коде. Выполните проверку, сложив +100 и −100.

3. **Определите диапазон значений** для 32-битных знаковых целых чисел в дополнительном коде. Какое наименьшее и наибольшее число можно представить?

4. **Объясните структуру числа в формате IEEE 754 single precision (float).** Сколько бит отведено под знак, экспоненту и мантиссу? Что такое "неявная единица"?

5. **Почему в программировании опасно сравнивать вещественные числа на точное равенство** (например, `a == b`)? Как правильно сравнивать вещественные числа?

6. **Что такое NaN и когда оно возникает?** Какое необычное свойство имеет NaN при сравнении самого с собой?

7. **Задача на расчёт:** Декодируйте число, представленное в 8-битном дополнительном коде: 10110011₂. Какое десятичное число оно представляет?

8. **Что произойдёт при выполнении операции 127 + 1** в 8-битной знаковой арифметике (дополнительный код)? Объясните причину.

9. **Переведите число 5.75₁₀** в формат IEEE 754 float (32 бита). Укажите двоичное представление знака, экспоненты и мантиссы.

10. **В каких областях критически важна точность представления чисел?** Приведите примеры и объясните, какие типы данных следует использовать.

## Резюме главы

В этой главе мы изучили:

1. ✅ **Представление целых чисел:**
   - Беззнаковые целые (диапазон 0 ... 2ⁿ−1)
   - Знаковые целые: прямой код, обратный код, дополнительный код
   - Дополнительный код как стандарт в современных ЭВМ
   - Проблема переполнения при операциях

2. ✅ **Представление вещественных чисел:**
   - Формат с плавающей точкой IEEE 754
   - Структура: знак, экспонента, мантисса
   - Float (32 бита) и Double (64 бита)
   - Нормализованная форма
   - Специальные значения: ±0, ±∞, NaN, денормализованные числа

3. ✅ **Проблемы точности:**
   - Конечная точность представления
   - Ошибки округления
   - Накопление ошибок при многократных операциях
   - Правильные методы сравнения вещественных чисел

4. ✅ **Практические аспекты:**
   - Типы данных в языках программирования
   - Выбор подходящего типа для задачи
   - Применение в архитектуре ЭВМ, программировании, криптографии

Теперь вы должны уметь:

- Представлять целые числа в дополнительном коде и декодировать их
- Понимать структуру чисел с плавающей точкой IEEE 754
- Объяснять причины ошибок точности при работе с вещественными числами
- Выбирать подходящие типы данных для различных задач программирования
- Рассчитывать диапазоны представления для различной разрядности

Эти знания понадобятся в главе 1.11 при изучении систем счисления, в разделе 2 при рассмотрении архитектуры ЭВМ и работы процессора, а также в разделе 6 при программировании на языках высокого уровня.

---

_Конец главы_

---

## Метаинформация (не включается в финальный учебник)

**Объём**: ~18 500 символов  
**Время на изучение**: 50-60 минут  
**Сложность**: Средне-высокая  
**Предварительные требования**: Главы 1.1, 1.2  
**Статус**: ✅ Готова (14 января 2026)
