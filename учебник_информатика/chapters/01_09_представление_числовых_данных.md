# Глава 1.9: Представление числовых данных в двоичном коде

## Введение

Значит так, братишка. Числа — это основа всех вычислений. От простого сложения 2+2 до нейросетей — везде числа. И компьютер должен как-то хранить эти числа в своей двоичной памяти. Просто взять и записать число 42 в двоичной системе? Не всё так просто, особенно если число отрицательное или с дробной частью.

Эта тема связана с главой 1.1 (арифметика в двоичной системе) и главой 1.2 (представление данных в памяти). А ещё понадобится в главе 1.11 (системы счисления), разделе 2 (архитектура ЭВМ — как процессор считает) и разделе 6 (языки программирования — типы данных).

В этой главе разберём, как компьютер представляет целые числа (положительные и отрицательные) и вещественные числа (числа с плавающей точкой). И почему в программировании `0.1 + 0.2 != 0.3` (спойлер: виновата конечная точность).

## Представление целых чисел

### Беззнаковые целые (unsigned integers)

**Беззнаковые целые** — это неотрицательные числа (0, 1, 2, 3...), представленные в двоичной системе без знака.

При n битах можно закодировать числа от 0 до (2ⁿ − 1).

**Примеры:**

- **8 бит** (1 байт): 0 ... 255 (2⁸ − 1)
- **16 бит** (2 байта): 0 ... 65 535 (2¹⁶ − 1)
- **32 бит** (4 байта): 0 ... 4 294 967 295 (2³² − 1)
- **64 бит** (8 байт): 0 ... 18 446 744 073 709 551 615 (2⁶⁴ − 1)

**Пример:** Представим число 75 в 8-битном беззнаковом формате.

```
75₁₀ = 64 + 8 + 2 + 1 = 2⁶ + 2³ + 2¹ + 2⁰

В двоичной системе:
75₁₀ = 01001011₂

Проверка: 0×128 + 1×64 + 0×32 + 0×16 + 1×8 + 0×4 + 1×2 + 1×1 = 75
```

### Знаковые целые (signed integers) — тут начинается веселье

**Знаковые целые** могут быть положительными, отрицательными или нулём. Нужно закодировать знак числа.

Есть три способа:

#### 1. Прямой код (Sign-Magnitude) — не используется

В **прямом коде** старший бит — знак (0 = плюс, 1 = минус), остальные биты — модуль числа.

**Недостатки:**
- Два представления нуля: +0 (00000000) и −0 (10000000) — как так, блять?
- Усложнённая арифметика (разная логика для плюсов и минусов)
- Практически не используется

**Пример (8 бит):**
```
+75₁₀ = 01001011₂  (знак = 0, модуль = 1001011)
−75₁₀ = 11001011₂  (знак = 1, модуль = 1001011)
```

#### 2. Обратный код (One's Complement) — тоже не используется

В **обратном коде** положительные числа — как в прямом, отрицательные — инверсия всех битов.

**Недостатки:**
- Опять два нуля: +0 (00000000) и −0 (11111111)
- При сложении нужен циклический перенос
- Используется редко

**Пример (8 бит):**
```
+75₁₀ = 01001011₂
−75₁₀ = 10110100₂  (инверсия всех битов)
```

#### 3. Дополнительный код (Two's Complement) — ВОТ ЭТО ИСПОЛЬЗУЕТСЯ

**Дополнительный код** — стандарт де-факто для представления знаковых чисел во всех современных компьютерах.

**Правила:**

1. **Положительные числа и ноль**: обычный двоичный код, старший бит = 0
2. **Отрицательные числа**: два способа получить:
   - **Способ А**: инвертировать все биты положительного числа и прибавить 1
   - **Способ Б**: переписать биты справа налево до первой единицы включительно, остальные инвертировать

**Преимущества:**
- ✅ Единственное представление нуля (00000000)
- ✅ Простая арифметика: сложение и вычитание одинаково работают для всех чисел
- ✅ Старший бит указывает знак (0 = плюс, 1 = минус)
- ✅ Естественное расширение разрядности

**Диапазон для n-битного знакового числа:**
- От −2ⁿ⁻¹ до (2ⁿ⁻¹ − 1)

**Примеры диапазонов:**
- **8 бит**: −128 ... +127
- **16 бит**: −32 768 ... +32 767
- **32 бит**: −2 147 483 648 ... +2 147 483 647
- **64 бит**: −9 223 372 036 854 775 808 ... +9 223 372 036 854 775 807

**Пример получения дополнительного кода (8 бит):**

Представим число −75₁₀.

**Способ А (инверсия + 1):**
```
Шаг 1: +75 в двоичном коде:
+75₁₀ = 01001011₂

Шаг 2: Инвертируем все биты:
01001011 → 10110100

Шаг 3: Прибавляем 1:
  10110100
+        1
----------
  10110101

Результат: −75₁₀ = 10110101₂ (в дополнительном коде)
```

**Проверка:** Сложим +75 и −75, должен получиться 0:
```
  01001011  (+75)
+ 10110101  (−75)
----------
1 00000000

Перенос за пределы 8 бит отбрасывается → 00000000 = 0 ✓
```

### Переполнение (Overflow) — баг, который всех достал

**Переполнение** возникает, когда результат операции выходит за пределы допустимого диапазона.

**Пример переполнения (8 бит, знаковые):**
```
  01111111  (+127, максимум для 8 бит)
+        1  (+1)
----------
  10000000  (−128 в дополнительном коде!)

Результат: 127 + 1 = −128 (переполнение!)
```

В программировании переполнение может привести к жёстким багам. Поэтому:
- Выбирай достаточную разрядность
- Проверяй результаты операций на переполнение
- Используй типы с бо́льшей разрядностью при необходимости

## Представление вещественных чисел (тут начинается магия)

**Вещественные числа** — это числа с дробной частью: 3.14, −0.001, 2.5×10⁸.

Для их представления используется формат с **плавающей точкой** (floating point), стандартизированный в **IEEE 754**.

### Формат IEEE 754

Стандарт **IEEE 754** определяет два основных формата:

1. **Single precision (float)** — 32 бита
2. **Double precision (double)** — 64 бита

**Общая структура:**

**(-1)^S × M × 2^E**

где:
- **S** (Sign) — знак (1 бит): 0 = плюс, 1 = минус
- **E** (Exponent) — экспонента (смещённый порядок)
- **M** (Mantissa) — мантисса (значащие цифры)

### Float (32 бита)

**Структура:**

```
| S (1 бит) | E (8 бит) | M (23 бита) |
  Знак        Экспонента  Мантисса
```

**Параметры:**
- **Знак (S)**: 1 бит
- **Экспонента (E)**: 8 бит, смещение = 127
  - Реальная экспонента = E − 127
  - Диапазон: −126 ... +127
- **Мантисса (M)**: 23 бита
  - Неявная единица: мантисса представляется как 1.ММММММ... (нормализованная форма)
  - Фактически 24 бита точности (23 явно + 1 неявно)

**Диапазон значений float:**
- Минимальное положительное: ≈ 1.18 × 10⁻³⁸
- Максимальное: ≈ 3.40 × 10³⁸
- Точность: около 7 десятичных цифр

### Double (64 бита)

**Структура:**

```
| S (1 бит) | E (11 бит) | M (52 бита) |
  Знак        Экспонента   Мантисса
```

**Параметры:**
- **Знак (S)**: 1 бит
- **Экспонента (E)**: 11 бит, смещение = 1023
  - Реальная экспонента = E − 1023
  - Диапазон: −1022 ... +1023
- **Мантисса (M)**: 52 бита + 1 неявный = 53 бита точности

**Диапазон значений double:**
- Минимальное положительное: ≈ 2.23 × 10⁻³⁰⁸
- Максимальное: ≈ 1.80 × 10³⁰⁸
- Точность: около 15-16 десятичных цифр

### Нормализованная форма

**Нормализованная форма** — представление числа в виде 1.xxxx × 2^exp, где старший бит мантиссы = 1 (неявный).

**Пример нормализации:**
```
Число: 13.625₁₀

Шаг 1: Переводим в двоичную:
13₁₀ = 1101₂
0.625₁₀ = 0.101₂ (0.625 = 1/2 + 1/8)

Результат: 13.625₁₀ = 1101.101₂

Шаг 2: Нормализуем (сдвигаем точку до 1.xxxxx):
1101.101₂ = 1.101101₂ × 2³

Шаг 3: Записываем в IEEE 754 float (32 бита):
Знак S = 0 (положительное)
Экспонента: 3 + 127 = 130₁₀ = 10000010₂
Мантисса: 101101 (23 бита): 10110100000000000000000

Итоговое представление:
0 10000010 10110100000000000000000
│ └────┬───┘ └──────────┬───────────┘
│   Exp=130      Mantissa
Sign=0
```

### Специальные значения (внезапные гости)

#### 1. Ноль (±0)

```
+0: S=0, E=0, M=0  (все биты = 0)
−0: S=1, E=0, M=0
```

Да, существует −0. Полезно в некоторых вычислениях (сохранение знака при приближении к нулю).

#### 2. Бесконечность (±∞)

```
+∞: S=0, E=все единицы (255 для float), M=0
−∞: S=1, E=все единицы (255 для float), M=0
```

Возникает при делении на ноль или переполнении:
```
1.0 / 0.0 = +∞
−1.0 / 0.0 = −∞
```

#### 3. NaN (Not a Number) — любимец всех программистов

```
NaN: E=все единицы (255 для float), M≠0
```

Возникает при неопределённых операциях:
```
0.0 / 0.0 = NaN
∞ − ∞ = NaN
√(−1) = NaN (для вещественных)
```

**Важное свойство NaN:** Любая операция с NaN даёт NaN, включая сравнение. Даже `NaN == NaN` возвращает `false`! Это не баг, это фича.

#### 4. Денормализованные числа (Subnormal/Denormal)

**Денормализованные числа** используются для очень малых чисел, близких к нулю (экспонента = 0, мантисса ≠ 0).

```
Денормализованное: E=0, M≠0
Значение: (−1)^S × 0.ММММ × 2^(−126)  (для float)
```

Заполняют "щель" между нулём и минимальным нормализованным числом.

### Проблемы точности (почему 0.1 + 0.2 != 0.3)

#### Проблема 1: Конечная точность

Не все десятичные числа можно точно представить в двоичной форме.

**Пример:** Число 0.1₁₀ не имеет точного представления в двоичной:
```
0.1₁₀ = 0.0001100110011001100...₂  (бесконечная периодическая дробь)
```

В результате:
```python
# Python (аналогично в большинстве языков)
0.1 + 0.2 == 0.3  # False!
0.1 + 0.2          # 0.30000000000000004
```

Вот почему программисты плачут.

#### Проблема 2: Потеря точности при операциях с числами разного масштаба

При сложении очень большого и очень маленького числа младшие разряды маленького могут быть потеряны.

**Пример:**
```
10000000.0 + 0.00000001 ≈ 10000000.0  (в float точности не хватает)
```

#### Проблема 3: Накопление ошибок округления

При многократных операциях ошибки накапливаются.

**Пример:**
```python
x = 0.0
for i in range(10):
    x += 0.1
print(x)  # 0.9999999999999999 вместо 1.0
```

### Рекомендации по работе с вещественными числами (чтоб не обосраться)

1. **НЕ сравнивай вещественные числа на точное равенство**. Используй сравнение с погрешностью (epsilon):
   ```python
   epsilon = 1e-9
   if abs(a - b) < epsilon:
       # числа считаются равными
   ```

2. **Используй double вместо float**, если нужна бо́льшая точность.

3. **Для финансовых расчётов** используй специальные типы (Decimal в Python, BigDecimal в Java), которые работают с десятичными числами без потери точности.

4. **Будь осторожен с циклами**, где накапливаются ошибки.

5. **Избегай вычитания близких по значению чисел** — может быть катастрофическая потеря точности (catastrophic cancellation).

## Практические примеры (чтоб в башку уложилось)

### Пример 1: Представление числа в дополнительном коде

**Задача:** Представь число −42₁₀ в 8-битном дополнительном коде.

**Решение:**

Шаг 1: +42 в двоичном:
```
42₁₀ = 32 + 8 + 2 = 2⁵ + 2³ + 2¹
42₁₀ = 00101010₂
```

Шаг 2: Инвертируем все биты:
```
00101010 → 11010101
```

Шаг 3: Прибавляем 1:
```
  11010101
+        1
----------
  11010110
```

**Ответ:** −42₁₀ = 11010110₂

**Проверка:** Сложим +42 и −42:
```
  00101010  (+42)
+ 11010110  (−42)
----------
1 00000000

Старший бит переполнения отбрасывается → 00000000 = 0 ✓
```

### Пример 2: Декодирование из дополнительного кода

**Задача:** Какое десятичное число представляет 8-битный код 11100101₂ в дополнительном коде?

**Решение:**

Старший бит = 1 → число отрицательное.

Способ А (инверсия + 1 для получения модуля):
```
Шаг 1: Инвертируем:
11100101 → 00011010

Шаг 2: Прибавляем 1:
  00011010
+        1
----------
  00011011

Шаг 3: Переводим в десятичную:
00011011₂ = 16 + 8 + 2 + 1 = 27₁₀

Шаг 4: Добавляем знак:
Результат: −27₁₀
```

**Ответ:** 11100101₂ = −27₁₀

### Пример 3: Диапазоны представления

**Задача:** Определи диапазон значений для:
- a) 16-битных беззнаковых целых
- b) 16-битных знаковых целых (дополнительный код)

**Решение:**

a) **16-битные беззнаковые:**
```
Диапазон: 0 ... (2¹⁶ − 1)
Диапазон: 0 ... 65 535
```

b) **16-битные знаковые:**
```
Диапазон: −2¹⁵ ... (2¹⁵ − 1)
Диапазон: −32 768 ... +32 767
```

**Замечание:** В дополнительном коде модуль наименьшего отрицательного числа (|−32 768| = 32 768) больше наибольшего положительного (32 767) на единицу. Это из-за того, что существует только одно представление нуля.

### Пример 4: Переполнение

**Задача:** Используя 8-битную арифметику в дополнительном коде, вычисли:
- a) 100 + 50
- b) −100 − 50

**Решение:**

a) **100 + 50:**
```
+100₁₀ = 01100100₂
+50₁₀  = 00110010₂

  01100100
+ 00110010
----------
  10010110  (знаковый бит = 1, это минус!)

Декодируем: 10010110₂ = −128 + 16 + 4 + 2 = −106₁₀

Результат: 100 + 50 = −106 (переполнение!)
```

Правильный результат 150 выходит за пределы [−128, +127].

b) **−100 − 50:**
```
−100₁₀ = 10011100₂
−50₁₀  = 11001110₂

  10011100
+ 11001110
----------
1 01101010

Отбрасываем перенос: 01101010₂ = 64 + 32 + 8 + 2 = 106₁₀

Результат: −100 − 50 = 106 (переполнение!)
```

Правильный результат −150 выходит за пределы [−128, +127].

### Пример 5: Представление в IEEE 754 float

**Задача:** Представь число −6.25₁₀ в IEEE 754 single precision (32 бита).

**Решение:**

Шаг 1: Переводим модуль в двоичную:
```
6₁₀ = 110₂
0.25₁₀ = 0.01₂  (0.25 = 1/4 = 2⁻²)

6.25₁₀ = 110.01₂
```

Шаг 2: Нормализуем:
```
110.01₂ = 1.1001₂ × 2²
```

Шаг 3: Компоненты:
```
Знак S: 1 (отрицательное)
Экспонента: 2 + 127 = 129₁₀ = 10000001₂
Мантисса: 1001 (дополняем до 23 бит): 10010000000000000000000
```

Шаг 4: Собираем:
```
1 10000001 10010000000000000000000
```

**Ответ:** −6.25₁₀ в IEEE 754 float = `11000000110010000000000000000000₂` = `0xC0C80000`

### Пример 6: Проблема точности

**Задача:** Объясни, почему `0.1 + 0.1 + 0.1 == 0.3` может вернуть `false`.

**Объяснение:**

Число 0.1₁₀ не имеет точного представления в двоичной:
```
0.1₁₀ = 0.0001100110011001100...₂  (бесконечная периодическая)
```

При хранении в float/double происходит округление:
```
0.1 ≈ 0.1000000000000000055511151231257827...
```

При сложении трёх:
```
0.1 + 0.1 + 0.1 ≈ 0.30000000000000004
```

А число 0.3 тоже приближённо:
```
0.3 ≈ 0.2999999999999999888977...
```

Эти два значения не совпадают побитово → `==` возвращает `false`.

**Правильное сравнение:**
```python
epsilon = 1e-9
result = 0.1 + 0.1 + 0.1
expected = 0.3
if abs(result - expected) < epsilon:
    print("Числа равны (с погрешностью)")
```

## Типы данных в языках программирования

### Целые числа

| Язык       | Тип         | Размер  | Диапазон (знаковые)              |
| ---------- | ----------- | ------- | -------------------------------- |
| C/C++      | `char`      | 8 бит   | −128 ... 127                     |
|            | `short`     | 16 бит  | −32 768 ... 32 767               |
|            | `int`       | 32 бита | −2 147 483 648 ... 2 147 483 647 |
|            | `long long` | 64 бита | −2⁶³ ... (2⁶³−1)                 |
| Java       | `byte`      | 8 бит   | −128 ... 127                     |
|            | `short`     | 16 бит  | −32 768 ... 32 767               |
|            | `int`       | 32 бита | −2 147 483 648 ... 2 147 483 647 |
|            | `long`      | 64 бита | −2⁶³ ... (2⁶³−1)                 |
| Python 3   | `int`       | ∞       | Ограничен только памятью         |
| JavaScript | `Number`    | 53 бита | −(2⁵³−1) ... (2⁵³−1) (целые)    |

**Замечание:** В Python 3 тип `int` имеет произвольную точность (arbitrary precision) и может представлять сколь угодно большие целые числа.

### Вещественные числа

| Язык       | Тип      | Размер  | Точность         | Стандарт |
| ---------- | -------- | ------- | ---------------- | -------- |
| C/C++      | `float`  | 32 бита | ~7 дес. цифр     | IEEE 754 |
|            | `double` | 64 бита | ~15-16 дес. цифр | IEEE 754 |
| Java       | `float`  | 32 бита | ~7 дес. цифр     | IEEE 754 |
|            | `double` | 64 бита | ~15-16 дес. цифр | IEEE 754 |
| Python     | `float`  | 64 бита | ~15-16 дес. цифр | IEEE 754 |
| JavaScript | `Number` | 64 бита | ~15-16 дес. цифр | IEEE 754 |

## Практическое значение

### В архитектуре компьютеров

- **Регистры процессора:** 32-битные (x86) или 64-битные (x64)
- **АЛУ:** Выполняет операции в дополнительном коде для целых и по IEEE 754 для вещественных
- **FPU:** Специализированный блок для быстрых операций с плавающей точкой

### В программировании

- **Выбор типа данных:** Правильный выбор критичен для производительности и корректности
- **Финансовые расчёты:** Используй Decimal, а не float/double
- **Научные вычисления:** Используй double для точности, библиотеки произвольной точности для экстремальных требований

### В криптографии

- **Большие целые числа:** RSA, Diffie-Hellman оперируют числами размером 1024-4096 бит
- **Модульная арифметика:** Целочисленные операции с большими модулями

### В графике

- **Представление цвета:** RGB-компоненты — беззнаковые 8-битные целые (0-255)
- **Аудио:** Сэмплы — знаковые 16-битные или 24-битные целые
- **Координаты:** float/double для точности

## Связь с другими главами

- **Глава 1.1**: Арифметика в двоичной системе — операции с двоичными числами
- **Глава 1.2**: Представление данных в памяти — числа хранятся согласно рассмотренным форматам
- **Глава 1.11**: Системы счисления — перевод между системами
- **Раздел 2**: Архитектура ЭВМ — процессор выполняет операции с числами
- **Раздел 6**: Языки программирования — типы данных соответствуют форматам

## Ключевые термины (зубрить!)

**Беззнаковое целое** — неотрицательное целое, диапазон 0 ... (2ⁿ − 1).

**Знаковое целое** — целое, которое может быть положительным, отрицательным или нулём.

**Прямой код** — знак + модуль (не используется).

**Обратный код** — отрицательное = инверсия битов положительного (не используется).

**Дополнительный код** — стандартный способ представления знаковых чисел (отрицательное = инверсия + 1).

**Переполнение (overflow)** — результат операции выходит за пределы диапазона.

**Вещественное число** — число с дробной частью в формате с плавающей точкой.

**IEEE 754** — стандарт представления вещественных чисел.

**Нормализованная форма** — представление 1.xxxxx × 2^exp, старший бит мантиссы = 1.

**Мантисса** — часть числа, хранящая значащие цифры.

**Экспонента** — порядок (степень двойки).

**NaN** — Not a Number, результат неопределённой операции.

**Денормализованное число** — число с экспонентой = 0 и ненулевой мантиссой (очень малые числа).

## Контрольные вопросы

1. **В чём преимущество дополнительного кода** перед прямым и обратным? Почему современные компьютеры используют именно его?

2. **Представь число −100₁₀** в 8-битном дополнительном коде. Выполни проверку сложением.

3. **Определи диапазон значений** для 32-битных знаковых целых в дополнительном коде.

4. **Объясни структуру числа в IEEE 754 float.** Сколько бит на знак, экспоненту, мантиссу? Что такое "неявная единица"?

5. **Почему опасно сравнивать вещественные на точное равенство?** Как правильно сравнивать?

6. **Что такое NaN и когда оно возникает?** Какое свойство у NaN при сравнении с самим собой?

7. **Задача:** Декодируй 8-битный дополнительный код 10110011₂. Какое десятичное число?

8. **Что произойдёт при 127 + 1** в 8-битной знаковой арифметике? Объясни.

9. **Переведи число 5.75₁₀** в IEEE 754 float. Укажи знак, экспоненту, мантиссу в двоичном виде.

10. **Где критически важна точность?** Приведи примеры и объясни, какие типы использовать.

## Резюме

В этой главе мы разобрали:

1. ✅ **Представление целых:**
   - Беззнаковые (0 ... 2ⁿ−1)
   - Знаковые: прямой, обратный, дополнительный код
   - Дополнительный код — стандарт в ЭВМ
   - Проблема переполнения

2. ✅ **Представление вещественных:**
   - Формат IEEE 754 с плавающей точкой
   - Структура: знак, экспонента, мантисса
   - Float (32 бита) и Double (64 бита)
   - Нормализованная форма
   - Специальные значения: ±0, ±∞, NaN, денормализованные

3. ✅ **Проблемы точности:**
   - Конечная точность
   - Ошибки округления
   - Накопление ошибок
   - Правильные методы сравнения

4. ✅ **Практика:**
   - Типы данных в языках
   - Выбор подходящего типа
   - Применение в архитектуре, программировании, криптографии

Теперь ты умеешь:

- Представлять целые в дополнительном коде и декодировать их
- Понимать структуру чисел IEEE 754
- Объяснять причины ошибок точности
- Выбирать подходящие типы данных
- Рассчитывать диапазоны представления

Эти знания понадобятся в главе 1.11 (системы счисления), разделе 2 (архитектура ЭВМ), разделе 6 (программирование).

---

_Конец главы_
