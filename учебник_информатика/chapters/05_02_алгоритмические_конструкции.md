# Глава 5.2: Основные алгоритмические конструкции

## Введение

Окей, в прошлой главе мы разобрались, что алгоритм — это **пошаговая инструкция**. Но из чего эти шаги состоят? Можно ли как-то **систематизировать** эту хрень, чтобы не изобретать велосипед каждый раз?

Хорошие новости: **можно**. В 1966 году итальянские математики **Бём и Якопини** доказали теорему, которая изменила программирование навсегда (ну или хотя бы упростила жизнь студентам). Они показали, что **любой алгоритм** можно построить всего из **трёх базовых конструкций**:

1. **Последовательность** (линейный алгоритм)
2. **Ветвление** (условие)
3. **Цикл** (повторение)

Серьёзно, **любой** алгоритм. Сортировка массива? Три конструкции. Нейросеть? Три конструкции. Управление спутником? Три конструкции (ну и много математики, но суть та же).

**Эта глава связана с:**
- **Глава 5.1** (Алгоритм и свойства) — там мы определили алгоритм, здесь показываем из чего он строится
- **Глава 4.4** (Модели решения задач) — там были жадные алгоритмы и ДП, здесь — как их реализовать
- **Глава 6.1** (Языки программирования) — все языки содержат эти 3 конструкции
- **Глава 6.2** (Компиляторы и интерпретаторы) — как эти конструкции превращаются в машинный код

**Зачем это нужно?** Потому что это **основа основ**. Без этих конструкций ты не напишешь ни одной программы. И на экзамене обязательно спросят про ветвления и циклы. Так что читай внимательно.

---

## 5.2.1. Теорема Бёма-Якопини

### Формулировка

**Теорема Бёма-Якопини (1966):** Любой алгоритм можно составить из трёх базовых управляющих структур:

1. **Последовательность** — команды выполняются одна за другой
2. **Ветвление** — выбор одного из двух путей в зависимости от условия
3. **Цикл** — повторение последовательности команд

**Практический смысл:** Тебе не нужно придумывать какие-то новые конструкции. **Этих трёх достаточно** для решения любой задачи.

**Исторический контекст:** До 1960-х годов программы писали с кучей `GOTO` (прыжков по коду в произвольные места). Код был **нечитаемым кошмаром**. Бём и Якопини доказали, что можно обойтись без `GOTO`, используя только эти три конструкции. Так родилось **структурное программирование**.

**Забавный факт:** Эдсгер Дейкстра в 1968 году написал знаменитую статью **"Go To Statement Considered Harmful"** ("Оператор GOTO вреден"). После этого программисты начали массово отказываться от `GOTO` и переходить на структурное программирование. Хотя в современных языках (C, C++, Go) `goto` всё ещё есть, но его использование считается дурным тоном (если ты не пишешь ядро операционной системы).

---

## 5.2.2. Последовательность (линейный алгоритм)

### Определение

**Последовательность (линейный алгоритм)** — это **простое выполнение команд одна за другой**, без условий и повторений.

**Схема:**
```
Команда 1
   ↓
Команда 2
   ↓
Команда 3
   ↓
...
```

Каждая команда выполняется **ровно один раз**, в строгом порядке. Никаких прыжков, никаких "если", никаких циклов.

---

### Пример 1: Вычисление площади прямоугольника

**Словесное описание:**
```
1. Ввести длину a
2. Ввести ширину b
3. Вычислить площадь S = a × b
4. Вывести S
```

**Блок-схема:**
```
    ⬭ Начало
      |
      ↓
  ▱ Ввести a
      |
      ↓
  ▱ Ввести b
      |
      ↓
  ▭ S = a × b
      |
      ↓
  ▱ Вывести S
      |
      ↓
    ⬭ Конец
```

**Псевдокод:**
```
Алгоритм ПлощадьПрямоугольника:
    Ввести a
    Ввести b
    S = a × b
    Вывести S
```

**Программный код (Python):**
```python
a = float(input("Длина: "))
b = float(input("Ширина: "))
S = a * b
print(f"Площадь: {S}")
```

**Выполнение:**
```
Длина: 5
Ширина: 3
Площадь: 15
```

Просто и понятно. Никаких условий, никаких повторений. **Линейный алгоритм** — это когда ты идёшь прямо, как по рельсам.

---

### Пример 2: Обмен значений двух переменных

**Задача:** Поменять местами значения двух переменных `a` и `b`.

**Неправильное решение (частая ошибка):**
```python
a = b  # Теперь a = b, но старое значение a потеряно
b = a  # b = a (но a уже изменилось), поэтому b = b
```

**Результат:** `a = b`, `b = b`. Значение `a` потеряно. Поздравляю, ты только что сделал **классическую ошибку новичка**.

**Правильное решение (с временной переменной):**
```python
temp = a  # Сохранили старое значение a
a = b     # Присвоили a значение b
b = temp  # Присвоили b старое значение a
```

**Программный код (Python):**
```python
a = 5
b = 10
print(f"До обмена: a = {a}, b = {b}")

temp = a
a = b
b = temp

print(f"После обмена: a = {a}, b = {b}")
```

**Вывод:**
```
До обмена: a = 5, b = 10
После обмена: a = 10, b = 5
```

**Красивый способ в Python (без temp):**
```python
a, b = b, a
```

Это работает благодаря **множественному присваиванию** (tuple unpacking). Но это специфика Python — в C++ или Java так не сделаешь.

---

### Пример 3: Вычисление дискриминанта квадратного уравнения

**Задача:** Для уравнения \(ax^2 + bx + c = 0\) вычислить дискриминант \(D = b^2 - 4ac\).

**Псевдокод:**
```
Алгоритм Дискриминант:
    Ввести a, b, c
    D = b² - 4 × a × c
    Вывести D
```

**Программный код (Python):**
```python
a = float(input("a = "))
b = float(input("b = "))
c = float(input("c = "))
D = b**2 - 4*a*c
print(f"Дискриминант: {D}")
```

**Выполнение:**
```
a = 1
b = -5
c = 6
Дискриминант: 1.0
```

(Для любопытных: \(x^2 - 5x + 6 = 0 \Rightarrow x_1 = 2, x_2 = 3\))

---

### Когда использовать последовательность?

- **Простые вычисления** (площадь, объём, формулы)
- **Преобразование данных** (перевод температуры, валюты)
- **Вывод информации** (приветствие, инструкция)

**Ограничения:** Линейный алгоритм **не может принимать решения** (для этого нужно ветвление) и **не может повторяться** (для этого нужен цикл).

---

## 5.2.3. Ветвление (условный оператор)

### Определение

**Ветвление (условный оператор)** — это конструкция, которая **выбирает** один из двух (или более) путей выполнения в зависимости от **условия**.

**Схема:**
```
    ◇ Условие?
    /       \
  Да         Нет
  /           \
Действие 1  Действие 2
```

Если условие **истинно** (True) — выполняется одна ветка. Если **ложно** (False) — другая.

---

### Виды ветвлений

#### 1. Полное ветвление (if-else)

**Есть два пути:** одно действие, если условие истинно, другое — если ложно.

**Синтаксис (псевдокод):**
```
Если <условие>, то:
    <действие 1>
Иначе:
    <действие 2>
```

**Синтаксис (Python):**
```python
if условие:
    действие_1
else:
    действие_2
```

**Пример: Проверка числа на чётность**

```python
n = int(input("Введите число: "))
if n % 2 == 0:
    print("Чётное")
else:
    print("Нечётное")
```

**Выполнение:**
```
Введите число: 7
Нечётное
```

---

#### 2. Неполное ветвление (if без else)

**Один путь:** если условие истинно — выполняем действие, иначе — ничего не делаем.

**Синтаксис (псевдокод):**
```
Если <условие>, то:
    <действие>
```

**Пример: Проверка на отрицательность**

```python
x = int(input("Введите число: "))
if x < 0:
    print("Число отрицательное")
# Если x >= 0, ничего не происходит
```

**Выполнение (x = -5):**
```
Введите число: -5
Число отрицательное
```

**Выполнение (x = 10):**
```
Введите число: 10
(Ничего не выводится)
```

---

#### 3. Множественное ветвление (if-elif-else)

**Несколько условий проверяются последовательно.** Как только одно из них истинно — выполняется соответствующее действие, остальные пропускаются.

**Синтаксис (Python):**
```python
if условие_1:
    действие_1
elif условие_2:
    действие_2
elif условие_3:
    действие_3
else:
    действие_по_умолчанию
```

**Пример: Определение знака числа**

```python
x = int(input("Введите число: "))
if x > 0:
    print("Положительное")
elif x < 0:
    print("Отрицательное")
else:
    print("Ноль")
```

**Выполнение:**
```
Введите число: -3
Отрицательное
```

---

#### 4. Вложенные условия (if внутри if)

**Условие внутри условия.** Нужно для **сложных проверок**.

**Пример: Нахождение максимума из трёх чисел**

```python
a = int(input("a = "))
b = int(input("b = "))
c = int(input("c = "))

if a >= b:
    if a >= c:
        max_val = a
    else:
        max_val = c
else:
    if b >= c:
        max_val = b
    else:
        max_val = c

print(f"Максимум: {max_val}")
```

**Выполнение:**
```
a = 5
b = 12
c = 8
Максимум: 12
```

**Альтернативный способ (без вложенности):**
```python
a = 5
b = 12
c = 8
max_val = max(a, b, c)
print(f"Максимум: {max_val}")
```

Встроенная функция `max()` — это **красота**. Но на экзамене тебя могут попросить написать **вручную**, так что знай оба способа.

---

### Пример: Решение квадратного уравнения

**Задача:** Решить уравнение \(ax^2 + bx + c = 0\).

**Алгоритм:**
1. Вычислить дискриминант \(D = b^2 - 4ac\)
2. Если \(D > 0\) — два корня: \(x_1 = \frac{-b + \sqrt{D}}{2a}\), \(x_2 = \frac{-b - \sqrt{D}}{2a}\)
3. Если \(D = 0\) — один корень: \(x = \frac{-b}{2a}\)
4. Если \(D < 0\) — корней нет (в действительных числах)

**Программный код (Python):**
```python
import math

a = float(input("a = "))
b = float(input("b = "))
c = float(input("c = "))

D = b**2 - 4*a*c

if D > 0:
    x1 = (-b + math.sqrt(D)) / (2*a)
    x2 = (-b - math.sqrt(D)) / (2*a)
    print(f"Два корня: x1 = {x1}, x2 = {x2}")
elif D == 0:
    x = -b / (2*a)
    print(f"Один корень: x = {x}")
else:
    print("Корней нет (дискриминант отрицательный)")
```

**Выполнение (D > 0):**
```
a = 1
b = -3
c = 2
Два корня: x1 = 2.0, x2 = 1.0
```

**Выполнение (D = 0):**
```
a = 1
b = -2
c = 1
Один корень: x = 1.0
```

**Выполнение (D < 0):**
```
a = 1
b = 0
c = 1
Корней нет (дискриминант отрицательный)
```

---

### Switch-case (множественный выбор)

В языках типа C++, Java, Go есть конструкция **switch-case** для удобного множественного выбора.

**Синтаксис (C++):**
```cpp
switch (переменная) {
    case значение1:
        действие1;
        break;
    case значение2:
        действие2;
        break;
    default:
        действие_по_умолчанию;
}
```

**Пример: Меню выбора операции**

```cpp
#include <iostream>
using namespace std;

int main() {
    int choice;
    cout << "Выберите операцию (1-4): ";
    cin >> choice;

    switch (choice) {
        case 1:
            cout << "Сложение" << endl;
            break;
        case 2:
            cout << "Вычитание" << endl;
            break;
        case 3:
            cout << "Умножение" << endl;
            break;
        case 4:
            cout << "Деление" << endl;
            break;
        default:
            cout << "Неверный выбор" << endl;
    }

    return 0;
}
```

**Важно:** В C++ **обязательно** ставить `break`, иначе выполнение "провалится" в следующий `case` (это называется **fall-through**). В Python **нет** `switch` до версии 3.10 (там добавили `match-case`).

---

## 5.2.4. Цикл с предусловием (while)

### Определение

**Цикл с предусловием (while)** — это конструкция, которая **повторяет** блок команд, **пока условие истинно**.

**Схема:**
```
    ◇ Условие?
    /       \
  Да         Нет
  /           \
Тело цикла   Выход
  |
  ↓
(вернуться к проверке условия)
```

**Ключевая особенность:** Условие проверяется **перед** выполнением тела цикла. Если условие сразу ложно — тело **не выполнится ни разу**.

**Синтаксис (псевдокод):**
```
Пока <условие>:
    <тело цикла>
```

**Синтаксис (Python):**
```python
while условие:
    тело_цикла
```

---

### Пример 1: Вывод чисел от 1 до 10

**Программный код (Python):**
```python
i = 1
while i <= 10:
    print(i)
    i += 1
```

**Вывод:**
```
1
2
3
4
5
6
7
8
9
10
```

**Пошаговое выполнение:**
```
Шаг 1: i = 1, i <= 10? Да → вывод 1, i = 2
Шаг 2: i = 2, i <= 10? Да → вывод 2, i = 3
...
Шаг 10: i = 10, i <= 10? Да → вывод 10, i = 11
Шаг 11: i = 11, i <= 10? Нет → выход из цикла
```

---

### Пример 2: Факториал числа

**Задача:** Вычислить \(n! = 1 \times 2 \times 3 \times ... \times n\).

**Псевдокод:**
```
Алгоритм Факториал(n):
    result = 1
    i = 1
    Пока i <= n:
        result = result × i
        i = i + 1
    Вернуть result
```

**Программный код (Python):**
```python
n = int(input("Введите число: "))
result = 1
i = 1
while i <= n:
    result *= i
    i += 1
print(f"{n}! = {result}")
```

**Выполнение:**
```
Введите число: 5
5! = 120
```

**Пошаговое выполнение:**
```
i = 1: result = 1 × 1 = 1
i = 2: result = 1 × 2 = 2
i = 3: result = 2 × 3 = 6
i = 4: result = 6 × 4 = 24
i = 5: result = 24 × 5 = 120
i = 6: i > n → выход
```

---

### Пример 3: Алгоритм Евклида (НОД)

**Задача:** Найти наибольший общий делитель (НОД) двух чисел.

**Алгоритм:**
```
Пока b ≠ 0:
    r = a mod b
    a = b
    b = r
Вернуть a
```

**Программный код (Python):**
```python
a = int(input("a = "))
b = int(input("b = "))

while b != 0:
    a, b = b, a % b

print(f"НОД = {a}")
```

**Выполнение:**
```
a = 48
b = 18
НОД = 6
```

---

### Когда цикл не выполнится ни разу?

Если условие **изначально ложно**, тело цикла **не выполнится**.

**Пример:**
```python
i = 20
while i <= 10:
    print(i)  # Не выполнится
    i += 1
```

Условие `i <= 10` сразу ложно (20 > 10), поэтому цикл пропускается.

---

## 5.2.5. Цикл с постусловием (do-while)

### Определение

**Цикл с постусловием (do-while)** — это конструкция, которая **сначала выполняет тело цикла**, а **затем проверяет условие**.

**Ключевая особенность:** Тело цикла выполнится **хотя бы один раз**, даже если условие изначально ложно.

**Схема:**
```
    Тело цикла
      |
      ↓
    ◇ Условие?
    /       \
  Да         Нет
  /           \
(повторить)  Выход
```

**Синтаксис (псевдокод):**
```
Выполнить:
    <тело цикла>
Пока <условие>
```

**Синтаксис (C++):**
```cpp
do {
    тело_цикла;
} while (условие);
```

**В Python нет do-while.** Но можно **эмулировать**:

```python
while True:
    тело_цикла
    if not условие:
        break
```

---

### Пример: Ввод числа с проверкой

**Задача:** Запросить у пользователя число от 1 до 10. Если ввёл не то — запросить снова.

**Программный код (C++):**
```cpp
#include <iostream>
using namespace std;

int main() {
    int n;
    do {
        cout << "Введите число от 1 до 10: ";
        cin >> n;
    } while (n < 1 || n > 10);

    cout << "Вы ввели: " << n << endl;
    return 0;
}
```

**Выполнение:**
```
Введите число от 1 до 10: 15
Введите число от 1 до 10: 0
Введите число от 1 до 10: 7
Вы ввели: 7
```

**Почему do-while?** Потому что нужно **хотя бы раз** спросить у пользователя число. С обычным `while` пришлось бы дублировать код.

**Эмуляция в Python:**
```python
while True:
    n = int(input("Введите число от 1 до 10: "))
    if 1 <= n <= 10:
        break
print(f"Вы ввели: {n}")
```

---

### Когда использовать do-while?

- **Ввод данных с проверкой** (пока пользователь не введёт правильное значение)
- **Меню программы** (показать меню хотя бы один раз, затем повторять по выбору пользователя)

---

## 5.2.6. Цикл со счётчиком (for)

### Определение

**Цикл со счётчиком (for)** — это конструкция для **повторения действий заданное количество раз**.

**Ключевая особенность:** Используется, когда **заранее известно**, сколько раз нужно выполнить цикл.

**Синтаксис (псевдокод):**
```
Для i от начало до конец:
    <тело цикла>
```

**Синтаксис (Python):**
```python
for i in range(начало, конец):
    тело_цикла
```

**Синтаксис (C++):**
```cpp
for (инициализация; условие; инкремент) {
    тело_цикла;
}
```

---

### Пример 1: Вывод чисел от 1 до 10

**Python:**
```python
for i in range(1, 11):  # range(1, 11) даёт [1, 2, ..., 10]
    print(i)
```

**C++:**
```cpp
for (int i = 1; i <= 10; i++) {
    cout << i << endl;
}
```

**Вывод:**
```
1
2
3
...
10
```

---

### Пример 2: Сумма элементов массива

**Задача:** Найти сумму всех элементов массива.

**Python:**
```python
arr = [3, 7, 2, 9, 5]
total = 0
for num in arr:
    total += num
print(f"Сумма: {total}")
```

**Вывод:**
```
Сумма: 26
```

**C++:**
```cpp
int arr[] = {3, 7, 2, 9, 5};
int n = 5;
int total = 0;
for (int i = 0; i < n; i++) {
    total += arr[i];
}
cout << "Сумма: " << total << endl;
```

---

### Пример 3: Таблица умножения

**Задача:** Вывести таблицу умножения для числа 5.

**Python:**
```python
n = 5
for i in range(1, 11):
    print(f"{n} × {i} = {n * i}")
```

**Вывод:**
```
5 × 1 = 5
5 × 2 = 10
5 × 3 = 15
...
5 × 10 = 50
```

---

### Пример 4: Факториал числа (цикл for)

**Python:**
```python
n = 5
result = 1
for i in range(1, n + 1):
    result *= i
print(f"{n}! = {result}")
```

**Вывод:**
```
5! = 120
```

---

## 5.2.7. Вложенные циклы

### Определение

**Вложенные циклы** — это **цикл внутри цикла**. Используется для работы с **многомерными данными** (таблицы, матрицы) или для **перебора всех комбинаций**.

**Схема:**
```
Для i от 1 до n:
    Для j от 1 до m:
        действие(i, j)
```

**Сложность:** Если внешний цикл выполняется n раз, а внутренний — m раз, то тело внутреннего цикла выполнится **n × m раз**. Если n = m, то сложность **O(n²)**.

---

### Пример 1: Таблица умножения (полная)

**Задача:** Вывести таблицу умножения от 1 до 10.

**Python:**
```python
for i in range(1, 11):
    for j in range(1, 11):
        print(f"{i} × {j} = {i * j}")
    print()  # Пустая строка после каждой таблицы
```

**Вывод (фрагмент):**
```
1 × 1 = 1
1 × 2 = 2
...
1 × 10 = 10

2 × 1 = 2
2 × 2 = 4
...
```

---

### Пример 2: Матрица (двумерный массив)

**Задача:** Вывести все элементы матрицы 3×3.

**Python:**
```python
matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]

for i in range(3):
    for j in range(3):
        print(matrix[i][j], end=" ")
    print()  # Переход на новую строку
```

**Вывод:**
```
1 2 3
4 5 6
7 8 9
```

---

### Пример 3: Проверка числа на простоту

**Задача:** Проверить, является ли число `n` простым (делится только на 1 и на себя).

**Алгоритм:**
- Перебираем все числа от 2 до \(\sqrt{n}\)
- Если хотя бы одно из них делит `n` — число составное
- Если ни одно не делит — число простое

**Python:**
```python
import math

n = int(input("Введите число: "))

if n < 2:
    print("Не простое")
else:
    is_prime = True
    for i in range(2, int(math.sqrt(n)) + 1):
        if n % i == 0:
            is_prime = False
            break  # Нашли делитель, дальше проверять не нужно
    
    if is_prime:
        print("Простое")
    else:
        print("Не простое")
```

**Выполнение:**
```
Введите число: 29
Простое
```

**Почему до \(\sqrt{n}\)?** Потому что если у числа есть делитель больше \(\sqrt{n}\), то обязательно есть делитель меньше \(\sqrt{n}\). Например, для 36: \(36 = 6 \times 6\), \(36 = 4 \times 9\), \(36 = 2 \times 18\). Все делители больше 6 имеют парные делители меньше 6. Так что проверять дальше 6 смысла нет.

---

### Пример 4: Треугольник из звёздочек

**Задача:** Вывести треугольник:
```
*
**
***
****
*****
```

**Python:**
```python
n = 5
for i in range(1, n + 1):
    for j in range(i):
        print("*", end="")
    print()
```

**Пошаговое выполнение:**
```
i = 1: выводим 1 звёздочку
i = 2: выводим 2 звёздочки
i = 3: выводим 3 звёздочки
...
```

---

## 5.2.8. Операторы управления циклом: break и continue

### break (досрочный выход из цикла)

**break** — немедленно **прерывает выполнение цикла** и выходит из него.

**Пример: Поиск первого делителя числа**

```python
n = int(input("Введите число: "))
for i in range(2, n):
    if n % i == 0:
        print(f"Первый делитель: {i}")
        break  # Нашли делитель, дальше искать не нужно
```

**Выполнение:**
```
Введите число: 100
Первый делитель: 2
```

Без `break` цикл продолжил бы перебирать все числа от 2 до 99, хотя ответ уже найден.

---

### continue (переход к следующей итерации)

**continue** — **пропускает оставшуюся часть тела цикла** и переходит к следующей итерации.

**Пример: Вывод только нечётных чисел от 1 до 10**

```python
for i in range(1, 11):
    if i % 2 == 0:
        continue  # Пропускаем чётные числа
    print(i)
```

**Вывод:**
```
1
3
5
7
9
```

**Без continue (альтернативный способ):**
```python
for i in range(1, 11):
    if i % 2 != 0:
        print(i)
```

Оба способа работают одинаково. `continue` полезен, когда нужно **пропустить сложную логику** для некоторых элементов.

---

### Разница между break и continue

| Оператор   | Действие                               | Когда использовать                      |
| ---------- | -------------------------------------- | --------------------------------------- |
| **break**  | Выход из цикла                         | Найден ответ, дальше искать не нужно    |
| **continue** | Переход к следующей итерации          | Пропустить текущий элемент              |

**Пример: Поиск и вывод всех простых чисел до 50**

```python
for n in range(2, 51):
    is_prime = True
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            is_prime = False
            break  # Нашли делитель, n не простое
    if is_prime:
        print(n)
```

**Вывод:**
```
2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47
```

---

## 5.2.9. Бесконечные циклы

### Что такое бесконечный цикл?

**Бесконечный цикл** — это цикл, который **никогда не завершается** (условие всегда истинно).

**Пример (нарочно):**
```python
while True:
    print("Привет")
```

Этот цикл будет выводить "Привет" **вечно**, пока ты не нажмёшь `Ctrl+C` (прерывание программы).

---

### Когда бесконечные циклы полезны?

1. **Серверы** — слушают запросы постоянно
2. **Игровые циклы** — игра работает, пока игрок не закроет её
3. **Операционные системы** — работают "бесконечно"
4. **Меню программы** — повторяется, пока пользователь не выберет "Выход"

**Пример: Меню программы**

```python
while True:
    print("\nМеню:")
    print("1. Сложение")
    print("2. Вычитание")
    print("3. Выход")
    choice = int(input("Выбор: "))
    
    if choice == 1:
        a = float(input("a = "))
        b = float(input("b = "))
        print(f"Сумма: {a + b}")
    elif choice == 2:
        a = float(input("a = "))
        b = float(input("b = "))
        print(f"Разность: {a - b}")
    elif choice == 3:
        print("Выход из программы")
        break  # Выход из бесконечного цикла
    else:
        print("Неверный выбор")
```

**Выполнение:**
```
Меню:
1. Сложение
2. Вычитание
3. Выход
Выбор: 1
a = 5
b = 3
Сумма: 8

Меню:
1. Сложение
2. Вычитание
3. Выход
Выбор: 3
Выход из программы
```

---

### Как избежать нежелательных бесконечных циклов?

**Частая ошибка новичков:**
```python
i = 1
while i <= 10:
    print(i)
    # Забыли написать i += 1
```

Переменная `i` **не изменяется**, условие `i <= 10` всегда истинно → бесконечный цикл.

**Правильно:**
```python
i = 1
while i <= 10:
    print(i)
    i += 1  # Не забывай!
```

---

## 5.2.10. Примеры задач

Теперь давайте разберём **10 задач**, которые показывают применение всех трёх конструкций.

---

### Задача 1: Факториал числа

**Задача:** Вычислить \(n!\).

**Программный код (Python):**
```python
n = int(input("n = "))
result = 1
for i in range(1, n + 1):
    result *= i
print(f"{n}! = {result}")
```

**Выполнение:**
```
n = 6
6! = 720
```

---

### Задача 2: Сумма цифр числа

**Задача:** Найти сумму цифр числа. Например, для 1234 сумма = 1 + 2 + 3 + 4 = 10.

**Алгоритм:**
1. Берём последнюю цифру: `n % 10`
2. Прибавляем к сумме
3. Отбрасываем последнюю цифру: `n = n // 10`
4. Повторяем, пока `n != 0`

**Программный код (Python):**
```python
n = int(input("Введите число: "))
total = 0
while n > 0:
    total += n % 10
    n //= 10
print(f"Сумма цифр: {total}")
```

**Выполнение:**
```
Введите число: 1234
Сумма цифр: 10
```

**Пошаговое выполнение:**
```
n = 1234: последняя цифра = 4, total = 4, n = 123
n = 123:  последняя цифра = 3, total = 7, n = 12
n = 12:   последняя цифра = 2, total = 9, n = 1
n = 1:    последняя цифра = 1, total = 10, n = 0
n = 0 → выход
```

---

### Задача 3: Реверс числа

**Задача:** Перевернуть число. Например, 1234 → 4321.

**Алгоритм:**
1. Берём последнюю цифру: `digit = n % 10`
2. Добавляем к результату: `reversed = reversed × 10 + digit`
3. Отбрасываем последнюю цифру: `n = n // 10`
4. Повторяем, пока `n != 0`

**Программный код (Python):**
```python
n = int(input("Введите число: "))
reversed_n = 0
while n > 0:
    reversed_n = reversed_n * 10 + n % 10
    n //= 10
print(f"Перевёрнутое: {reversed_n}")
```

**Выполнение:**
```
Введите число: 1234
Перевёрнутое: 4321
```

**Пошаговое выполнение:**
```
n = 1234: digit = 4, reversed = 0×10 + 4 = 4, n = 123
n = 123:  digit = 3, reversed = 4×10 + 3 = 43, n = 12
n = 12:   digit = 2, reversed = 43×10 + 2 = 432, n = 1
n = 1:    digit = 1, reversed = 432×10 + 1 = 4321, n = 0
n = 0 → выход
```

---

### Задача 4: Числа Фибоначчи

**Задача:** Вывести первые n чисел Фибоначчи.

**Последовательность Фибоначчи:** \(F_0 = 0, F_1 = 1, F_n = F_{n-1} + F_{n-2}\).

**Программный код (Python):**
```python
n = int(input("Сколько чисел вывести: "))
a, b = 0, 1
for _ in range(n):
    print(a, end=" ")
    a, b = b, a + b
```

**Выполнение:**
```
Сколько чисел вывести: 10
0 1 1 2 3 5 8 13 21 34
```

---

### Задача 5: Проверка на простоту

**Задача:** Проверить, является ли число простым.

**Программный код (Python):**
```python
import math

n = int(input("Введите число: "))

if n < 2:
    print("Не простое")
else:
    is_prime = True
    for i in range(2, int(math.sqrt(n)) + 1):
        if n % i == 0:
            is_prime = False
            break
    
    print("Простое" if is_prime else "Не простое")
```

**Выполнение:**
```
Введите число: 17
Простое
```

---

### Задача 6: Поиск минимума и максимума в массиве

**Задача:** Найти минимальный и максимальный элемент массива.

**Программный код (Python):**
```python
arr = [3, 7, 2, 9, 5, 1, 8]
min_val = arr[0]
max_val = arr[0]

for num in arr:
    if num < min_val:
        min_val = num
    if num > max_val:
        max_val = num

print(f"Минимум: {min_val}, Максимум: {max_val}")
```

**Вывод:**
```
Минимум: 1, Максимум: 9
```

---

### Задача 7: Подсчёт элементов с условием

**Задача:** Подсчитать количество чётных чисел в массиве.

**Программный код (Python):**
```python
arr = [3, 7, 2, 9, 5, 1, 8, 4]
count = 0

for num in arr:
    if num % 2 == 0:
        count += 1

print(f"Количество чётных: {count}")
```

**Вывод:**
```
Количество чётных: 3
```

---

### Задача 8: Таблица квадратов

**Задача:** Вывести таблицу квадратов чисел от 1 до 10.

**Программный код (Python):**
```python
for i in range(1, 11):
    print(f"{i}² = {i**2}")
```

**Вывод:**
```
1² = 1
2² = 4
3² = 9
...
10² = 100
```

---

### Задача 9: Сумма чётных чисел от 1 до N

**Задача:** Найти сумму всех чётных чисел от 1 до N.

**Программный код (Python):**
```python
n = int(input("N = "))
total = 0
for i in range(2, n + 1, 2):  # range с шагом 2
    total += i
print(f"Сумма чётных: {total}")
```

**Выполнение:**
```
N = 10
Сумма чётных: 30
```

(2 + 4 + 6 + 8 + 10 = 30)

---

### Задача 10: Двумерный массив — сумма всех элементов

**Задача:** Найти сумму всех элементов матрицы 3×3.

**Программный код (Python):**
```python
matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]

total = 0
for i in range(3):
    for j in range(3):
        total += matrix[i][j]

print(f"Сумма всех элементов: {total}")
```

**Вывод:**
```
Сумма всех элементов: 45
```

(1+2+3+4+5+6+7+8+9 = 45)

---

## Термины и определения

**Теорема Бёма-Якопини** — доказательство того, что любой алгоритм можно построить из трёх конструкций: последовательность, ветвление, цикл.

**Последовательность (линейный алгоритм)** — выполнение команд одна за другой, без условий и повторений.

**Ветвление (условный оператор)** — выбор одного из путей выполнения в зависимости от условия.

**Полное ветвление** — есть ветка для "истина" и для "ложь" (if-else).

**Неполное ветвление** — есть только ветка для "истина" (if без else).

**Множественное ветвление** — несколько условий проверяются последовательно (if-elif-else или switch-case).

**Вложенные условия** — условие внутри условия (if внутри if).

**Цикл с предусловием (while)** — условие проверяется **до** выполнения тела цикла. Может не выполниться ни разу.

**Цикл с постусловием (do-while)** — условие проверяется **после** выполнения тела цикла. Выполняется хотя бы один раз.

**Цикл со счётчиком (for)** — повторение действий заданное количество раз (известно заранее).

**Вложенные циклы** — цикл внутри цикла. Используется для многомерных данных или перебора всех комбинаций.

**break** — досрочный выход из цикла.

**continue** — переход к следующей итерации цикла (пропуск оставшейся части тела).

**Бесконечный цикл** — цикл, который никогда не завершается (условие всегда истинно). Используется в серверах, игровых циклах, ОС.

**Сложность O(n²)** — характерна для двух вложенных циклов по n итераций.

---

## Контрольные вопросы

### Теоретические:

1. **Сформулируйте теорему Бёма-Якопини.**  
   _Подсказка: любой алгоритм можно построить из трёх конструкций._

2. **Назовите три базовые алгоритмические конструкции.**  
   _Ответ: последовательность, ветвление, цикл._

3. **Чем отличается полное ветвление от неполного?**  
   _Подсказка: полное — if-else, неполное — if без else._

4. **Чем отличается while от do-while?**  
   _Подсказка: while проверяет условие до выполнения, do-while — после. do-while выполнится хотя бы один раз._

5. **Когда использовать цикл for, а когда while?**  
   _Подсказка: for — когда известно количество итераций, while — когда неизвестно (зависит от условия)._

6. **Что делает оператор break? А continue?**  
   _Ответ: break — выход из цикла, continue — переход к следующей итерации._

7. **Какая сложность у алгоритма с двумя вложенными циклами (n × n)?**  
   _Ответ: O(n²)._

8. **Когда бесконечный цикл — это нормально?**  
   _Подсказка: серверы, игровые циклы, ОС, меню программы._

### Практические:

9. **Задача:** Напишите псевдокод алгоритма, который проверяет, чётное ли число.  
   _Ответ:_
   ```
   Ввести n
   Если n mod 2 = 0, то:
       Вывести "Чётное"
   Иначе:
       Вывести "Нечётное"
   ```

10. **Задача:** Найдите сумму чисел от 1 до 100 с помощью цикла.  
    _Ответ:_
    ```python
    total = 0
    for i in range(1, 101):
        total += i
    print(total)  # 5050
    ```

11. **Задача:** Напишите алгоритм, который выводит все числа от 10 до 1 (в обратном порядке).  
    _Ответ:_
    ```python
    for i in range(10, 0, -1):
        print(i)
    ```

12. **Задача:** Напишите алгоритм, который считает сумму цифр числа 9876.  
    _Ответ:_
    ```python
    n = 9876
    total = 0
    while n > 0:
        total += n % 10
        n //= 10
    print(total)  # 30
    ```

13. **Задача:** Напишите алгоритм, который проверяет, является ли число 29 простым.  
    _Ответ:_
    ```python
    import math
    n = 29
    is_prime = True
    for i in range(2, int(math.sqrt(n)) + 1):
        if n % i == 0:
            is_prime = False
            break
    print("Простое" if is_prime else "Не простое")  # Простое
    ```

14. **Задача:** Напишите алгоритм, который выводит первые 8 чисел Фибоначчи.  
    _Ответ:_
    ```python
    a, b = 0, 1
    for _ in range(8):
        print(a, end=" ")
        a, b = b, a + b
    # Вывод: 0 1 1 2 3 5 8 13
    ```

15. **Задача:** Найдите максимум в массиве [12, 7, 19, 3, 25, 10].  
    _Ответ:_
    ```python
    arr = [12, 7, 19, 3, 25, 10]
    max_val = arr[0]
    for num in arr:
        if num > max_val:
            max_val = num
    print(max_val)  # 25
    ```

---

## Заключение

Поздравляю, теперь ты знаешь **три кита программирования**: последовательность, ветвление, цикл. Серьёзно, это **всё**, что нужно для написания любой программы (ну почти).

**Главное, что нужно запомнить:**

1. **Теорема Бёма-Якопини:** Любой алгоритм = последовательность + ветвление + цикл.
2. **Последовательность** — команды выполняются по порядку (линейный алгоритм).
3. **Ветвление (if-else)** — выбор пути в зависимости от условия.
4. **Цикл while** — повторение, пока условие истинно (проверка **до** выполнения).
5. **Цикл do-while** — повторение, пока условие истинно (проверка **после** выполнения, выполнится хотя бы один раз).
6. **Цикл for** — повторение заданное количество раз (счётчик известен).
7. **Вложенные циклы** — цикл внутри цикла (сложность O(n²)).
8. **break** — выход из цикла, **continue** — переход к следующей итерации.
9. **Бесконечный цикл** — полезен для серверов, игр, ОС, меню.

На экзамене могут попросить:
- Написать псевдокод с if-else → помни про полное/неполное ветвление
- Написать цикл для вычисления факториала → используй for или while
- Оценить сложность вложенных циклов → n × m = O(n²), если n = m
- Найти ошибку в коде (бесконечный цикл, забыли i += 1) → проверяй условие выхода

**Следующая глава:** 6.1 Классификация языков программирования (разберём языки низкого/высокого уровня, компилируемые/интерпретируемые, парадигмы)  
**Предыдущая глава:** 5.1 Алгоритм и его свойства. Способы описания

Теперь у тебя есть весь инструментарий для написания алгоритмов. Осталось применить его на практике (и не забыть на экзамене). Удачи!
